//import zkeSDK, { Proof };
import zkeSDK, {
    Proof,
    testDecomposedRegex,
    parseEmail,
    generateProofInputs,  /// @dev - Imported from the relayerUtils.ts of the zkemail/zk-email-sdk-js/src
    testBlueprint,
    getMaxEmailBodyLength,
    extractEMLDetails,
    generateDfa,
} from "@zk-email/sdk";  /// @dev - Import the zkEmail Blueprint SDK


/**
 * @notice - Create new Blueprint with a given props (BlueprintProps struct data).
 */
export async function createNewBlueprint(
    props: BlueprintProps
): Promise<{ blueprint: any }> {
    const sdk = zkeSDK();
    const blueprint = await sdk.createBlueprint(props);
    console.log(`blueprint: ${JSON.stringify(blueprint, null, 2)}`);

    return { blueprint };
}


/**
 * @notice - Generate a ZK Proof from the raw email, which is extracted from an EML file. 
 * @notice - The ZK proof is generated by using the zkEmail SDK.
 * @param rawEmail - The raw email text, which is extracted from an eml file.
 */
export async function generateProofFromEmlFile(
    rawEmail: string,
    blueprintSlug: string,
): Promise<{ proof: Proof }> {
    // Initialize the SDK
    const sdk = zkeSDK();

    // Get the blueprint
    const blueprint = await sdk.getBlueprint(blueprintSlug);
    console.log(`blueprint: ${JSON.stringify(blueprint, null, 2)}`);

    // Create a prover
    const prover = blueprint.createProver();
    console.log(`prover: ${JSON.stringify(prover, null, 2)}`);


    // [TEST]: Generate the inputs from the raw email
    const inputsParsed = await generateProofInputsFromEmlFile(rawEmail);
    console.log(`inputsParsed: ${JSON.stringify(inputsParsed, null, 2)}`);


    // Generate the proof
    const proof = await prover.generateProof(rawEmail);
    console.log(`proof: ${JSON.stringify(proof, null, 2)}`);  // Verify the proof

    // Verify the proof
    const isProofValid = await verifyProofOfEmlFile(blueprint, proof);
    console.log(`isProofValid: ${JSON.stringify(isProofValid, null, 2)}`);

    return { proof };
}


/**
 * @notice - Verify a ZK Proof of the raw email, which is extracted from an EML file. 
 */
export async function verifyProofOfEmlFile(
    blueprint: any,
    proof: Proof
): Promise<{ isProofValid: boolean }> {
    // Verify the proof on chain
    const isProofValidOnChain = await blueprint.verifyProofOnChain(proof);
    console.log(`isProofValidOnChain: ${JSON.stringify(isProofValidOnChain, null, 2)}`);

    // Verify the proof off chain
    const isProofValidOffChain = await blueprint.verifyProof(proof);
    console.log(`isProofValidOffChain: ${JSON.stringify(isProofValidOffChain, null, 2)}`);

    if (!isProofValidOnChain) {
        throw new Error("Proof is not valid on chain");
    }
    if (!isProofValidOffChain) {
        throw new Error("Proof is not valid off chain");
    }

    return { isProofValid: true };
}


/**
 * @notice - Generate the inputs from the raw email using the zkEmail SDK.
 * @param rawEmail - Raw email text, which is extracted from an EML file.
 */
export async function generateProofInputsFromEmlFile(
    rawEmail: string
): Promise<{ inputsParsed: string }> {
    const { decomposedRegex, externalInputs, params } = getTestRegexAndExternalInputs()

    // @ts-ignore
    const inputs = await generateProofInputs( /// @dev - This function is defined in the relayerUtils.ts of the zkemail/zk-email-sdk-js/src / [Result]: Error - Seems not to be able to call directly.
        rawEmail,        
        decomposedRegex,
        [externalInputs],
        params
    );

    const inputsParsed = JSON.parse(inputs);
    console.log("inputs: ", inputsParsed.pubkey[0]);

    return { inputsParsed };
}


/**
 * @notice - Test regex and external inputs for the input generation using zkEmail SDK.
 */
function getTestRegexAndExternalInputs() {
    const decomposedRegex = [
        {
          name: "emailRecipient",
          parts: [
            { regexDef: "(\r\n|^)to:" },
            { regexDef: "([^\r\n]+<)?" },
            {
              isPublic: true,
              regexDef: "[a-zA-Z0-9!#$%&\\*\\+-/=\\?\\^_`{\\|}~\\.]+@[a-zA-Z0-9_\\.-]+",
            },
            { regexDef: ">?\r\n" },
          ],
          location: "header",
          maxLength: 64,
        },
        {
          name: "senderDomain",
          parts: [
            { regexDef: "(\r\n|^)from:[^\r\n]*@" },
            { isPublic: true, regexDef: "[A-Za-z0-9][A-Za-z0-9\\.-]+\\.[A-Za-z]{2,}" },
            { regexDef: "[>\r\n]" },
          ],
          location: "header",
          maxLength: 64,
        },
        {
          name: "emailTimestamp",
          parts: [
            { regexDef: "(\r\n|^)dkim-signature:" },
            { regexDef: "([a-z]+=[^;]+; )+t=" },
            { isPublic: true, regexDef: "[0-9]+" },
            { regexDef: ";" },
          ],
          location: "header",
          maxLength: 64,
        },
        {
          name: "subject",
          parts: [
            { regexDef: "(\r\n|^)subject:" },
            { isPublic: true, regexDef: "[^\r\n]+" },
            { regexDef: "\r\n" },
          ],
          location: "header",
          maxLength: 128,
        },
    ];
  
    const externalInputs = {
        name: "address",
        value: "0x0000",
        maxLength: 44,
    };
  
    console.log("externalInput: ", externalInputs);
  
    const params = {
        emailHeaderMaxLength: 2048,
        emailBodyMaxLength: 2048,
        ignoreBodyHashCheck: true,
        removeSoftLinebreaks: true,
        shaPrecomputeSelector: "",
    };

    return { decomposedRegex, externalInputs, params };
}