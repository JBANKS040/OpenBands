//import zkeSDK, { Proof };
import zkeSDK, {
    Proof,
    /// @dev - The following modules/methods are imported from the relayerUtils.ts (via the index.ts) of the zkemail/zk-email-sdk-js/src.
    testDecomposedRegex,
    parseEmail,
    generateProofInputs,
    testBlueprint,
    getMaxEmailBodyLength,
    extractEMLDetails,
    generateDfa,
    ParsedEmail,
    BlueprintProps
} from "@zk-email/sdk";  /// @dev - Import the zkEmail Blueprint SDK

import { generateZkEmailInputsFromEmlFile } from "../../../utils";
//import { generateEmailVerifierInputs } from "@zk-email/zkemail-nr";

//import { convertToPubkeyLimbsAndSignatureLimbs } from "./zkEmailPubkeyAndSignatureConverter.js";


/**
 * @notice - Generate a ZK Proof from the raw email, which is extracted from an EML file. 
 * @notice - The ZK proof is generated by using the zkEmail SDK.
 * @param rawEmail - The raw email text, which is extracted from an eml file.
 */
export async function generateProofFromEmlFile(
    rawEmail: string,
    blueprintSlug: string,
): Promise<{ proof: Proof }> {
    // Initialize the SDK
    const sdk = zkeSDK();

    // [TEST]:
    //const blueprintId = await createNewBlueprint();

    // Get the blueprint
    const blueprint = await sdk.getBlueprint(blueprintSlug);
    console.log(`blueprint: ${JSON.stringify(blueprint, null, 2)}`);

    // Create a prover
    const prover = blueprint.createProver();
    console.log(`prover: ${JSON.stringify(prover, null, 2)}`);

    // [TEST]: Generate the inputs from the raw email
    const inputsParsed = await generateProofInputsFromEmlFile(rawEmail);  /// @dev - Called from the ./app/utils.ts
    console.log(`inputsParsed: ${JSON.stringify(inputsParsed, null, 2)}`);

    // [TEST]: Parse the email from the raw email
    const { parsedEmail, emailHeader, emailBody, dkimHeader, publicKey, signature } = await parseEmailFromEmlFile(rawEmail);
    console.log(`parsedEmail: ${JSON.stringify(parsedEmail, null, 2)}`);
    console.log(`emailHeader: ${emailHeader}`);
    console.log(`emailBody: ${emailBody}`);
    console.log(`dkimHeader: ${dkimHeader}`);  // [Log]: a=rsa-sha256; d=example.com; s=selector; c=relaxed/simple; q=dns/txt; h=from:to:subject:date:message-id; bh=...; b=...;
    console.log(`publicKey: ${publicKey}`);
    console.log(`signature: ${signature}`);  // [Log]: b=...;

    // [TEST]: Generate the inputs for the ZK proof
    const { inputs: zkEmailInputs } = await generateZkEmailInputsFromEmlFile(rawEmail);
    console.log(`zkEmailInputs: ${zkEmailInputs}`);

    // [TEST]: Test to retrieve a converted pubilcKey and signature in limbs type.
    //const { public_key_limbs, public_key_redc_limbs, signature_limbs } = await convertToPubkeyLimbsAndSignatureLimbs(publicKey, dkimHeader);
    //console.log(`public_key_limbs: ${JSON.stringify(public_key_limbs, null, 2)}`);
    //console.log(`public_key_redc_limbs: ${JSON.stringify(public_key_redc_limbs, null, 2)}`);
    //console.log(`signature_limbs: ${JSON.stringify(signature_limbs, null, 2)}`);


    // Generate the proof
    const proof = await prover.generateProof(rawEmail);
    console.log(`proof: ${JSON.stringify(proof, null, 2)}`);  // Verify the proof

    // Verify the proof
    const isProofValid = await verifyProofOfEmlFile(blueprint, proof);
    console.log(`isProofValid: ${JSON.stringify(isProofValid, null, 2)}`);

    return { proof };
}


/**
 * @notice - Verify a ZK Proof of the raw email, which is extracted from an EML file. 
 */
export async function verifyProofOfEmlFile(
    blueprint: any,
    proof: Proof
): Promise<{ isProofValid: boolean }> {
    // Verify the proof on chain
    const isProofValidOnChain = await blueprint.verifyProofOnChain(proof);
    console.log(`isProofValidOnChain: ${JSON.stringify(isProofValidOnChain, null, 2)}`);

    // Verify the proof off chain
    const isProofValidOffChain = await blueprint.verifyProof(proof);
    console.log(`isProofValidOffChain: ${JSON.stringify(isProofValidOffChain, null, 2)}`);

    if (!isProofValidOnChain) {
        throw new Error("Proof is not valid on chain");
    }
    if (!isProofValidOffChain) {
        throw new Error("Proof is not valid off chain");
    }

    return { isProofValid: true };
}


/**
 * @notice - Get the blueprint props (BlueprintProps struct data).
 * @dev - This function is referenced from the "zk-email-sdk-js/integration_tests/proof.test.ts"
 */
function getBlueprintProps(
  title = "OpenBands",
  circuitName?: string,
  description?: string,
  tags?: string[]
): BlueprintProps {
  return {
    title,
    circuitName: circuitName || ("open-bands" + Math.random()).replace("0.", ""),
    description,
    tags,
    decomposedRegexes: [
        {
            name: "subject",
            parts: [
                { regexDef: "(\r\n|^)subject:", isPublic: false },
                { isPublic: true, regexDef: "[^\r\n]+" },
                { regexDef: "\r\n", isPublic: false },
            ],
            location: "header",
            maxLength: 128,
        },
    ],
    emailHeaderMaxLength: 2816,
    emailBodyMaxLength: 1024,
    ignoreBodyHashCheck: false,
    removeSoftLinebreaks: true,
  };
}


/**
 * @notice - Create new Blueprint with a given props (BlueprintProps struct data).
 * @dev - This function is referenced from the "zk-email-sdk-js/integration_tests/proof.test.ts"
 */
export async function createNewBlueprint(
    //props: BlueprintProps
): Promise<{ blueprintId: any }> {
    const props = getBlueprintProps();
    console.log("got props");

    /// @dev - Example auth token.
    const authToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NDY4NzU2NzgsImdpdGh1Yl91c2VybmFtZSI6IkRpbWlEdW1vIn0.5291aJQ5vENagdMzo6OtAsaEvAlN_K0L67Di1QbsZ8M";
   
    /// @dev - Example configuration for the zkEmail SDK instance.
    const sdk = zkeSDK({
        auth: {
            getToken: async () => authToken,
            onTokenExpired: async () => {},
        },
        //baseUrl: "https://staging-conductor.zk.email"
        baseUrl: "https://registry.zk.email"
    });
    //const sdk = zkeSDK();
    
    const blueprint = await sdk.createBlueprint(props);
    console.log(`blueprint: ${JSON.stringify(blueprint, null, 2)}`);
    console.log("created blueprint");
    
    await blueprint.submitDraft();
    console.log("submitted blueprint");

    console.log("wait for status done");

    const blueprintId = blueprint.getId();
    console.log(`blueprintId: ${blueprintId}}`);

    //blueprintIds.push(blueprintId!);

    return { blueprintId };
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @notice - The following functions are used to generate the "Circuit" inputs for the ZK proof using the zkEmail SDK.  //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * @notice - Generate the inputs from the raw email using the zkEmail SDK.
 * @param rawEmail - Raw email text, which is extracted from an EML file.
 */
export async function generateProofInputsFromEmlFile(
    rawEmail: string
): Promise<{ inputsParsed: string }> {
    const { decomposedRegex, externalInputs, params } = getRegexAndExternalInputsAndParams();

    // @ts-ignore
    const inputs = await generateProofInputs( /// @dev - This function is defined in the relayerUtils.ts of the zkemail/zk-email-sdk-js/src / [Result]: Error - Seems not to be able to call directly.
        rawEmail,        
        decomposedRegex,
        [externalInputs],
        params
    );

    const inputsParsed = JSON.parse(inputs);
    console.log("inputs: ", inputsParsed.pubkey[0]);

    return { inputsParsed };
}


/**
 * @notice - Get the regex, external inputs, params for the input generation using zkEmail SDK.
 */
function getRegexAndExternalInputsAndParams(): {decomposedRegex: any, externalInputs: any, params: any} {
    const decomposedRegex = [
        // @dev - The following regex for the "emailRecipient" is commentted out. Because some of the eml files does not contain a "To:" field/item.   
        //
        // {
        //   name: "emailRecipient",
        //   parts: [
        //     { regexDef: "(\r\n|^)to:" },
        //     { regexDef: "([^\r\n]+<)?" },
        //     {
        //       isPublic: true,
        //       regexDef: "[a-zA-Z0-9!#$%&\\*\\+-/=\\?\\^_`{\\|}~\\.]+@[a-zA-Z0-9_\\.-]+",
        //     },
        //     { regexDef: ">?\r\n" },
        //   ],
        //   location: "header",
        //   maxLength: 64,
        // },
        {
          name: "senderDomain",
          description: "Extracts the sender's domain",
          parts: [
            { regexDef: "(\r\n|^)from:[^\r\n]*@", isPublic: false },
            { isPublic: true, regexDef: "[A-Za-z0-9][A-Za-z0-9\\.-]+\\.[A-Za-z]{2,}" },
            { regexDef: "[>\r\n]", isPublic: false },
          ],
          location: "header",
          maxLength: 64,
        },
        {
          name: "emailTimestamp",
          description: "Extracts the DKIM timestamp", 
          parts: [
            { regexDef: "(\r\n|^)dkim-signature:", isPublic: false },
            { regexDef: "([a-z]+=[^;]+; )+t=", isPublic: false },
            { isPublic: true, regexDef: "[0-9]+" },
            { regexDef: ";", isPublic: false },
          ],
          location: "header",
          maxLength: 64,
        },
        {
          name: "subject",
          description: "Extracts the subject line",
          parts: [
            { regexDef: "(\r\n|^)subject:", isPublic: false },
            { isPublic: true, regexDef: "[^\r\n]+" },
            { regexDef: "\r\n", isPublic: false },
          ],
          location: "header",
          maxLength: 128,
        },
    ];
  
    const externalInputs = {
        name: "address",
        value: "0x0000",
        maxLength: 44,
    };
  
    console.log("externalInput: ", externalInputs);
  
    const params = {
        emailHeaderMaxLength: 2048,
        //emailBodyMaxLength: 30720,
        emailBodyMaxLength: 2048,
        //ignoreBodyHashCheck: false,
        ignoreBodyHashCheck: true,
        removeSoftLinebreaks: true,
        shaPrecomputeSelector: "",
    };

    return { decomposedRegex, externalInputs, params };
}


/**
 * @notice - Test the regex for the email body using the zkEmail SDK.
 * @param rawEmail - The raw email text, which is extracted from an eml file.
 */
export async function parseEmailFromEmlFile(
    rawEmail: string
): Promise<{ parsedEmail: ParsedEmail, emailHeader: string, emailBody: string, dkimHeader: string, publicKey: string, signature: string }> {
    const ignoreBodyHashCheck = true;
    //const ignoreBodyHashCheck = false;

    const parsedEmail = await parseEmail(rawEmail, ignoreBodyHashCheck);
    const emailHeader = parsedEmail.canonicalizedHeader;
    const emailBody = parsedEmail.cleanedBody;
    const dkimHeader = parsedEmail.headers.get("DKIM-Signature")?.[0] || "";
    //const selector = dkimHeader.match(/s=([^;]+)/)?.[1] || "";
    //console.log(`parsedEmail: ${JSON.stringify(parsedEmail, null, 2)}`);
    //console.log(`emailHeader: ${emailHeader}`);
    //console.log(`emailBody: ${emailBody}`);
    //console.log(`dkimHeader: ${dkimHeader}`);  // [Log]: a=rsa-sha256; d=example.com; s=selector; c=relaxed/simple; q=dns/txt; h=from:to:subject:date:message-id; bh=...; b=...;
    //console.log(`selector: ${selector}`);      // [Log]: mail

    /// [TEST]:
    const emailCanonicalizedBody = parsedEmail.canonicalizedBody;
    const publicKey = parsedEmail.publicKey;
    const signature = parsedEmail.signature;
    console.log(`emailCanonicalizedBody: ${emailCanonicalizedBody}`);
    console.log(`publicKey: ${publicKey}`);
    console.log(`signature: ${signature}`);

    return { parsedEmail, emailHeader, emailBody, dkimHeader, publicKey, signature };
}
