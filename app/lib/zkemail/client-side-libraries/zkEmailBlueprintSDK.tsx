import zkeSDK, { Proof } from "@zk-email/sdk";  /// @dev - Import the zkEmail Blueprint SDK


/**
 * @notice - Generate a ZK Proof from the raw email, which is extracted from an EML file. 
 * @notice - The ZK proof is generated by using the zkEmail SDK.
 * @param rawEmail - The raw email text, which is extracted from an eml file.
 */
export async function generateProofFromEmlFile(
    rawEmail: string,
    blueprintSlug: string,
): Promise<{ proof: Proof }> {
    // Initialize the SDK
    const sdk = zkeSDK()

    // [TEST]: Generate the inputs from the raw email
    const inputsParsed = await generateProofInputsFromEmlFile(sdk, rawEmail);
    console.log(`inputsParsed: ${JSON.stringify(inputsParsed, null, 2)}`);

    // Get the blueprint
    const blueprint = await sdk.getBlueprint(blueprintSlug);
    console.log(`blueprint: ${JSON.stringify(blueprint, null, 2)}`);

    // Create a prover
    const prover = blueprint.createProver();
    console.log(`prover: ${JSON.stringify(prover, null, 2)}`);
      
    // Generate the proof
    const proof = await prover.generateProof(rawEmail);
    console.log(`proof: ${JSON.stringify(proof, null, 2)}`);// Verify the proof

    // Verify the proof
    const isProofValid = await verifyProofOfEmlFile(blueprint, proof);
    console.log(`isProofValid: ${JSON.stringify(isProofValid, null, 2)}`);

    return { proof };
}


/**
 * @notice - Verify a ZK Proof of the raw email, which is extracted from an EML file. 
 */
export async function verifyProofOfEmlFile(
    blueprint: any,
    proof: Proof
): Promise<{ isProofValid: boolean }> {
    // Verify the proof on chain
    const isProofValidOnChain = await blueprint.verifyProofOnChain(proof);
    console.log(`isProofValidOnChain: ${JSON.stringify(isProofValidOnChain, null, 2)}`);

    // Verify the proof off chain
    const isProofValidOffChain = await blueprint.verifyProof(proof);
    console.log(`isProofValidOffChain: ${JSON.stringify(isProofValidOffChain, null, 2)}`);

    if (!isProofValidOnChain) {
        throw new Error("Proof is not valid on chain");
    }
    if (!isProofValidOffChain) {
        throw new Error("Proof is not valid off chain");
    }

    return { isProofValid: true };
}


/**
 * @notice - Generate the inputs from the raw email using the zkEmail SDK.
 * @param sdk 
 * @param rawEmail - Raw email text, which is extracted from an EML file.
 */
export async function generateProofInputsFromEmlFile(
    sdk: any,
    rawEmail: string
): Promise<{ parsed: string }> {

    const { decomposedRegex, externalInputs, params } = getTestRegexAndExternalInputs()

    // @ts-ignore
    const inputs = await sdk.generateProofInputs( /// [Result]: Error - Seems not to be able to call directly.
        rawEmail,
        decomposedRegex,
        [externalInputs],
        params
    );
    const parsed = JSON.parse(inputs);
    console.log("inputs: ", parsed.pubkey[0]);

    return { parsed };
}


/**
 * @notice - Test regex and external inputs for the input generation using zkEmail SDK.
 */
function getTestRegexAndExternalInputs() {
    const decomposedRegex = [
        {
          name: "emailRecipient",
          parts: [
            { regexDef: "(\r\n|^)to:" },
            { regexDef: "([^\r\n]+<)?" },
            {
              isPublic: true,
              regexDef: "[a-zA-Z0-9!#$%&\\*\\+-/=\\?\\^_`{\\|}~\\.]+@[a-zA-Z0-9_\\.-]+",
            },
            { regexDef: ">?\r\n" },
          ],
          location: "header",
          maxLength: 64,
        },
        {
          name: "senderDomain",
          parts: [
            { regexDef: "(\r\n|^)from:[^\r\n]*@" },
            { isPublic: true, regexDef: "[A-Za-z0-9][A-Za-z0-9\\.-]+\\.[A-Za-z]{2,}" },
            { regexDef: "[>\r\n]" },
          ],
          location: "header",
          maxLength: 64,
        },
        {
          name: "emailTimestamp",
          parts: [
            { regexDef: "(\r\n|^)dkim-signature:" },
            { regexDef: "([a-z]+=[^;]+; )+t=" },
            { isPublic: true, regexDef: "[0-9]+" },
            { regexDef: ";" },
          ],
          location: "header",
          maxLength: 64,
        },
        {
          name: "subject",
          parts: [
            { regexDef: "(\r\n|^)subject:" },
            { isPublic: true, regexDef: "[^\r\n]+" },
            { regexDef: "\r\n" },
          ],
          location: "header",
          maxLength: 128,
        },
    ];
  
    const externalInputs = {
        name: "address",
        value: "0x0000",
        maxLength: 44,
    };
  
    console.log("externalInput: ", externalInputs);
  
    const params = {
        emailHeaderMaxLength: 1024,
        emailBodyMaxLength: 0,
        ignoreBodyHashCheck: true,
        removeSoftLinebreaks: true,
        shaPrecomputeSelector: "",
    };

    return { decomposedRegex, externalInputs, params };
}