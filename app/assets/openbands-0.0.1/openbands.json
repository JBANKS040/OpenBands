{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":15274898884297195809,"abi":{"parameters":[{"name":"partial_data","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":640,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"partial_hash","type":{"kind":"array","length":8,"type":{"kind":"integer","sign":"unsigned","width":32}},"visibility":"private"},{"name":"full_data_length","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"base64_decode_offset","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"jwt_pubkey_modulus_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"public"},{"name":"jwt_pubkey_redc_params_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"jwt_signature_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"domain","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"},{"name":"position","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":128,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"},{"name":"salary","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"},{"name":"work_life_balance","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"culture_values","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"career_growth","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"compensation_benefits","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"leadership_quality","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"operational_efficiency","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"header","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":512,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"body","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":1024,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"pubkey","type":{"kind":"struct","path":"zkemail::dkim::RSAPubkey","fields":[{"name":"modulus","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"redc","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"body_hash_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"dkim_header_sequence","type":{"kind":"struct","path":"zkemail::Sequence","fields":[{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"}],"return_type":null,"error_types":{"1745191622261247408":{"error_kind":"string","string":"rating must be at least 1"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3951064283418873378":{"error_kind":"fmtstring","length":123,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32}]},"4118337510742699159":{"error_kind":"string","string":"No ';' suffix found at asserted bh index"},"4128061241751547076":{"error_kind":"string","string":"Position can not be found in email body"},"4524007320076231485":{"error_kind":"string","string":"Header field out of bounds of header"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5466606472443271855":{"error_kind":"string","string":"Header field must not contain newlines"},"5634341720269277520":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":32}]},"5675127253506927136":{"error_kind":"string","string":"utils::search could not find needle in haystack"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6314603625877298116":{"error_kind":"string","string":"haystack length of size 0 not supported"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6543056410826478903":{"error_kind":"string","string":"incorrect value for claim"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7788270038095378938":{"error_kind":"string","string":"substring not present in main text (match found if a padding text included. is main text correctly formatted?)"},"8133541709288850676":{"error_kind":"string","string":"No ':bh=' or '; bh=' prefix found before body hash"},"8386845565670372523":{"error_kind":"string","string":"SHA256 hash computed over body does not match body hash found in DKIM-signed header"},"8397817944888091498":{"error_kind":"string","string":"rating must be at most 5"},"9281715815618326061":{"error_kind":"string","string":"invalid domain"},"9619408434855056367":{"error_kind":"string","string":"Header field name must be followed by a colon"},"10713088778935619315":{"error_kind":"string","string":"char before domain is not '@'"},"11883698362854120768":{"error_kind":"string","string":"Header field must start with CRLF"},"12712340723692189130":{"error_kind":"string","string":"Header field name does not match"},"13815800804469369678":{"error_kind":"string","string":"partial_data length is too long"},"14044520943542572812":{"error_kind":"string","string":"Salary can not be found in email body"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14304927234259905409":{"error_kind":"fmtstring","length":129,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32}]},"14734181347393705282":{"error_kind":"string","string":"Header field must end with CRLF"},"15412340888643424233":{"error_kind":"string","string":"needle length of size 0 not supported"},"15512795827244806757":{"error_kind":"string","string":"Body hash index accessed outside of DKIM header field"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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4wm244m240m248m24ym246m245/cx/Ph3wXAQmARsBhYAiwFljF70nIaL27N/T2yFTSPl+pznazP11cSPV6qb+JyrnMVyTqD2b9nsJri8VJ1TX/e1+HXkFxH/N9rXkvx+lyIXyi8Qsd6v68jeR2R/3tF6yk8qUUg++f3N5C9zs37fGMj1etJFu/zjU0k61Qez/v5/c0kfT6oDRhdqN3nlts8ZoXteKXteJXteLXteI3teK3teJ3teP3ffH9qg+14o+14k+14s+14vu14ge14oe14ke14se14ie14qe14mft4C/y7FdgGbAd2ADuBXcBuZp/bQ+NzlrqGONe5l2CdAf/C5+L3UVw/6t1BF28991Os8/W3wwNYH9cP0HgS++f8DpK9rsD7eYVDNK8nqc/9sD5eHqbpS+zf1zlC4Z2to1/54lznUYr9+frbbrzX+zGi9w3gvmd9feE4yesL8E5MMO/rCycornc/eERq9eb3HPfYPGav7Xif7Xi/7dj+PcQDtmP7+5IHbceHbMeHbcdHbMdHbcf290OP2Y6P245P2I632I632o632Y6324532I532o532Y53u49Pwr+ngNPAGeAscA44D1xg9rmLFPe3+t5TIO/rNJdIrh8/F/f3sy5Tvb7N/LtEVyjqCde4egebc51XKdbZ+vUnj1n7+zWSer7+5SzW3yu5TuNz7Nf7DbrrndWPbxI9HwZY13mL5PlbUOtgVzDr9X6bzo9Z9+cdiusoEK72UN7XO3+jeX0uWP0GjN3nLto85pLt+LLt+Irt+Krt2O6C17zcft12fMN2fNN2fMt2bP+O523b8R3b8W+245O241O249O24zO247O243O24/O24wvu47vw7+/APeAP4D7wJ/AAeMjsc4/Ing/x9s3HNP0oSD0j4lznE4p1vv7etR+rfzwl6Zvq/UHe97OeEaxTveemfrmCc53PaXyuFffrCi9oriP1Cxus1/tLmsehQO7r/RXR69zc3zN4ZxzJ+62W6vT2x3Vvr5E8sh0/th0/sR0/tR0/sx0/tx2/8PI6zV/5XYaXtuNXtmNVi/8c37Xd/rvt+J7t+A/b8X3b8Z+24we244f/OYb/nRhATCAWEBuIA8QF4o175x3O+zs+zf0Nzy95r/ME40i8uBX37x0npKhniPr2Le86E1GsMzA4iPv7t4kJ1vn6/Rfm3/FLQnW/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","debug_symbols":"7P3djiXJ1l0Hvst3zQu3fzO+SqPRYLeoBgGBFETqitC7a6dQmXWA8PIpAZs7x0DkXZ2DQNWIyIw1py9zG/u//9v/9B//v//7////85/+8//8X/7rv/37/9d//7f/5b/8//7Df/tP/+U/v/7Xf/+32vf1f/2///V//Q//+cf/8V//23/43/7bv/37Ptv8d//2H//z//T6x73K//Hv/u1//k//y3/8t38/X//45YvbrNdfX9zmWH9/8fo//t//7sd/ovyP/0/U//H/ifY//j/Rb/8Te61f/4m9nv8TvY+f/4k++/jX/8TXL577On998dx1//3F+y+eAeOZMJ4F49mf5tn1J8+55leew+I5F4ynwHjqZ3lWrT95Vl31K0+D8XQYz4DxTBjPgvFsGM9B8YzrgvEUGA9rPo+LNZ/HxZrP42LN53Gx5vO4WPN5XKz5PC7YfC6w+Vxg87nA5nOBzecCm88FNp8LbD4X2HwusPlcYPO5wuZzhc3nCpvPFTafK2w+V9h8rrD5XGHzucLmc4XN5wabzw02nxtsPjfYfG6w+dxg87nB5nODzecGm88NNp87bD532HzusPncYfO5w+Zzh83nDpvPHTafO2w+d9h8HrD5PGDzecDm84DN5wGbzwM2nwdsPg/YfB4fn8/75795tVK+8hwWz7xgPAXG8+n5/DoB/Mkz1vWvPF+/+PV3f/z1xa9/ml/hGxm+7P4L/rq+wncz/DDDTzP8svzC9v0Vfpvhjxh+XWb4YobXJOwdPDphEzw6YRM8OmETPDphE7w5YZc5YZc5Ybc5Ybc5Ybc5Ybc5YT99O/i98OaE3eaE3eaE3eaE3eaEPeaEPeaEPeaEPeaE/fj97rfCmxP2mBP2mBP2mBP2iBN2XuKEnZc4YeclTth5iRN2XuKEnZc4YeclTth5iRN2XuKEnZc5YYs5YYs5YYs5YYs5YT/uWHgrvDlhizlhizlhizlhizlhqzlhqzlhqzlhqzlhP27JeCu8OWGrOWGrOWGrOWGrOWGbOWGbOWGbOWGbOWE/7jl54z2p2cS3dWYT39aZDZ2wCR6dsAnenLDdnLDdnLDdnLBdk7A3IfVxU83/M/j98zOVarvqV3j2M2yAZz/DBnj2M2yAZz/DBnh0woZ6MNAJm+DRCZvg0Qmb4M3PsB93Db0V3rwlHuYt8TBviYd5Szw0z7A3fX6yn2Gfu81kP8MGePYzbIBnJ2yAZydsgDdvic1Op8l2OiV485bY7HSaZqfTNDudptnpNM1Op2l2Ok2P0+mmz8OdTs/dBu50CvDmLTHc6fQMD3c6BXjzlpjtdErwYi/xZDudErx5S2x2Ok2z02manU7T7HSaZqfT9Didbvo83On03G3gTqcAj07YBG9+0wnudArw5i0x2+mU4MVvOi220ynBi7fEy+x0Wman07rYCRvgxc+wy+x0Wh6n09c+v+BOp8dus+BOp2d4uNMpwIvfdFpwp1OAF2+JF9vplODFbzotttMpwYu3xMvsdFpmp9MyO52W2em0zE6n5XE63fR5uNPpudvAnU4BXrwlXnCnU4A3P8OynU6hmLGdTgle/KbTYjudErx5S+xxOt3Bm7fEbKdTgjc/w7KdTglefB92wZ1Oz90G7nQK8OYtMdzpFODZCRvgzVtittMpwYvfdFpsp1OCN2+J2U6nBG/eErOdTgne/Axrdjotj9Ppps/DnU7P3QbudArw5i0x3On0DG92Oi220ykUM7bTKcGb33RiO50SvHlLzHY6JXjzlpjtdErw5mdYs9NpeZxON30e7nR67jZwp1OARydsgje/6WR2Oi220ykUM7bTKcGb33RiO50SvHlLzHY6JXjzlpjtdErw5mdYs9NpeZxON30e7nR67jZwp9MzPNzpFODNbzqZnU6L7XQKxYztdErw5jed2E6nBG/eErOdTglevCXebKdTghc/w26z02l7nE5f+/y+0An73G023OkU4MVb4g13OgV48TPsZjudnovZZjudErz4TafNdjolePGWeLOdTglevCXebKdTghc/w26z02l7nE43fR7udHruNnCnU4AXb4k33OkU4NkJG+DFW+LNdjolePGbTpvtdErw5i0x2+mU4M1bYrbTKcGbn2HNTqftcTrd9Hm40+m528CdTgHevCWGO52e4c1Op812OoVixnY6JXjxm06b7XRK8OYtMdvplODNW2K20ynBm59hzU6n7XE63fR5uNPpudvAnU4BHp2wCd78ppPZ6bTZTqdQzNhOpwRvftOJ7XRK8OYtMdvplODNW2K20ynBm59hzU6n7XE63fR5uNPpudvAnU7P8HCnU4A3v+lkdjptttMpFDO20ynBm990YjudErx5S8x2OiV485aY7XRK8OZnWLPTaXucTjd9Hu50eu42cKdTgDdv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Mzzb6RTqAdvplODN57Bsp1OCNycs3OkU4M0Jy3Y6JXjzlpjtdArwZqfTNjudttnptM1Op+1xOt08jMCdTs99Hu50CvDmLTHb6ZTgzVtis9Nps51OYc6znU4J3pywZqfTNjudtsfpdNNt4E6n53oAdzoFeHPCsp1OCd68JTY7nTbb6RTmPNvplODNCWt2Om2z02mbnU7b43T6WswO3On02G0O3OkU4MUJe9hOpwSPTtgEL76tc9hOp+c5f9hOpwQvTthjdjods9PpmJ1Ox+N0uilmcKfTc7eBO50CvDlh2U6nBC8+hz1sp1OCNycs2+mU4M0Jy3Y6JXjxlviYnU7H43S6KWZwp9Nzt4E7nQK8OWHZTqcAz3Y6JXjxOeyBO52e5zzb6ZTgzQnLdjolePOW2Ox0Oman0/E4nW5aJdzp9FzM4E6nAG8+h2U7nRI8OmETvHlLzHY6hTnPdjoleHPCsp1OAd7sdDpmp9PxOJ1uihnc6fTcbeBOpwBvTli20ynBm89h2U6nBG9OWLbTKcGbE5btdErw5i2xx+l0023gTqfnegB3OgV4c8KynU4J3nwOy3Y6JXhzwpqdTsfsdDoep9MdvPkcFu50CvBiL/FhO51Ct2E7nQK82el02E6nBG8+h2U7nRK8OWHNTqfjcTrdwZvPYeFOpwBv3hKznU6hmLGdTqHbsJ1OCd58Dvtxp9P59dd4nVG+8gwYz4TxLBjPhvEcEs+6Pm4xSjyfjolXqv71xfsq/XlYvf74frKX8RW9etGbF7170YcXfXrRlxd9e9GPFv3jGqI3onvTtHjTtHjT9OP6oTeie9O0eNO0eNO0eNO0eNO0etO0etO0etO0etP046qhN6J707R607R607R607R607R507R507R507R50/TjWqE3onvTtHnTtHnTtHnTtHnTtHvTtHvTtHvTtHvT9OMKoTeie9O0e9O0e9O0e9O0e9N0eNN0eNN0eNN0eNP047qgN6J703R403R403R403R403R603R603R603R60/TjaqA3onvTdHrTdHrTdHrTdHrTdHnTdHnTdHnTdHnT9OMaoDeie9N0edN0edN0edN0edN0e9N0e9N0e9N0e9P048qfN6J703R703R703R703R70/R40/R40/R40/R40/Tzep/3oXvT9HjT9HjT9HjT9GjTtFzaNC1eF1LxupCK14VU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TgHenLBsp1OCN5/Dsp1OCd6csGynU4I3Jyzb6ZTgzVtisdPpBa/ZEt8UM7jT6bnbwJ1OAd6csGynU4I3n8OynU4J3pywbKdTgGc7nRK8+RyW7XRK8OYtsdjp9II3n8PCnU7PxQzudArw5nNYttMpwLOdTgnevCVmO53CnGc7nRK8OWHZTqcEb94Si51OL3jzOSzc6fTcbeBOpwBvTli20ynBm89h2U6nBG9OWLbTKcGbE5btdErw5i2xx+l0023gTqfnegB3OgV4c8KynU4J3nwOy3Y6JXhzwoqdTi94ccIWj9PpDl58DlvgTqcA7/USv+DRCfvcbQrb6ZTgxQlb2E6nBC8+hy1sp1OANzuditnpVDxOpzt48TlsgTudArx4S1zYTqdQzNhOp9Bt2E6nBC8+hy0fdzqdX3+Nf3yC+leeAuOpMJ4G4+kwngHjmTCeT8fEOT+/+Ieu8nlYzXN+spfxFX170Y8W/eNKojeiFy969aI3L3r3og8v+vSie9O0edO0edO0e9O0e9O0e9O0e9P049qhN6J707R707R707R707R703R403R403R403R40/TjiqE3onvTdHjTdHjTdHjTdHjTdHrTdHrTdHrTdHrT9OM6oTeie9N0etN0etN0etN0etN0edN0edN0edN0edP04+qgN6J703R503R503R503R503R703R703R703R70/TjmqA3onvTdHvTdHvTdHvTdHvT9HjT9HjT9HjT9HjT9ONKoDeie9P0eNP0eNP0eNP0aNO0Xto0rZc2TeulTdN6adO0Xto0rZc2TeulTdN6adO0Xto0rZc3TYs3TYs3TYs3TYs3TT+u+nkjujdNizdNizdNizdNizdNqzdNqzdNqzdNqzdNP68ieh+6N02rN029LqTqdSFVrwupel1I1etCql4XUvW6kKrXhVS9LqTqdSFVrwupel1I1etCql4XUvW6kKrXhVS9LqTqdSFVrwupel1I1etCql4XUvW6kKrXhVS9LqTqdSFVrwupel1I1etCql4XUvW6kKrXhVS9LqTqdSFVrwupel1I1etCql4XUvW6kKrXhVS9LqTqdSFVrwupel1I9fMupFX+Rt9feSqMp8F4OoxnwHgmjGfBeDaM57B4Pi/iCTyw+fxxZU6t9Wd8vcLhK0+D8XQYz4DxTBjPgvFsGM9h8Xxc7ZJ4CowHNp8P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3pXXvRuvezde92687t143bt1HhKvezde92687t143bvxunfnde/O696d1707r3v3juvende9O697d1737rzu3Xnde/C69+B178Hr3oPXvUfnIfG69+B178Hr3oPXvQeve09e95687j153XvyuvfsuO49ed178rr35HXvyevek9e9F697L173XrzuvXjde3UeEq97L173XrzuvXjde/G69+Z1783r3pvXvTeve3/+rmXs3pvXvTeve29e99687r153fvwuvfhdW/eXcvKu2tZeXctK++uZeXdtay8u5aVd9ey8u5aNt5dy8a7a9l4dy0b765lu3Ddu/HuWjbeXcvGu2vZeHctG++uZfv8Xcv266tf/3w3BD5/1zIjVR5S4yF1HtLgIX18ever/kJ6Hb79K9LXL5/n/PXFq4wb+qWm32r6Y6b//L3Qt9IXNX1V0zc1fVfTDzW9OmurOmurOmurOmubOmubOmubOmubOms/f+P4rfTqrG3qrG3qrG3qrG3qrO3qrO3qrO3qrO3qrP38/fC30quztquztquztquztquzdqizdqizdqizdqiz9vO3+d9Kr87aoc7aoc7aoc7aoc7aqc7aqc7aqc7aqc7az7sX3kqvztqpztqpztqpztqpztqlztqlztqlztqlztrPmzLeSq/O2qXO2qXO2qXO2qXO2q3O2q3O2q3O2q3O2s97Td5Kr87arc7arc7arc7arc7ao87ao87ao87ao87az1to3kqvztqjztqjztqjztpjztp+mbO2X+as7Zc5a/tlztp+mbO2X+as7Zc5a/tlztp+mbO2X+qsLeqsLeqsLeqsLeqs/bzh6a306qxVe6O62hvV1d6orvZGdbU3qqu9UV3tjepqb1RXe6O62hvV1d6orvZGdbU3qqu9UV3tjepqb1RXe6O62hvV1d6orvZGdbU3qqu9UV3tjepqb1RXe6O62hvV1d6orvZGdbU3qqu9UV3tjepqb1RXe6O62hvV1d6orvZGdbU3qqu9UV3tjepqb1RXe6O62hvV1d6orvZG9c97o9r++0PuXivsG6TCQ6o8pMZD6jykwUOaPKTFQ9o8pM8P+jH/RhrrK9JvMBFFpM8//pzyC2mMfYNUeUiNh9R5SIOHNHlIi4e0eUgHh/Qb3DYRiTe9N296b9703rzpvXnTe/Om9+ZN782b3ps3vQ9veh/e9D686X140/vwpvfhTe/Dm96HN70Pb3of3PQeF256jws3vceFm97jwk3vceGm97hw03tcuOk9Ltz0Hhdueo+LN70Lb3oX3vQuvOldeNO78KZ34U3vwpvehTe9C296F970rrzpXXnTu/Kmd+VN78qb3pU3vStvelfe9K686V1507vxpnfjTe/Gm96NN70bb3o33vT+/J3r2f5+w3j2O6TFQ9o8pIND+vw95vnrX12udfUbpI9P7zX630ir3iBV3h9c4yF1HtLgIU3eb9zi/cbxpnfnTe/P34zNSIWHVHG/cZ+/mBp/4wZveg/e9B687j143fvzNzjzb9zB/cZN3vSevOk9ed178rr35+9axt+4z9+1zL9xvOk9edN78rr35HXvxducLN7mZPGm9+JN78/ftcxIvO69eJuTxducLN70XrzpvXnde/O69+ZtTjZvc7J503vzpvfmde/N696btznZvM3J4U3vw5veh9e9D697f/6uZfyNO7zNyeFN78Ob3ofXvQ+ue88LtzmZF25zMi/c9J4XbnrPC9e954Xr3vPCbU7mhduczAs3vefFm94F171nwXXvWXCbk1lwm5NZeNO78KZ3wXXvWXDdexbc5mQW3OZkVt70rrzpXXndu/K69+fvWsbfuIrbnMzKm96VN70rr3tXXvduvM1J421OGm96N970/vxdy4zE696NtzlpvM0J767l5N21nJ3XvTuve3fe5qTzNie8u5aTd9dydl737rzu3Xmbk87bnPDuWk7eXcs5eN178Lr3b7hrmX7jBm9zwrtrOXl3Lefgde/B696TtzmZvM0J767l5N21nL/hrmVE4nXvyducTN7mhHfXcvLuWs7F696L170Xb3OyeJsT3l3LybtrORevey9e9168zcnibU54dy0n767l3LzuvXnd+zfctUy/cZu3OeHdtZy8u5Zz87r35nXvw9ucHN7mhHfXcvLuWs7fcNcyIvG69+FtTg5vc8K7azl5dy3Xheve68J173XhNifrwm1OXpi8Pzjc9F4XrnuvC9e914XbnKwLtzlZvLuWi3fXchVc914F173Xb7hrmX7jCm5zsnh3LRfvruUquO69Cq97V9zmZFXc5mTx7lou3l3L9RvuWkYkXveuuM3JqrjNyeLdtVy8u5ar8bp343XvxtucNN7mhHfXcvHuWi7e51ou3udarsbbnDTe5oR3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IRo3rQqJ42Yat2DctCokjptWhWjctCokjptWhWjctCrkjRv80fovjBv8ZfnkcdOqEI2bVoXEcTONWzBuWhUSx02rQjRuWhUSx02rQjRuWhXyxg3+uvi2PX/AHNf4xbj99ifDh10/CK1XMqGbyfXjxOcM+xuh/5244U7ccSc23IkH7sQTd+KFO/HGnfjQTvzb3z9+/sQ455o455o45/rtb/I+f2Kcc02cc02cc02cc02cc61SzvWvfy/WXrt9//mt9/aL34utUo72FkKlnO4thEo54FsImQgFhEo55lsIlXLStxAq5bBvIVTKed9CqJQjv4PQllNHhOTUESE5dURITh0RMhEKCMmpI0Jy6oiQnDoiJKeOCMGdevx8qLyNY38j9Kt/f35+nv7665+G/vLnB38aeuC6/ix8+CbwLHz4kvEsfPj+8ix8E/zn4MO3rmfhwxe6Z+HDd8Vn4cPX0Gfha8N9DP710ob7IHxtuA/C14b7IHxtuA/CN8F/Dr423Afha8P9N/D79ePn3/892n+Ez95w53qN7z9/LnsF8COY7I117p+TPPfa/xEmewPNhXmxN8pkmOwNMRkme+NLhsne4JJhmmDmwWRvWMkw2RtTMkz4BpQLUxtQIkxtQHkwmzagRJjagBJhagNKhKkNKBGmCWYeTG1AiTC1ASXC1AaUCFMbUCJMbUB5MLs2oESY2oASYWoDSoSpDSgRpglmHkxtQIkwtQElwtQGlAhTG1AiTG1AeTBNG1AiTPYGFD8IeRl7rUl9EPIy9lrzlXEzjVveuLF3la+MG3sBSR439gLylXFjbxXJ48beKr4wboO9KuSOW62nqt8ybloVEsdNq0I0bqZxyxs3rQrRuGlVSBw3rQrRuGlVSBw3rQrBuNV6Bv3hcav1wvpbxk2rQuK4aVWIxs00bnnjplUhGjetConjplUhGjetConjplUhGLelVSFv3JZWhWjctCokjptWhWjcTOOWN25aFaJx06qQOG5aFaJx06qQOG5aFYJx21oV8sZta1WIxk2rQuK4aVWIxs00bnnjplUhGjetConjplUhGjetConjplUhGLejVSFv3I5WhWjctCokjptWhWjcTOOWN25aFaJx06qQOG5aFaJx06qQOG5aFf553Br8ZfnUcWvwl+K/Mm5aFRLHTatCNG6mccsbN60K0bhpVUgcN60K0bhpVUgc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X+k4thdfqfl9pe73lTa/r/Tbb+9HDff82f2f3+AXX+mw+0q/fXbj//OV9hevypjtshSL31da/b6S39v7t0/me0R63f/Eu734jfvt0/OufKXN773k9/aOw+5V2Sa7Gdf83t7N7+3d/N7ev3262IX3UvN7e7du915qfm/vtvu9Kg+7Gdf93t7d7+3d/d7ev32q0oX3Uvd7e/dm917qfm/vvtm9KvvuN+P83t6b39t783t7//Y5MhfeS5vf23sLu/fS5vf23rrdq3Lz63tvfm/vze/tvfu9vX/7RIwL76Xd7+29r3bvpd3v7b03u1fl7vevlrvf23v3e3vvfm/vY7J7Lx1+b+9jsXsvHX5v7yPsXpWH35qTw+/tffi9vQ+/t/dxuL2X1snu7b1Os9t7aZ3s3t7rtLq9Ktcp3GbcOtm9vdfJ7u29TnZv73Xa/d5Lfm/vebJ7L81+b+95sXtVznZrTtbZ7+09+729Z7+397z5vZf83t6z3XrvdfF7ey+z3atysVtzsi5+b+/F7+29+L29F7v13uvi9/Ze7NZ7r4vf23u1262zrnZrTtbV7+29+r29/fZarqvdeu919Xt7r3brvVe/vZbrardbZw27NSer317L1W+v5eq313L99b2W5+8lv72Wa9it91799lquYbdbZw27NSer317L1W+v5eq313Jtduu9V7+9lmuzW++9+u21XJvdbp212a05Wf32Wq5+ey1Xv72Wa7db77367bVcC/Zanr2X/PZart1ut87a/dac+O21XP32Wq5+ey3XzW699+q313Ld7NZ7r357LdfNbrfOuvmtOfHba7n67bVc/fZarrvfem+/vZbr7rfe22+v5Vq81/LVq3L3W3Pit9dy9dtrufrttVx3v/Xefnst18NvvbffXsv18Nut8+t7Lc9nnN9ey9Vvr+Xqt9dyPfzWe/vttYzJbr13+O21jMlut05MdmtOYrJ7e4ffXsvw22sZk9167/DbaxmT3Xrv8NtrGbPdbp2Y7dachN9ey/Dbaxl+ey1jtlvvHX57LWO2W+8dfnstY7HbrROL3ZqT8NtrGX57LcNvr2Usduu9w2+vZSx2673Db69lLHa7dWK1W3MSfnstw2+vZfjttYxf32t5/l7y22sZq9167/Dbaxmr3W6dWO3WnITfXsvw22sZfnstI+zWe4ffXssIu/Xe4bfXMsJut06E3ZqT8NtrGX57LcNvr2U0u/Xe4bfXMgr2Wp69l/z2Wkaz260TzW7NSfjttQy/vZbht9cyut167/Dbaxndbr13+O21jG63Wye635oTv72W4bfXMvz2WsZmt947/PZaxma33jv89lpG8V7LV6/KzW/Nid9ey/Dbaxl+ey1j81vv7bfXMna/9d5+ey1jt9utE7++1/J8xvnttQy/vZbht9cydr/13n57LePwW+/tt9cyDr/dOoffmhO/vZbht9cy/PZaxuG33ttvr2Ucduu9m99eyzbZ7dZpk92ak+a317JNdm/v5rfXsk12672b317LNtmt925+ey3bbLdbp812a06a317L5rfXsvnttWyz3Xrv5rfXss12672b317LNtvt1mmL3ZqT5rfXsvnttWx+ey3br++1PH8v+e21bIvdeu/mt9eyLXa7ddpit+ak+e21bH57LZvfXsu22q33bn57Ldtqt967+e21bKvdbp222q05aX57LZvfXsvmt9eyhd167+a317IV7LU8ey/57bVsYbdbp4XdmpPmt9ey+e21bH57LVuzW+/d/PZatma33rv57bVszW63Tmt2a06a317L5rfXsvnttWzdbr1389tr2brdeu/mt9eyFe+1fPWq7H5rTvz2Wja/vZbNb69l63brvZvfXsu22a33bn57Ldtmt1un/fpey/MZ57fXsvnttWx+ey3bZrfeu/nttWy733pvv72WbbfbrdN2vzUnfnstm99ey+a317Ltfuu9/fZatt1vvbffXst2+O3WOfzWnPjttWx+ey2b317Ldvit9/bba9kOv/Xefnst+2S3W6dPdmtOut9ey+6317JPdm/vPtmt9+5+ey37ZLfeu/vtteyT3W6dPtutOel+ey27317L7rfXsv/6Xsvz95LfXss+26337n57Lftst1unz3ZrTrrfXsvut9ey++217Ivdeu/ut9eyL3brvbvfXsu+2O3W6YvdmpPut9ey++217H57Lftqt967++217AV7Lc/eS357Lftqt1unr3ZrTrrfXsvut9ey++217GG33rv77bXsYbfeu/vttexht1unh92ak+6317L77bXsfnste7Nb79399lr2Zrfeu/vttezFey1fvSqb3ZqT7rfXsvvttex+ey17s1vv3f32WvZut967++217N1ut07/9b2W5zPOb69l99tr2f32WvZut967++217Jvdeu/ut9eyb3a7dfrmt+bEb69l99tr2f32WvbNbr1399tr2Te/9d5+ey37brdbp+9+a0789lp2v72W3W+vZd/91nv77bXsu996b7+9lv3w261z+K058dtr2f32Wna/vZb98Fvv7bfXsh9+67399lr2w263zjbZrTnZ/PZabn57LTe/vZbbFG7vpc1vr+U22a333vz2Wm6T3W6dbbJbc7L57bXc/PZabn57LbfZbr335rfXcpvt1ntvfnstt9lut84226052fz2Wm5+ey03v72W22K33nvz22u5Fey1PHsv+e213Ba73TrbYrfmZPPba7n57bXc/PZabqvdeu/Nb6/lttqt99789lpuq91unW21W3Oy+e213Pz2Wm5+ey23sFvvvfnttdzCbr335rfXcivea/nqVRl2a042v72Wm99ey81vr+UWduu9N7+9lluzW++9+e213Jrdbp3t1/dans84v72Wm99ey81vr+XW7NZ7b357Lbdut95789truXW73Tpb91tz4rfXcvPba7n57bXcut16781vr+XW7dZ7b357LbfNbrfOtvmtOfHba7n57bXc/PZabpvdeu/Nb6/lttmt99789lpuu91unW33W3Pit9dy89trufnttdx2v/Xefnstt91vvbffXstt99utc/itOfHba7n57bXc/PZabr++1/L8veS313I7/NZ7++213A6/3TqH3ZqT3W+v5e6313L322u5T3brvffJ7u29T3brvXe/vZb7ZLdbZ5/s1pzsfnstd7+9lrvfXst9tlvvvfvttdwL9lqevZf89lrus91unX22W3Oy++213P32Wu5+ey33xW699+6313Jf7NZ77357LffFbrfOvtitOdn99lrufnstd7+9lvtqt95799trua926713v72We/Fey1evytVuzcnut9dy99trufvttdxXu/Xeu99eyz3s1nvvfnst97DbrbP/+l7L8xnnt9dy99trufvttdzDbr337rfXcm926713v72We7PbrbM3uzUnu99ey91vr+Xut9dyb3brvXe/vZZ7s1vvvfvttdy73W6dvfutOfHba7n77bXc/fZa7t1uvffut9dy73brvXe/vZb7ZrdbZ9/81pz47bXc/fZa7n57LffNbr337rfXct/s1nvvfnst981ut86++6058dtrufvttdz99lruv77X8vy95LfXct/91nv77bXcd7vdOvvut+bEb6/l7rfXcvfba7kffuu9/fZa7offem+/vZb74bdb5/Bbc+K31/Lw22t5+O21PCa79d6H317LYwq399Lht9fymOx26xyT3ZqTw2+v5eG31/Lw22t5zHbrvQ+/vZbHbLfe+/Dba3nMdrt1jtluzcnht9fy8NtrefjttTwWu/Xeh99ey2OxW+99+O21PIr3Wr56VS52a04Ov72Wh99ey8Nvr+Wx2K33Pvz2Wh6r3Xrvw2+v5bHa7dY5fn2v5fmM89trefjttTz89loeq91678Nvr+URduu9D7+9lkfY7dY5wm7NyeG31/Lw22t5+O21PMJuvffht9fyCLv13offXsuj2e3WOZrdmpPDb6/l4bfX8vDba3k0u/Xeh99ey6PZrfc+/PZaHt1ut87R/dac+O21PPz2Wh5+ey2Pbrfe+/Dba3l0u/Xeh99ey6Pb7dY5Nr81J357LQ+/vZaH317L49f3Wp6/l/z2Wh6b3Xrvw2+v5bHZ7dY5Nr81J357LQ+/vZaH317LY/db7+231/LY/dZ7++21PHa73TrH7rfmxG+v5eG31/Lw22t5HH7rvf32Wh4Fey3P3kt+ey2Pw2+3zuG35sRvr+Vht9eyTXZ7LR9fyW299+Mrub29H1/Jbb334yu5vb0fX8ltt87jK7mtOXl8Jbe39+Mrub29H1/J7+09u633fnwlv7f37Lbe+/GV/N7exXstX70qZ7c1J4+v5Pf2tttr+fhKfm/v2W29d5vs9lo+vpLbeu/HV/J7ey9uu3UeXynsZpzdXsvHV/J7e9vttXx8Jbf13o+v5Pf2Xt3Wez++kt/be3XbrfP4Sm5rTh5fye/tbbfX8vGV/N7eq9t678dX8nt7r27rvdtkt9fy8ZXcdus8vpLbmpPHV/J7e9vttXx8Jb+3d7it9358Jb+3d7it9358Jb+3d3PbrfP4Sm5rTh5fye/tbbfX8vGV/N7ezW299+Mr+b29m9t678dX8nt7N7fdOo8/7bfmxG6v5eNP+7297fZaPv502L2X7PZaPv6023rvx5/2e3t3t906jz/tt+bEbq/l4yv5vb3t9lo+vpLbeu/HV/J7e29u670fX8nv7b257dZ5fCW/NSd2ey0ff8/v7W231/Lx9/zWe9vttXz8vbB7L9nttXz8PbfdOo+/57fmxG6v5ePv+b297fZaPr6S33pvu72Wj6/kt97bbq/l4yv57dY5/Nac2O21fHwlv7e3317LebJb7z377bWcJ7v13rPfXst5CrdX5TzZrTmZ/fZazpPd23v222s5T3brvWe/vZbzbLfee/bbaznPdrt15l/fa3k+4/z2Ws5+ey1nv72W82y33nv222s5L3brvWe/vZbzYrdbZ17s1pzMfnstZ7+9lrPfXst5sVvvPfvttZwXu/Xes99ey3m1260zr3ZrTma/vZaz317L2W+v5bzarfee/fZazqvdeu/Zb6/lHHa7deawW3My++21nP32Ws5+ey3nsFvvPfvttZzDbr337LfXcg673Tpzs1tzMvvttZz99lrOfnst51/fa3n+XvLbazk3u/Xes99ey7nZ7daZm9+aE7+9lrPfXsvZb6/l3O3We89+ey3nbrfee/bbazl3u906c/dbc+K313L222s5++21nDe79d6z317LuWCv5dl7yW+v5bzZ7daZN781J357LWe/vZaz317Lefdb7+2313Le/dZ7++21nHe73Trz7rfmxG+v5ey313L222s5H37rvf32Ws6H33pvv72Wc/Fey1evysNvzYnfXsvZb6/l7LfXcj7s1nsvfnstl8luvffit9dymex26yxTuM24xW+v5eK313Lx22u5THbrvRe/vZbLbLfee/Hba7nMdrt1ltluzcnit9dy8dtrufjttVxmu/Xei99ey2W2W++9+O21XBa73TrLYrfmZPHba7n47bVc/PZaLovdeu/Fb6/lstit91789louq91unWW1W3Oy+O21XPz2Wi5+ey2X1W699+K313JZ7dZ7L357LZfVbrfOEnZrTha/vZaL317LxW+v5fLrey3P30t+ey2XsFvvvfjttVzCbrfOEnZrTha/vZaL317LxW+v5dLs1nsvfnstl2a33nvx22u5NLvdOkuzW3Oy+O21XPz2Wi5+ey2Xbrfee/Hba7kU7LU8ey/57bVcut1unaX7rTnx22u5+O21XPz2Wi6b3XrvxW+v5bLZrfde/PZaLpvdbp1l81tz4rfXcvHba7n47bVcdr/13n57LZfdb723317LpXiv5atX5e635sRvr+Xit9dy8dtruex+67399louh996b7+9lsvht1vn1/dans84v72Wi99ey8Vvr+Vy+K339ttruU52671Xv72W62S3W2ed7NacrJPd23v122u5+u21XCe79d6r317LdbJb77367bVcZ7vdOutst+Zk9dtrufrttVz99lqus91679Vvr+U62633Xv32Wq6L3W6ddbFbc7L67bVc/fZarn57LdfFbr336rfXcl3s1nuvfnst18Vut8662q05Wf32Wq5+ey1Xv72W66/vtTx/L/nttVxXu/Xeq99ey3W1262zrnZrTla/vZar317L1W+v5Rp2671Xv72Wa9it91799lquYbdbZw27NSer317L1W+v5eq313Jtduu9V7+9lmvBXsuz95LfXsu12e3WWZvdmpPVb6/l6rfXcvXba7l2u/Xeq99ey7Xbrfde/fZart1ut87a/dac+O21XP32Wq5+ey3XzW699+q313Ld7NZ7r357LdfivZavXpWb35oTv72Wq99ey9Vvr+W6+a339ttrue5+67399lquu91unfX391ou8Zxx87LFi6/067X3cvz5Suv86it1v6+0+X2lX/9Xy3U+/nyleBXvw+4r/f5ey/OvNP9+luZvX2l98ZVev70f/0739VfW76+z+et/tr73P3v9Foz9+T97wHjxP2vv/c9ev02i73/+Z9uL/9l2+j+b1xf/s9ezsk/T1/+sr8eL/9lx+j/r/5dkJHvR+tz//LX9xf9sfu9/trzzbJHsuzp9tnjvS7b3/mf9vWfb3nu2/b0vebz1P0v2vJw9W7Iv5ezZkr0jp19yfe9/Fu89W3vv2fp7X3J773+2v/ds771LlvfeJct775LlvXfJ8t67ZHnvXbK89y5Z3nuXLO+9S5b33iXLe++S9b13yfreu2R9712yvvcuWd97l6zvvUvW994l63vvkvW9d8n63rsk3nuXxHvvknjvXRLvvUvivXdJvPcuiffeJfHeuyTee5fEe++S9t67pL33LmnvvUvae++S9t67pL33LmnvvUvae++S9t67pL33LunvvUv6e++S/t67pL/3LunvvUv6e++S/t67pL/3LunvvUv6e++S7b13yfbeu2R7712yvfcu2d57l2zvvUu2994l23vvku29d8n23rtkf+9dsr/3Ltnfe5fs771L9vfeJft775L9vXfJ/t67ZH/vXbK/9y453nuXHO+9S4733iXHe++S4713yfHeu+R4711yvPcuea/3Gu/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xtt7vdf2Xu+1vdd7be/1Xvt7vdf+Xu+1v9d77e/1Xvt7vdf+Xu+1v9d77e/1Xvt7vdf+Xu+1v9d77e/1Xvt7vdf+Xu+1v9d77e/1Xvt7vdf+Xu+1v9d77e/1Xvt7vdf+Xu+1v9d77e/1Xvt7vdf+Xu+1v9d77e/1Xvt7vdf+Xu+1v9d77e/1Xvt7vdf+Xu+1v9d77e/1Xvt7vdf+Xu+1v9d77e/1Xvt7vdf+Xu+1v9d77e/1Xvt7vdf+Xu+1v9d77e/1Xvt7vdf+Xu+1v9d77e/1Xvvr3uvjh+hr29zjdf+3bXMvdhBG//obc2zzi7+x/sLfiH//Nx7/ZP31Nx7/wPjib7Rf+Bv9F/7G9gt/Y3/9N/ry/BvH/G/H/Pjv/8brHvc/+xtnrF43xMV/Y/mFv7H+wt9I5vnxteP5UR21fzvm7Rf+Rv/3f+OU1fYLf2P/hb9x/Pd/4/W/Ujxq5vn5N/r2L8f89T9piP/G8u//ximr9Rf+RvzC32i/8Ddez/N1+zrO4WEF/7b2ef0PPOK/sf/7v3HK6vjv/8Y+/cLfmH/hb7ye5zE/f2sjjn855q//uUv8N+Lf/41TVu0X/kb/hb+x/cLfeD3Pj/Xrb2xLj7O/MT0PJ2rrt6O34sWHH/+1rw8v/Vt1OP/PQTT/59OP9/HXu3ndpj8HrCz96+sfH/31X//75ud8/fmzv/7y2V9//eyvH5/99dtnf/3+2V9/++yv/9m/usdH/+pu00f/6m7TR//qbtNH/+pu00f/6m7T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+upz/8fQ29OEVaHP9nRgWeit218Weuvel4XeuvFloU8W+lWht255Weit+10Weutml4XeutllobdudlXoi3Wzy0Jv3eyy0Fs3uyz01s0uC32y0K8KvXWzy0Jv3eyy0Fs3uyz01s0uC711s6tCX62bXRZ662aXhd662WWht252WeiThX5V6K2bXRZ662aXhd662WWht252Weitm10V+mbd7LLQWzf7/dB/Q+a2WYv6k3hqytw2a1F1UzlZPFelsvWduqlszeSyVLZmUjeVrUNclsrWIaqmcre2b1Uqd2v7dFPZ2r5lqWxtn24qJ4vnqlS2tk83la3tW5bK1vbpprK1fctS2do+zVTOztq+RamcnbV9uqlsbd+yVLa2TzeVk8VzVSpb26ebytb2LUtla/t0U9navmWpbG2faip7a/tWpbK3tk83la3tW5bK1vbppnKyeK5KZWv7dFPZ2r5lqWxtn24qW9u3LJWt7VNN5WBt36pUDtb26aaytX3LUtnaPt1UThbPValsbZ9uKlvbtyyVre3TTWVr+5alsrV9qqkcre1blcrR2j7dVLa2b1kqW9unm8rJ4rkqla3t001la/uWpbK1fbqpbG3fslS2tk81lZO1fatSOVnbp5vK1vYtS2Vr+3RTOVk8V6WytX26qWxt37JUtrZPN5Wt7VuWytb2/SD0NR//fqutDlI5Y7d9l7P89dO5VCGeJdbr7yuU++g/ieZdXqbu7j49IrmcbN01L1Mq94n5+OHa/XULqT3WxyzO2B3fp0Yduy/81Khjt4SfGvVkUV8Qdeye8VOjjt1ZfmrUsZvKT406duv5qVHH7jo/NOrFetMVUbfedEXUrTddEXXrTVdEPVnUF0TdetMVUbfedEXUrTddEXXrTVdE3XrTBVGv1puuiLr1piuibr3piqhbb7oi6smiviDq1puuiLr1piuibr3piqhbb7oi6tabLoh6s950RdStN10RdetNV0TdetMVUU8W9QVRt950RdStN10RdetNV0TdetMVUbfedEHUu/WmK6JuvemKqFtvuiLq1puuiHqyqC+IuvWmK6JuvemKqFtvuiLq1puuiLr1pvOjXpz1piuibr3piqhbb7oi6tabroh6sqgviLr1piuibr3piqhbb7oi6tabroi69aYLou6tN10RdetNV0TdetMVUbfedEXUk0V9QdStN10R9X1703KExl8+Pjfq+/amK6O+b2+6Mur79qYLox727U1XRn3f3nRl1PftTVdGfd/edGXUk0V9QdT37U1XRt160xVRt950RdStN10RdetNF0Q9Wm+6IurWm66IOnhvWvP10yVKv42cy/WXjosLf332j6/gHaGqr2kjX8G7H1VfwXsOVV/BT/qqvoKfr1V9BT/VavqawM+Sqr6Cn+BUfd3o3JQ2OjeltJGvG52b0kbnprTRuSltdG5KG52b8kbnprzRuSlvdG7KG52bctrI143OTXmjc1Pe6NyUNzo35Y3OTWWjc1PZ6NxUNjo3lY3OTSV9jq+1XL+Ybi6NfP2gc5Po6wedm0RfP+jcJPr6Qecm0dcPOjdJvqL/Nruqrx90bhJ9/aBzk+jrB52bRF/TRr5udG5C/31pVV83Ojeh/5ayqq8bnZvQfzdY1deNzk3ov5Gr6usHnZtauH645dHzJvTfg/2Jr97X68M173sfeftBJ6dvePtBZ6dvePtBp6dvePtB56dvePtBJyjZW/Tft1T29oNOUd/w9oPOUd/w9oNOUt/wNm3l7VZnKfTf61P2dquzFPrv0yl7u9NZqqL/HpuytzudpSr6748pe7vTWaq6tJW3O52lKvrvSyl7u9NZqqL/npKyt1udpdB/P0jZ263OUui/l6Ps7VZnKfTfh1H2dquzFPrvoSh7u9VZCv33P5S93eoshf57F8rebnWWQv99B2VvtzpLof+egbK3W52l0PX7lb3d6iyFrlev7O1WZyl0fXZlb7c6S32SHvk3vN3qLPVJmuTf8Hars9Qn6ZJ/w9utzlKfpE3+DW+3Okt9kj75N7zd6iz1SRrl3/B2q7PUJ+mUf8Pbrc5Sn6RV/g1vtzpLfZJe+Te83eos9Uma5d/wdquz1Cfpln/D263OUp+kXf4Nb7c6S32Sfvk3vN3qLPVJGubf8Hars9Qn6Zh/w9utzlKfpGX+DW+3Okt9kp75N7zd6iz1SZrm3/B2q7PUJ+maf8Pbrc5Sn6Rt/g1vtzpLfZK++Te83eos9Uka59/wdquz1CfpnH/D263OUp+kdf4Nb7c6S32S3vk3vN3qLPVJmuff8Hars9RWuud1K93zupXued1K97xupXtet9I9r1vpntetdM/rVrrndSvd87qV7nndSve8bqV7XrfSPa9b6Z7XrXTP21a6520r3fO2le5520r3vLm0lbc7naXaVrrnbSvd87aV7nnbSve8baV73rbSPW9b6Z63rXTP21a6520r3fO2le5520r3vG2le9620j1vW+met610z9tWuudtK93ztpXuedtK97xtpXvettI9b1vpnretdM/bVrrnbSvd87aV7nnbSve8baV73rbSPW9b6Z63rXTP21a6520r3fO2le5520r3vG2le9620j1vW+met610z9tWuudtK93ztpXuedtK97xtpXvettI9b1vpnretdM/bVrrnbSvd87aV7nnbSve8baV73rbSPW9b6Z63rXTP21a6520r3fO2le5520r3vG2le9620j1vW+met610z9tWuudtK93ztpXuedtK97xtpXvettI9b1vpnretdM/bVrrnbSvd87aV7nnbSve8baV73rbSPW9b6Z63rXTP20fpnod2gETXRt5+0lkqtnoFST6OvFU4S5V8JFD1/rW3PpUjNCXkO2/HsQnp6m1w97Epg0/31P58uNcufLa6OwfvPluvcekWl1FcNLTUYeLSrx/2zv8dmD/O+p2cDTs5G3dyNn2Os97H22mlxJG3eStvy1be1g/yNvjrSc6HVEbeftDZ7BveftCJ69JIHXty8En4dPL9ekBLwdcb9u/IdPdBZy7lyHzQAU05Mh90mlOOzAcd/ZQjkywyTyLzUWdK1ch81PlTNTKfdFbVjcwnnWt1I2Nn4CeR8XYGfhYZOwM/i4ydgZ9Fxs7AzyKTLDJPImNn4GeRsTPws8jYGfhZZOwM/CwydgZ+EplgZ+BnkbEz8LPI2Bn4WWTsDPwsMski8yQydgZ+Fhk7Az+LjJ2Bn0XGzsDPImNn4CeRiXYGfhYZOwM/i4ydgZ9Fxs7AzyKTLDJPImNn4GeRsTPws8jYGfhZZOwM/CwydgZ+Epn0qWfgPJj57+mTzrWxHN7GnkfeftJZVfb2k86fMcXD2/+8vXLiHk8WmSeR+aTz511k0n8+/cfbTzpT5ni8jZ7L0NtPOifK3n7S2U/29pPOc7m549927h93tPxJ5zndyHzS2e8+Mne+3u6Q/Elnv9JvIC6NvP2ks5/sbfokb+stk/s/3+OfdJ7Tjcwnnf3uInMPcneHfNLZ7/L46vpvd/+vHU/+pHPifWSqG+XBJ50Tuz+egFwa14G35ZPOfrK3n3SeU73Hyyed/cR7vHzS2U/O+rSVt590ntO9xz/pPCff4590npOz/pPOaLK3n3RGU73H6yed58R7vH7SeU7M+vpJZzTZ2086o+ne42mre/yTznNy1n/SGU321p65PbvHt3rmVrd65ta2eubW7Jnbk3u8bfXMrW31zE3j92iIvLVnbs/u8a2eubWtnrl90m/XfMNbe+b25B7/pN+kke/xT/pRGjnrP+lXab7hrT1ze3aPp63u8a2euX3Ub9jI3tozt2f3+FbP3D7q926ErO/uo37DRvbWnrkN7/FLZDZ65nbxdqNnbhdv01be2jO3Z/f4Rs/cLt5u9Mzt4u1Gz9wu3toztyf3+Ef9Hot4j3/Sb6wEV69XNvgYRt5+0BntG95+0BktuHx9C//ieP3Xezx9ZmR88qM8wD7PhXp4G8d5jH3qkvmxz1E5XP/pONK3uPBjn4xkfuyzjsgP/usYMj/2GSO36+93x+LyP1YW8F+l0PUV+3xx76tvo7xM5PzYdV3mx67rMj92XU89HPuyqyN+7Lou85PXdXDFf5kfvK6L/OC1WuTnqb//fNYAV63X9ZW8roOrxcv84P26yA/er4v82HVdPJeAq5jL/OR1HVxpXOYHr+siP3itFvl56u8/nzXAVbh1fSWv6+Cq2jI/eL8u8YOrWcv82HVdPJeAq0jL/OR1HVzpWeYHr+siP3itFvl56u8/nzXAlY11fSWv6+BKxTI/z/frY36e78zH/Nh1XTyXgKv4yvzkdR1cPVfmJ59vA1e4lfl56u8/nzXAVWh1fSWv6+CqsjI/+XwbuJqrzI9d18VzCbjiqsxPXtfBlU5lfvL5NnA1Upl/o7l1cMVQXV/J6zq4AqjMTz7fBq68KfOTz62Dq2PK/OR1HVyVUuYnn28DV46U+TeaWwdXd9T1lbyug6s1yvzk823gKokyP/fcugdXMpT5ueu6B1cQlPm559u8A6/VIv8+c+seXIlP11fuuu7BlfVkfu75Ng+uaCfzc8+te3DVOZmfvK6Dq73J/NzzbR5cv03m32du3aNrvan6Sl7X0XXhRH7u+TZPpPU25ueeW/fg+m0yP3ldR9dvE/m559s8uH6bzL/P3LpH13pT9ZW8rqPrwon83PNtnkjrbczPPbfuwfXbZH7yuo6u3ybyc8+3eXD9Npl/n7l1j671puoreV1H14UT+bnn2zyR1tuYn3tu3YPrt8n85HUdXb9N5CefbwPXb5P595lb9+hab6q+ktd1dF04kZ98vo1I623MTz63Dq7fJvOT13V0/TaRn3y+DVy/TebfaG4dXetN1Vfyuo6uCyfyk8+3EWm9jfnJ59bB9dtkfvK6jq7fJvKTz7eB67fJ/BvNraNrvan6Sl7X0XXhRH7y+TYirbcxP/ncOrh+m8xPXtfR9dtEfvL5NnD9Npl/o7l1dK03VV/J6zq6LpzITz7fRqT1NuYnn1sH12+T+cnrOrp+m8jPPd8WwPXbZP595tYDutabqq/cdT047roeiHThxvzc820BXL9NOpcEcP02mZ+8rqPrt4n83PNtAVy/TebfZ249oGu9qfpKXtfRdeFEfu75tkCk9Tbm555bD+D6bTI/eV1H128T+bnn2wK4fpvMv8/cekDXelP1lbyuo+vCifzc822BSOttzM89tx7A9dtkfvK6jq7fJvJzz7cFcP02mX+fufWArvWm6it5XUfXhRP5uefbApHW25ife249gOu3yfzkdR1dv03k555vC+D6bTL/PnPrAV3rTdVX8rqOrgsn8pPPtxFpvY35uefWA7h+m8xPXtfR9dtEfvL5NnD9Npl/o7l1dK03VV/J6zq6LpzITz7fRqT1NuYnn1sH12+T+cnrOrp+m8hPPt8Grt8m8280t46u9abqK3ldR9eFE/nJ59uItN7G/ORz6+D6bTI/eV1H128T+cnn28D122T+jebW0bXeVH0lr+vounAiP/l8G5HW25iffG4dXL9N5iev6+j6bSI/+XwbuH6bzL/R3Dq61puqr9x1PaLrwon83PNtkUjrbczPPbceHXZdl/m563pE128T+bnn2yK4fpvMv8/cekTXelP1lbyuo+vCifzc822RSOttzM89tx7B9dtkfvK6jq7fJvJzz7dFcP02mX+fufWIrvWm6it5XUfXhRP5uefbIpHW25ife249guu3yfzkdR1dv03k555vi+D6bTL/PnPrEV3rTdVX8rqOrgsn8nPPt0UirbcxP/fcegTXb5P5yes6un6byM893xbB9dtk/n3m1iO61puqr+R1HV0XTuQnn28j0nob83PPrUdw/TaZn7yuo+u3ifzk823g+m0y/z5z6xFd603VV/K6jq4LJ/KTz7cRab2N+cnn1sH122R+8rqOrt8m8pPPt4Hrt8n8G82to2u9qfpKXtfRdeFEfvL5NiKttzE/+dw6uH6bzE9e19H120R+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J/Izz7d98TPPt33xM8+tf/Ezz61/8ZPXdXT9NpGffL4NXL9N5t9lbv3LV55a/e++ktd1dF04kZ98vo1I623MTz63Dq7fJvOT13V0/TaRn3y+DVy/TebfaG4dXetN1Vfyuo6uCyfyk8+3EWm9jfnJ59bB9dtkfvK6jq7fJvKTz7eB67fJ/BvNraNrvan6Sl7X0XXhRH7y+TYirbcxP/ncOrh+m8xPXtfR9dtEfvL5NnD9Npl/o7l1dK03VV/J6zq6LpzITz7fRqT1NuYnn1sH12+T+cnrOrp+m8jPPd/mwfXbZP595tY9utabqq/cdd077rruiXThxvzc820eXL9NOpd4cP02mZ+8rqPrt4n83PNtHly/TebfZ27do2u9qfpKXtfRdeFEfu75Nk+k9Tbm555b9+D6bTI/eV1H128T+bnn2zy4fpvMv8/cukfXelP1lbyuo+vCifzc822eSOttzM89t+7B9dtkfvK6jq7fJvJzz7d5cP02mX+fuXWPrvWm6it5XUfXhRP5uefbPJHW25ife27dg+u3yfzkdR1dv03k555v8+D6bTL/PnPrHl3rTdVX8rqOrgsn8pPPtxFpvY35uefWPbh+m8xPXtfR9dtEfvL5NnD9Npl/o7l1dK03VV/J6zq6LpzITz7fRqT1NuYnn1sH12+T+cnrOrp+m8hPPt8Grt8m8280t46u9abqK3ldR9eFE/nJ59uItN7G/ORz6+D6bTI/eV1H128T+cnn28D122T+jebW0bXeVH0lr+vounAiP/l8G5HW25iffG4dXL9N5iev6+j6bSI/+XwbuH6bzL/R3Dq61puqr9x1PaDrwon83PNtgUjrbczPPbceHHZdl/m563pA128T+bnn2wK4fpvMv8/cekDXelP1lbyuo+vCifzc822BSOttzM89tx7A9dtkfvK6jq7fJvJzz7cFcP02mX+fufWArvWm6it5XUfXhRP5uefbApHW25ife249gOu3yfzkdR1dv03k555vC+D6bTL/PnPrAV3rTdVX8rqOrgsn8nPPtwUirbcxP/fcegDXb5P5yes6un6byM893xbA9dtk/n3m1gO61puqr+R1HV0XTuQnn28j0nob83PPrQdw/TaZn7yuo+u3ifzk823g+m0y/z5z6wFd603VV/K6jq4LJ/KTz7cRab2N+cnn1sH122R+8rqOrt8m8pPP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m3QuKeD6bTI/eV1H128T+bnn2wq4fpvMv8/cekHXelP1lbyuo+vCifzc822FSOttzM89t17A9dtkfvK6jq7fJvJzz7cVcP02mX+fufWCrvWm6it5XUfXhRP5uefbCpHW25ife269gOu3yfzkdR1dv03k555vK+D6bTL/PnPrBV3rTdVX8rqOrgsn8nPPtxUirbcxP/fcegHXb5P5yes6un6byM8931bA9dtk/n3m1gu61puqr+R1HV0XTuQnn28j0nob83PPrRdw/TaZn7yuo+u3ifzk823g+m0y/0Zz6+hab6q+ktd1dF04kZ98vo1I623MTz63Dq7fJvOT13V0/TaRn3y+DVy/TebfaG4dXetN1Vfyuo6uCyfyk8+3EWm9jfnJ59bB9dtkfvK6jq7fJvKTz7eB67fJ/BvNraNrvan6Sl7X0XXhRH7y+TYirbcxP/ncOrh+m8xPXtfR9dtEfvL5NnD9Npl/o7l1dK03VV+563pF14UT+bnn2yqR1tuYn3tuvTrsui7zc9f1iq7fJvJzz7dVcP02mX+fufWKrvWm6it5XUfXhRP5uefbKpHW25ife269guu3yfzkdR1dv03k555vq+D6bTL/PnPrFV3rTdVX8rqOrgsn8nPPt1UirbcxP/fcegXXb5P5yes6un6byM8931bB9dtk/n3m1iu61puqr+R1HV0XTuTnnm+rRFpvY37uufUKrt8m85PXdXT9NpGfe76tguu3yfz7zK1XdK03VV/J6zq6LpzITz7fRqT1Nubnnluv4PptMj95XUfXbxP5yefbwPXbZP595tYrutabqq/kdR1dF07kJ59vI9J6G/OTz62D67fJ/OR1HV2/TeQnn28D12+T+TeaW0fXelP1lbyuo+vCifzk821EWm9jfvK5dXD9NpmfvK6j67eJ/OTzbeD6bTL/RnPr6Fpvqr6S13V0XTiRn3y+jUjrbcxPPrcOrt8m85PXdXT9NpGffL4NXL9N5t9obh1d603VV/K6jq4LJ/KTz7cRab2N+bnn1hu4fpvMz13XG7p+m8jPPd/WHHitFvn3mVtv6Fpvqr5y1/WGrgsn8nPPtzUirbcxP/fcegPXb5P5yes6un6byM8939bA9dtk/n3m1hu61puqr+R1HV0XTuTnnm9rRFpvY37uufUGrt8m85PXdXT9NpGfe76tgeu3yfz7zK03dK03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","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"10":{"source":"pub struct Vec<T> {\n    pub(crate) slice: [T],\n}\n// A mutable vector type implemented as a wrapper around immutable slices.\n// A separate type is technically not needed but helps differentiate which operations are mutable.\nimpl<T> Vec<T> {\n    pub fn new() -> Self {\n        Self { slice: &[] }\n    }\n\n    // Create a Vec containing each element from the given slice.\n    // Mutations to the resulting Vec will not affect the original slice.\n    pub fn from_slice(slice: [T]) -> Self {\n        Self { slice }\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Panics if the given index\n    /// points beyond the end of the vector.\n    pub fn get(self, index: u32) -> T {\n        self.slice[index]\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn set(&mut self, index: u32, value: T) {\n        self.slice[index] = value;\n    }\n\n    /// Push a new element to the end of the vector, returning a\n    /// new vector with a length one greater than the\n    /// original unmodified vector.\n    pub fn push(&mut self, elem: T) {\n        self.slice = self.slice.push_back(elem);\n    }\n\n    /// Pop an element from the end of the given vector, returning\n    /// a new vector with a length of one less than the given vector,\n    /// as well as the popped element.\n    /// Panics if the given vector's length is zero.\n    pub fn pop(&mut self) -> T {\n        let (popped_slice, last_elem) = self.slice.pop_back();\n        self.slice = popped_slice;\n        last_elem\n    }\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    pub fn insert(&mut self, index: u32, elem: T) {\n        self.slice = self.slice.insert(index, elem);\n    }\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the removed element\n    pub fn remove(&mut self, index: u32) -> T {\n        let (new_slice, elem) = self.slice.remove(index);\n        self.slice = new_slice;\n        elem\n    }\n\n    /// Returns the number of elements in the vector\n    pub fn len(self) -> u32 {\n        self.slice.len()\n    }\n}\n\nmod tests {\n    use crate::collections::vec::Vec;\n\n    #[test]\n    fn set_updates_values_properly() {\n        let mut vec = Vec { slice: &[0, 0, 0, 0, 0] };\n\n        vec.set(0, 42);\n        assert_eq(vec.slice, &[42, 0, 0, 0, 0]);\n\n        vec.set(1, 43);\n        assert_eq(vec.slice, &[42, 43, 0, 0, 0]);\n\n        vec.set(2, 44);\n        assert_eq(vec.slice, &[42, 43, 44, 0, 0]);\n\n        vec.set(1, 10);\n        assert_eq(vec.slice, &[42, 10, 44, 0, 0]);\n\n        vec.set(0, 0);\n        assert_eq(vec.slice, &[0, 10, 44, 0, 0]);\n    }\n\n    #[test(should_fail)]\n    fn panics_when_writing_elements_past_end_of_vec() {\n        let mut vec = Vec::new();\n        vec.set(0, 42);\n\n        // Need to use println to avoid DIE removing the write operation.\n        crate::println(vec.get(0));\n    }\n}\n","path":"std/collections/vec.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"20":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"26":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// docs:start:sha256\n#[deprecated(\"sha256 is being deprecated from the stdlib, use https://github.com/noir-lang/sha256 instead\")]\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\n#[deprecated(\"sha256 is being deprecated from the stdlib, use https://github.com/noir-lang/sha256 instead\")]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\n#[deprecated(\"sha256 is being deprecated from the stdlib, use https://github.com/noir-lang/sha256 instead\")]\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        // Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        // Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    // Safety: the msg_len is checked below in verify_msg_len\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n\n        // Safety: testing context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        // Safety: test context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        // Safety: testing context\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n","path":"std/hash/sha256.nr"},"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"61":{"source":"mod tests;\nmod utils;\n\nuse jwt::JWT;\n\nuse zkemail::{\n    headers::{body_hash::get_body_hash, email_address::get_email_address},\n    MAX_EMAIL_ADDRESS_LENGTH, partial_hash::partial_sha256_var_end,\n    dkim::RSAPubkey, KEY_LIMBS_2048, Sequence\n};\n\nuse utils::position_and_salary_extractor::{\n    extract_position_from_email_body, // @dev - extract_position_from_email_body() function\n    extract_salary_from_email_body    // @dev - extract_salary_from_body() function\n}; \nuse utils::email_2048_bit_dkim_verifier::{\n    MAX_EMAIL_HEADER_LENGTH, MAX_EMAIL_BODY_LENGTH, \n    verify_email_2048_bit_dkim,        // @dev - verify_email_2048_bit_dkim() function\n};\n\n// @dev - [NOTE]: The following imported-variables are temporary variables. They are stored into the \"test_header\" and \"test_body\" for passing the verify_email_2048_bit_dkim() function. Thus, this should be removed once appropreate implementation will be done in the future.\nuse tests::test_inputs::{\n    EmailLarge::{\n        HEADER, BODY,\n    },\n    EmploymentOfferEmailLarge::{\n        EMPLOYMENT_OFFER_EMAIL_HEADER, EMPLOYMENT_OFFER_EMAIL_BODY,\n        POSITION_BODY, SALARY_BODY,\n    },\n};\n\nglobal MAX_PARTIAL_DATA_LENGTH: u32 = 640; // signed data length after partial SHA\nglobal MAX_DOMAIN_LENGTH: u32 = 64;\nglobal MAX_EMAIL_LENGTH: u32 = 128;\nglobal MAX_POSITION_LENGTH: u32 = 128;\nglobal MAX_SALARY_LENGTH: u32 = 32;\n\n// Rating must be between 1 and 5\nfn verify_rating(rating: u8) {\n    assert(rating >= 1, \"rating must be at least 1\");\n    assert(rating <= 5, \"rating must be at most 5\");\n}\n\n/**\n * @brief Verify JWT signature (RSA/SHA256 only) and validate domain field\n * Also verify position and salary claims\n *\n * @param partial_data: OIDC JWT (id_token) base64 data (`$header.$payload`) as byte array of ascii characters\n *                      We do partial SHA on the data up to hd field outside of the circuit, to reduce constraints\n *                      This field only contains the bytes after partial SHA; padded to MAX_PARTIAL_DATA_LENGTH\n * @param partial_hash: The 256-bit partial hash of the `data`\n * @param full_data_length: The full length of the `data` (before partial SHA)\n * @param base64_decode_offset: Offset needed in `partial_data` to make the payloadB64 a multiple of 4\n *                    Signed data is $header.$payload. $payload might not be a multiple of 4 in `partial_data`, so we need to offset\n *                    Not attack-able by giving an incorrect offset, as string match of domain will fail\n * @param jwt_pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n * @param jwt_pubkey_redc_params_limbs: RSA reduction parameters limbs\n * @param jwt_signature_limbs: RSA signature limbs\n * @param domain: Domain name (`hd` key) as a byte array of ascii characters padded to MAX_DOMAIN_LENGTH\n * @param position: Position at the company as a byte array of ascii characters padded to MAX_POSITION_LENGTH\n * @param salary: Salary at the company as a byte array of ascii characters padded to MAX_SALARY_LENGTH\n * @param work_life_balance: Work-life balance rating (1-5)\n * @param culture_values: Culture and values rating (1-5)\n * @param career_growth: Career growth rating (1-5)\n * @param compensation_benefits: Compensation and benefits rating (1-5)\n * @param leadership_quality: Leadership quality rating (1-5)\n * @param operational_efficiency: Operational efficiency rating (1-5)\n **/\nfn main(\n    partial_data: BoundedVec<u8, MAX_PARTIAL_DATA_LENGTH>,\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    jwt_pubkey_modulus_limbs: pub [u128; 18],\n    jwt_pubkey_redc_params_limbs: [u128; 18],\n    jwt_signature_limbs: [u128; 18],\n    domain: pub BoundedVec<u8, MAX_DOMAIN_LENGTH>,\n    position: pub BoundedVec<u8, MAX_POSITION_LENGTH>,   // Position, which is part of Email Body-extracted from the Entire Email Body.\n    salary: pub BoundedVec<u8, MAX_SALARY_LENGTH>,       // Salary, which is part of Email Body-extracted from the Entire Email Body.\n    work_life_balance: pub u8,\n    culture_values: pub u8,\n    career_growth: pub u8,\n    compensation_benefits: pub u8,\n    leadership_quality: pub u8,\n    operational_efficiency: pub u8,\n\n    // @dev - Input parameters for email verification /w ZKEmail.nr\n    header: BoundedVec<u8, MAX_EMAIL_HEADER_LENGTH>,  // Entire Email Header\n    body: BoundedVec<u8, MAX_EMAIL_BODY_LENGTH>,      // Entire Email Body\n    pubkey: RSAPubkey<KEY_LIMBS_2048>,\n    signature: [Field; KEY_LIMBS_2048],\n    body_hash_index: u32,\n    dkim_header_sequence: Sequence\n) {\n    // Init JWT struct and verify signature\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        jwt_pubkey_modulus_limbs,\n        jwt_pubkey_redc_params_limbs,\n        jwt_signature_limbs,\n    );\n    jwt.verify();\n\n    // Assert email_verified claim\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n\n    // Get email claim\n    let email: BoundedVec<u8, MAX_EMAIL_LENGTH> = jwt.get_claim_string(\"email\".as_bytes());\n\n    // Get domain start_index from email claim - unconstrained, but we verify the domain bytes below\n    // Safety: This function is unconstrained but its output is verified by the domain check below\n    let domain_start_index = unsafe { get_domain_start_index_in_email(email) };\n\n    // Verify domain passed is present in the email claim after the @\n    assert(email.storage()[domain_start_index - 1] == 64, \"char before domain is not '@'\");\n    for i in 0..MAX_DOMAIN_LENGTH {\n        assert(email.storage()[domain_start_index + i] == domain.storage()[i], \"invalid domain\");\n    }\n\n    // Verify position and salary claims\n    // These are separate inputs, NOT from the JWT\n    let position_claim: BoundedVec<u8, MAX_POSITION_LENGTH> = position;\n    for i in 0..MAX_POSITION_LENGTH {\n        assert(position_claim.storage()[i] == position.storage()[i], \"invalid position\");\n    }\n\n    let salary_claim: BoundedVec<u8, MAX_SALARY_LENGTH> = salary;\n    for i in 0..MAX_SALARY_LENGTH {\n        assert(salary_claim.storage()[i] == salary.storage()[i], \"invalid salary\");\n    }\n\n    // Verify ratings are valid (1-5)\n    verify_rating(work_life_balance);\n    verify_rating(culture_values);\n    verify_rating(career_growth);\n    verify_rating(compensation_benefits);\n    verify_rating(leadership_quality);\n    verify_rating(operational_efficiency);\n\n    // @dev - [TODO]: The following variables are temporary variables. They are just for passing the verify_email_2048_bit_dkim() function. Thus, this should be replaced with a given \"header\" and \"body\" going forward.\n    let test_header: BoundedVec<u8, MAX_EMAIL_HEADER_LENGTH> = HEADER;\n    let test_body: BoundedVec<u8, MAX_EMAIL_BODY_LENGTH> = BODY;\n\n    // @dev - Verify an arbitrary email, which is signed by a 2048-bit RSA DKIM signature\n    let return_value: [Field; 2] = verify_email_2048_bit_dkim(\n        test_header,  // [TODO]: Should be replaced with a given \"header\" in the future.\n        //header,\n        test_body,    // [TODO]: Should be replaced with a given \"body\" in the future.\n        //body,\n        pubkey,\n        signature,\n        body_hash_index,\n        dkim_header_sequence\n    );\n\n    // @dev - [TODO]: The following variables are temporary variables. They are just for passing the is_position_found_in_email_body() and is_salary_found_in_email_body() function. Thus, this should be replaced with a given \"body\"/\"position\"/\"salary\" going forward.\n    let test_email_body: BoundedVec<u8, MAX_EMAIL_BODY_LENGTH> = EMPLOYMENT_OFFER_EMAIL_BODY;\n    let test_position: BoundedVec<u8, MAX_POSITION_LENGTH> = POSITION_BODY;\n    let test_salary: BoundedVec<u8, MAX_SALARY_LENGTH> = SALARY_BODY;\n\n    /// @dev - Validate to check whether a given \"position\" is included in the entire email body or not.\n    /// @dev - Compare a given \"position\" (BoundedVec<u8, MAX_POSITION_LENGTH>) and a given \"body\" (BoundedVec<u8, MAX_EMAIL_BODY_LENGTH>)\n    let is_position_found_in_email_body: bool = unsafe { is_position_found_in_email_body(test_position, test_email_body) };\n    //let is_position_found_in_email_body: bool = unsafe { is_position_found_in_email_body(position, body) };\n    assert(is_position_found_in_email_body == true, \"Position can not be found in email body\");\n\n    /// @dev - Validate to check whether a given \"salary\" is included in the entire email body or not.\n    /// @dev - Compare a given \"salary\" (BoundedVec<u8, MAX_SALARY_LENGTH>) and a given \"body\" (BoundedVec<u8, MAX_EMAIL_BODY_LENGTH>)\n    let is_salary_found_in_email_body: bool = unsafe { is_salary_found_in_email_body(test_salary, test_email_body) };\n    //let is_salary_found_in_email_body: bool = unsafe { is_salary_found_in_email_body(salary, body) };\n    assert(is_salary_found_in_email_body == true, \"Salary can not be found in email body\");\n}\n\n\n/**\n * @notice - Get (Identify) a start index of domain in email\n */\nunconstrained fn get_domain_start_index_in_email(email: BoundedVec<u8, MAX_EMAIL_LENGTH>) -> u32 {\n    let mut domain_start_index = 0;\n    for i in 0..MAX_EMAIL_LENGTH {\n        if email.storage()[i] == (\"@\".as_bytes())[0] {\n            domain_start_index = i + 1;\n            break;\n        }\n    }\n\n    domain_start_index\n}\n\n/**\n * @dev - Validate to check whether a given \"position\" is included in the entire email body or not.\n * @dev - Compare a given \"position\" (BoundedVec<u8, MAX_POSITION_LENGTH>) and a given \"body\" (BoundedVec<u8, MAX_EMAIL_BODY_LENGTH>)\n */\nunconstrained fn is_position_found_in_email_body(\n    position: BoundedVec<u8, MAX_POSITION_LENGTH>, \n    body: BoundedVec<u8, MAX_EMAIL_BODY_LENGTH>\n) -> bool {\n    /// @dev - Logging\n    let position_storage = position.storage(); \n    let body_storage = body.storage(); \n    println(f\"position.storage(): {position_storage}\\n\");\n    println(f\"body.storage(): {body_storage}\\n\");\n\n    /// @dev - Look for \"position\" in \"email_body\"\n    let mut is_position_found_in_email_body: bool = false;\n    for i in 0..body.len() {\n        if (position.storage()[0] == body.storage()[i]) {\n            if (position.len() == 1) { // @dev - The position and the sentence in the Email Body would completely be matched - In the case that the number of vectors of \"position\" is \"1\". \n                is_position_found_in_email_body = true;\n                break;\n            }\n\n            let mut position_array: Vec<u8> = Vec::new();\n            //let mut position_array: BoundedVec<Field, position.len()> = BoundedVec::new();\n            for j in 1..position.len() {\n                if (position.storage()[j] == body.storage()[i+j]) {\n                    position_array.push(position.storage()[j]);\n                    println(f\"position_array: {position_array}\\n\");\n\n                    /// @dev - Logging\n                    let position_len = position.len() - 1;\n                    let position_array_len = position_array.len();\n                    println(f\"position.len() - 1: {position_len}\\n\");\n                    println(f\"position_array.len(): {position_array_len}\\n\");\n\n                    /// @dev - The position and the sentence in the Email Body would completely be matched - In the case that the number of vectors of \"position\" is \"many\" (Not \"1\"). \n                    if ((j == position.len() - 1) & (position_array.len() == position.len() - 1)) { /// @dev - Since \"j\" get started from \"1\", \"1\" should be subtracted from the position.len()\n                        is_position_found_in_email_body = true;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    is_position_found_in_email_body\n}\n\n/** \n * @dev - Validate to check whether a given \"salary\" is included in the entire email body or not.\n * @dev - Compare a given \"salary\" (BoundedVec<u8, MAX_SALARY_LENGTH>) and a given \"body\" (BoundedVec<u8, MAX_EMAIL_BODY_LENGTH>)\n * @dev - In the following implementation, the maximum number of sequences-matched is 5. (\"5\" is enuough for judging whether a given salary is included in the email body or not)\n */\nunconstrained fn is_salary_found_in_email_body(\n    salary: BoundedVec<u8, MAX_SALARY_LENGTH>, \n    body: BoundedVec<u8, MAX_EMAIL_BODY_LENGTH>\n) -> bool {\n    let mut is_salary_found_in_email_body: bool = false;\n    for i in 0..body.len() {\n        if (salary.storage()[0] == body.storage()[i]) {\n            if (salary.len() == 1) {\n                // @dev - Salary is found in the email body\n                is_salary_found_in_email_body = true;\n                break;\n            }\n\n            let mut salary_array: Vec<u8> = Vec::new();\n            //let mut salary_array: BoundedVec<Field, salary.len()> = BoundedVec::new();\n            for j in 1..salary.len() {\n                if (salary.storage()[j] == body.storage()[i+j]) {\n                    salary_array.push(salary.storage()[j]);\n                    println(f\"salary_array: {salary_array}\\n\");\n\n                    /// @dev - Logging\n                    let salary_len = salary.len() - 1;\n                    let salary_array_len = salary_array.len();\n                    println(f\"salary.len() - 1: {salary_len}\\n\");\n                    println(f\"position_array.len(): {salary_array_len}\\n\");\n\n                    // @dev - The position and the sentence in the Email Body would completely be matched - In the case that the number of vectors of \"position\" is \"many\" (Not \"1\"). \n                    if ((j == salary.len() - 1) & (salary_array.len() == salary.len() - 1)) { /// @dev - Since \"j\" get started from \"1\", \"1\" should be subtracted from the position.len()\n                        is_salary_found_in_email_body = true;\n                        break;\n                    }\n                }\n            }\n         }\n    }\n\n    is_salary_found_in_email_body\n}","path":"/Users/unomasanori/Projects/DEMO_MVP/NoirNoirHack - OpenBands (zkGlassdoor )/actual-impl/OpenBands/circuit/src/main.nr"},"64":{"source":"use std::{collections::bounded_vec::BoundedVec, hash::{pedersen_hash, sha256_var}};\nuse zkemail::{dkim::RSAPubkey, headers::body_hash::get_body_hash, KEY_LIMBS_2048, Sequence};\n\nglobal MAX_EMAIL_HEADER_LENGTH: u32 = 512;\nglobal MAX_EMAIL_BODY_LENGTH: u32 = 1024;\n\n/**\n * Verify an arbitrary email signed by a 2048-bit RSA DKIM signature\n * @dev TOTAL CONSTRAINTS: ~222,783\n *\n * @param header - The email header, 0-padded at end to the MAX_EMAIL_HEADER_LENGTH\n * @param body - The email body, 0-padded at end to the MAX_EMAIL_BODY_LENGTH\n * @param pubkey - The DKIM RSA Public Key modulus and reduction parameter\n * @param signature - The DKIM RSA Signature\n * @param body_hash_index - The index of the body hash in the partial hash array\n * @param dkim_header_sequence - The index and length of the DKIM header field\n * @return - \n *         0: Pedersen hash of DKIM public key (root of trust)\n *         1: Pedersen hash of DKIM signature (email nullifier)\n */\nfn verify_email_2048_bit_dkim(\n    header: BoundedVec<u8, MAX_EMAIL_HEADER_LENGTH>,\n    body: BoundedVec<u8, MAX_EMAIL_BODY_LENGTH>,\n    pubkey: RSAPubkey<KEY_LIMBS_2048>,\n    signature: [Field; KEY_LIMBS_2048],\n    body_hash_index: u32,\n    dkim_header_sequence: Sequence,\n) -> pub [Field; 2] {\n    // check the body and header lengths are within bounds\n    assert(header.len() <= MAX_EMAIL_HEADER_LENGTH);\n    assert(body.len() <= MAX_EMAIL_BODY_LENGTH);\n\n    // ~ 86,553 constraints\n    // verify the dkim signature over the header\n    pubkey.verify_dkim_signature(header, signature);\n\n    // ~ 6,289 constraints\n    // extract the body hash from the header\n    let signed_body_hash = get_body_hash(header, dkim_header_sequence, body_hash_index);\n\n    // ~ 113,962 constraints\n    // hash the asserted body\n    let computed_body_hash: [u8; 32] = sha256_var(body.storage, body.len() as u64);\n\n    // compare the body hashes\n    assert(\n        signed_body_hash == computed_body_hash,\n        \"SHA256 hash computed over body does not match body hash found in DKIM-signed header\",\n    );\n\n    // ~ 10,255 constraints\n    // hash the pubkey and signature for the standard outputs\n    let email_nullifier = pedersen_hash(signature);\n    [pubkey.hash(), email_nullifier]\n}\n","path":"/Users/unomasanori/Projects/DEMO_MVP/NoirNoirHack - OpenBands (zkGlassdoor )/actual-impl/OpenBands/circuit/src/utils/email_2048_bit_dkim_verifier.nr"},"67":{"source":"mod partial_hash;\n\nuse base64::BASE64_URL_DECODER;\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse nodash::str_to_u64;\nuse partial_hash::partial_sha256_var_end;\nuse rsa::rsa::verify_sha256_pkcs1v15;\nuse sha256::sha256_var;\nuse string_search::{StringBody, SubString};\n\n/**\n * @brief Struct representing a JWT. Use the init functions to create an instance\n *        Currently only supports RSA 2048/SHA256 signatures\n **/\npub struct JWT<let MAX_DATA_LENGTH: u32> {\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    pubkey_modulus_limbs: [u128; 18],\n    redc_params_limbs: [u128; 18],\n    signature_limbs: [u128; 18],\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    is_partial_hash: bool, // compile time variable used internally\n}\n\nimpl<let MAX_DATA_LENGTH: u32> JWT<MAX_DATA_LENGTH> {\n    /**\n    * @brief Initialize JWT struct\n    *\n    * @param data: Signed JWT data (base64 encoded `$header.$payload`) as byte array of ascii characters\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Any 4x multiple from the payload start index.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs (2048-bit split into 18 limbs)\n    * @param signature_limbs: RSA signature limbs (2048-bit split into 18 limbs)\n    **/\n    pub fn init(\n        data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(data.len() <= MAX_DATA_LENGTH, \"data length is too long\");\n\n        JWT {\n            data,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            // below fields are not relevant unless for partial hash\n            full_data_length: MAX_DATA_LENGTH,\n            partial_hash: [0; 8],\n            is_partial_hash: false,\n        }\n    }\n\n    /**\n    * @brief Initialize JWT with partial SHA256 hash'ed input\n    *        Since SHA hash is expensive to compute in circuit, we can optimize by pre-hashing up to a certain block outside the circuit,\n    *        and verify for correctness in the circuit. This is possible since SHA works in incremental blocks.\n    *        You can pre-hash up to the SHA-256 block from where you want to extract a claim.\n    *\n    * @param partial_data: Signed JWT data (base64 encoded `$header.$payload`) after partial hashed block\n    * @param partial_hash: The 256-bit partial hash of the `partial_data` up to a certain block\n    * @param full_data_length: The full length of the `data` (before partial SHA)\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Trimming `offset` nubmer of bytes from the data should it base64 decode-able.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs\n    * @param signature_limbs: RSA signature limbs\n    **/\n    pub fn init_with_partial_hash(\n        partial_data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        partial_hash: [u32; 8],\n        full_data_length: u32,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(partial_data.len() <= MAX_DATA_LENGTH, \"partial_data length is too long\");\n\n        JWT {\n            data: partial_data,\n            full_data_length,\n            partial_hash,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            is_partial_hash: true,\n        }\n    }\n\n    /**\n    * @brief Verify JWT signature with RSA 2048/SHA256\n    **/\n    pub fn verify(mut self) {\n        let mut data_hash: [u8; 32] = [0; 32];\n\n        if (!self.is_partial_hash) {\n            // this is a compile time conditional\n            // Hash the data using SHA256\n            data_hash = sha256_var(self.data.storage(), self.data.len() as u64);\n        } else {\n            // Compute the full SHA256 hash with the given partial hash\n            data_hash = partial_sha256_var_end(\n                self.partial_hash,\n                self.data.storage(),\n                self.data.len() as u64,\n                self.full_data_length as u64,\n            );\n        }\n\n        // Verify RSA signature\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(false, self.pubkey_modulus_limbs, self.redc_params_limbs);\n\n        let signature = RuntimeBigNum { params, limbs: self.signature_limbs };\n\n        assert(verify_sha256_pkcs1v15(data_hash, signature, 65537));\n    }\n\n    /**\n    * @brief Get a string claim from the JWT payload\n    *\n    * @param KEY_LENGTH: The length of the claim key\n    * @param MAX_VALUE_LENGTH: The maximum length of the claim value\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        self.get_claim::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key, true)\n    }\n\n    /**\n    * @brief Assert a string claim in the JWT payload.\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: BoundedVec<u8, MAX_VALUE_LENGTH>,\n    ) {\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> =\n            self.get_claim_string::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a number (u64) claim from the JWT payload\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_number<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> u64 {\n        let claim = self.get_claim::<KEY_LENGTH, 20>(claim_key, false);\n        str_to_u64(claim.storage())\n    }\n\n    /**\n    * @brief Assert a number (u64) claim in the JWT payload.\n    *        Refer to `get_claim_number` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_number<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: u64,\n    ) {\n        let value = self.get_claim_number::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a boolean claim from the JWT payload\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_bool<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> bool {\n        let value = self.get_claim::<KEY_LENGTH, 5>(claim_key, false);\n        let mut is_true = true;\n        for i in 0..4 {\n            is_true = is_true & (value.storage()[i] == \"true\".as_bytes()[i]);\n        }\n        let is_false = value.storage() == \"false\".as_bytes();\n\n        assert(is_true | is_false, \"incorrect value for claim\");\n        is_true\n    }\n\n    /**\n    * @brief Assert a boolean claim in the JWT payload.\n    *        Refer to `get_claim_bool` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_bool<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: bool,\n    ) {\n        let value = self.get_claim_bool::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Internal function to get claim bytes from the JWT payload\n    **/\n    fn get_claim<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        //Safety: extract the value in unconstrained mode, and verify later\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> = unsafe {\n            self.extract_claim_unconstrained::<KEY_LENGTH, MAX_VALUE_LENGTH>(\n                claim_key,\n                is_value_quoted,\n            )\n        };\n\n        // constrain the extracted value is present in the payload using string_search lib\n        // haystack is the base64 decoded payload;\n        let haystack = self.prepare_haystack();\n\n        // needle is the key with quotes around it - searching for just the key string might return false positives from elsewhere\n        // Note: key length is known at compile time as this lib doesn't support runtime keys\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = claim_key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle: SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // assert value after quoted key is a colon\n        let colon_index = position + KEY_LENGTH + 2; // +2 for the quotes around the key\n        assert(haystack.body[colon_index] == 58); // :\n\n        // assert the value is correct - string have quotes around them, numbers and booleans don't\n        let mut value_start_index = colon_index + 1; // Value starts after the colon\n        let mut index_after_value = value_start_index + value.len(); // Index after the value, quoted or otherwise\n\n        if (is_value_quoted) {\n            // adjust start index for the quotes around the value\n            value_start_index = value_start_index + 1; // Adjust for the quote before the value\n            index_after_value = index_after_value + 2; // Adjust for the quotes around the value\n\n            // assert the char before and after the value is a quote\n            assert(haystack.body[value_start_index - 1] == 34); // \"\n            assert(haystack.body[index_after_value - 1] == 34); // \"\n        }\n\n        // assert the value is correct\n        for i in 0..MAX_VALUE_LENGTH {\n            if (i < value.len()) {\n                assert(haystack.body[value_start_index + i] == value.storage()[i]);\n            }\n        }\n\n        // assert the char after the value is a comma or a closing brace (last claim in the payload)\n        let char_after_value = haystack.body[index_after_value];\n        assert((char_after_value == 44) | (char_after_value == 125)); // , or }\n\n        value\n    }\n\n    /**\n    * @brief Internal function to prepare the haystack for string search (base64 decoded payload with offset applied)\n    **/\n    fn prepare_haystack(\n        self,\n    ) -> StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> {\n        // We need to decode the payload from the payload_b64_offset; i.e. data.slice(0, base64_decode_offset)\n        let mut data_to_b64_decode: [u8; MAX_DATA_LENGTH] = [0; MAX_DATA_LENGTH];\n\n        // Conditional inside the for loop blows up the constraint size\n        // So we fill the full MAX_DATA_LENGTH (rotate on overflow) and prepare a BoundedVec with the correct length later\n        for i in 0..MAX_DATA_LENGTH {\n            data_to_b64_decode[i] =\n                self.data.storage()[(i + self.base64_decode_offset) % self.data.len()];\n        }\n\n        let data_to_decode_bv: BoundedVec<u8, MAX_DATA_LENGTH> = BoundedVec::from_parts(\n            data_to_b64_decode,\n            self.data.len() - self.base64_decode_offset,\n        );\n\n        // Decode the payload\n        let payload: BoundedVec<u8, ((MAX_DATA_LENGTH / 4) * 3)> =\n            BASE64_URL_DECODER::decode_var(data_to_decode_bv); // b64 decoded length is ceil(MAX_DATA_LENGTH / 3) * 4\n\n        // Create the haystack\n        let haystack: StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> =\n            StringBody::new(payload.storage(), payload.len());\n\n        haystack\n    }\n\n    /**\n    * @brief Unconstrained function to extract claim bytes from the JWT payload\n    **/\n    pub unconstrained fn extract_claim_unconstrained<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        let haystack = self.prepare_haystack();\n\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle: SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // Get the value after the key\n        let mut value_start_idx = position + key.len() + 3; // +3 for the quote around the key and the colon\n        if (is_value_quoted) {\n            value_start_idx += 1; // +1 for the quote before the value\n        }\n\n        let mut value: BoundedVec<u8, MAX_VALUE_LENGTH> = BoundedVec::new();\n\n        for i in 0..MAX_VALUE_LENGTH {\n            let val = haystack.body[value_start_idx + i];\n            if ((val == 34) | (val == 44) | (val == 125)) {\n                break;\n            }\n            value.push(haystack.body[value_start_idx + i]);\n        }\n\n        value\n    }\n}\n\n#[test]\nfn test_verify() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_verify_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_get_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_get_claim_string_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_assert_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let value: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    jwt.assert_claim_string(\"email\".as_bytes(), value);\n}\n\n#[test]\nfn test_get_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let iat: u64 = jwt.get_claim_number(\"iat\".as_bytes());\n    let expected_iat: u64 = 1737642217;\n    assert(iat == expected_iat);\n}\n\n#[test]\nfn test_assert_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let expected_iat: u64 = 1737642217;\n    jwt.assert_claim_number(\"iat\".as_bytes(), expected_iat);\n}\n\n#[test]\nfn test_get_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email_verified: bool = jwt.get_claim_bool(\"email_verified\".as_bytes());\n    assert(email_verified);\n}\n\n#[test]\nfn test_assert_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n}\n\n#[test]\nfn test_get_last_claim() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let exp: u64 = jwt.get_claim_number(\"exp\".as_bytes()); // exp is the last claim in the test payload\n    let expected_exp: u64 = 1799999999;\n    assert(exp == expected_exp);\n}\n","path":"/Users/unomasanori/nargo/github.com/saleel/noir-jwt/v0.4.4/src/lib.nr"},"68":{"source":"// Copied form https://raw.githubusercontent.com/zkemail/zkemail.nr/refs/heads/main/lib/src/partial_hash.nr\n// Use dependency one zkemail.nr is updated to bignum 0.6.0\n\nuse std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L23\n// Convert 64-byte array to array of 16 u32s\npub fn msg_u8_to_u32(msg: [u8; BLOCK_SIZE]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L38\nunconstrained fn build_msg_block_iter<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> ([u8; BLOCK_SIZE], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L59\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32,\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE: u32 = 64;\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L86-L116\n/**\n * Partially computes a SHA256 hash of a message but does not finalize\n * @notice can be used for post-partial hashing where client proves part of hash and relies on server to finish\n * \n *\n * @param N: the length of the message to hash.\n *  --- WARNING: N must be divisible by BLOCK_SIZE such that N % BLOCK_SIZE == 0 \n *      otherwise the remaining bytes will not be inputted when computing the initial hash\n * @param msg: the preimage to begin hashing\n * @return the intermediate hash state\n */\npub fn partial_sha256_var_start<let N: u32>(msg: [u8; N]) -> [u32; 8] {\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block_iter(msg, N, msg_start) };\n        if msg_start < N {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, N, msg_block, msg_start);\n            if msg_start < N {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < N {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < N) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    h\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block_iter(msg, N, msg_start) };\n        if msg_start < N {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, N, msg_block, msg_start);\n            if msg_start < N {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < N {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < N) & (msg_byte_ptr == BLOCK_SIZE) & (msg_start < message_size) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    h\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L85\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the remaining preimage\n * @param real_message_size -= the total size of the preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u64,\n    real_message_size: u64,\n) -> [u8; 32] {\n    let message_size = message_size as u32; // noir stdlib uses u64\n    let real_message_size = real_message_size as u32; // noir stdlib uses u64\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block_iter(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block_iter(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !is_unconstrained() {\n        for i in 0..64 {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..64 {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, real_message_size) };\n\n    if !is_unconstrained() {\n        for i in 0..56 {\n            if i < msg_byte_ptr {\n                assert_eq(msg_block[i], last_block[i]);\n            } else {\n                assert_eq(msg_block[i], zero);\n            }\n        }\n\n        let len = 8 * real_message_size;\n        let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n        for i in 56..64 {\n            assert_eq(msg_block[i], len_bytes[i - 56]);\n        }\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; BLOCK_SIZE],\n    mut msg_byte_ptr: u32,\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: [u8; BLOCK_SIZE],\n    mut msg_byte_ptr: u32,\n    message_size: u32,\n) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n","path":"/Users/unomasanori/nargo/github.com/saleel/noir-jwt/v0.4.4/src/partial_hash.nr"},"70":{"source":"unconstrained fn __boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let mut r: [Field; Range] = [0; Range];\n    for i in limit..Range {\n        r[i] = 1;\n    }\n    r\n}\n\n/**\n * @brief Return a size-Range array of values that describe whether an index `i` is in the range `0<=i<limit`\n * @details When evaluating variable-length loops of size `limit`, it is neccessary to iterate over a maximum bound defined at compile-time\n *          Any constraints or evaluations that occur where `i >= limit` must be discarded.\n *          This is most efficiently performed by using predicate `Field` values, where `predicate[i] = 0` if `i < limit`, otherwise `predicate[i] = 1`.\n *          This method efficiently generates such predicate values more efficiently than querying whether `i <= limit` at every iteration.\n *          Gate cost is 3 * Range\n **/\npub fn boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let r = unsafe {\n        //@safety r contains claims about whether `r[i] >= limit`. the rest of this function checks this claim is correct\n        __boundary_check(limit)\n    };\n\n    let mut transition_index = 0;\n    // **\n    // We have an array of Field elements `r` such that:\n    // if i < limit, `r = 0`\n    // if i >= limit, `r = 1`\n    // We validate the predicate list `r` is correct by checking:\n    // 1. every r[i] element is 0 or 1\n    // 2. if r[i] = 1, r[i+1] must also be 1\n    // 3. if r[i] = 0 and r[i+1] = 1, then i == limit\n    // we check point 3 by tracking a `transition_index` variable, where\n    // transition_index += (1 - r[i]) * (r[i+1]) * i\n    // i.e. if r[i] == 0 and r[i+1] == 1, transition_index += i\n    //      else transition_index += 0\n    // NOTE: total constraint cost is 3 gates per iteration\n    // **\n    if Range > 0 {\n        for i in 0..Range - 1 {\n            assert_eq(r[i] * r[i], r[i]);\n            assert_eq(r[i] * r[i + 1], r[i]);\n            let idx = (r[i + 1] * (1 - r[i])) * (i as Field + 1);\n            transition_index = transition_index + idx;\n            std::as_witness(transition_index);\n        }\n        assert_eq(r[Range - 1] * r[Range - 1], r[Range - 1]);\n        transition_index = transition_index + (1 - r[Range - 1]) * limit as Field;\n        assert(transition_index == limit as Field);\n        r\n    } else {\n        [0; Range]\n    }\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir_base64/v0.4.0/src/boundary_check.nr"},"71":{"source":"use super::defaults::{\n    BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK, INVALID_DECODE_VALUE,\n};\n\npub use crate::boundary_check::boundary_check;\nuse crate::tables::{\n    BASE64_DECODE_BE_TABLE, BASE64_DECODE_BE_URL_TABLE, BASE64_DECODE_BE_URL_VAR_TABLE,\n    BASE64_DECODE_BE_VAR_TABLE,\n};\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64DecodeBE {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 0>(input)\n    }\n}\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64DecodeBENoPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 0>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64DecodeBEUrlSafe {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 1>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64DecodeBEUrlSafeWithPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Return a human-readable error if the input is invalid Base64\n * @details We constrain the decoding to be correct by using a lookup table to decode Base64.\n *          Validation is performed by batch-checking that no lookups returned an error state.\n *          This produces unhelpful error messages so we put this sanitised check in an unconstrained fn\n **/\nunconstrained fn __validate_decoded(decoded: Field, input_byte: u8, offset: u32) {\n    assert(\n        decoded != INVALID_DECODE_VALUE,\n        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n    );\n}\n\n/**\n * @brief Given a variable-sized number of Base64 encoded characters, return a *claim* about how many are padding chars\n * @note The returned value is only a claim and must be validated\n **/\nunconstrained fn __get_num_padding_chars_var<let InputElements: u32>(\n    input: BoundedVec<u8, InputElements>,\n) -> (bool, bool) {\n    let len = input.len();\n    let r1 = if len > 1 {\n        input.get(len - 2) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    let r2 = if len > 0 {\n        input.get(len - 1) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    (r1, r2)\n}\n\n/**\n * @brief Take an array of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\nfn decode<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; OutputBytes] {\n    let rem = OutputBytes % 3;\n    // Calculate the number of padding characters and the length of the input without padding\n    let num_padding_chars = if rem == 1 {\n        2\n    } else if rem == 2 {\n        1\n    } else {\n        0\n    };\n\n    // Assert that the output length & input length are correct\n    // Every 3 output chars will be encoded as 4 base64 input chars\n    let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n    if Pad != 0 {\n        assert(\n            encoded_length == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n        );\n        // enforce Base64 padding is valid\n        if num_padding_chars == 2 {\n            let offset = InputElements - 1;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n            let offset = InputElements - 2;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        } else if num_padding_chars == 1 {\n            let offset = InputElements - 1;\n            assert(\n                input[InputElements - 1] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        }\n    } else {\n        let expected = encoded_length - num_padding_chars;\n        assert(\n            encoded_length - num_padding_chars == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n        );\n    }\n\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n    let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    // validity_check = accumulator value that we add every output from BASE64_DECODE_BE_TABLE into.\n    // Invalid error states will return a lookup value of -2^32 , which will cause `validity_check` to fail a 32-bit range check.\n    // This batch-validation technique is more efficient than asserting every returned token is valid.\n    let mut validity_check: Field = 0;\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_TABLE[input_byte]\n                } else {\n                    BASE64_DECODE_BE_TABLE[input_byte]\n                };\n                validity_check += decoded;\n                slice += decoded as Field;\n                unsafe {\n                    //@safety get a sensible error message out if the decoding is invalid.\n                    // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                    // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                    // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                    // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        // process the final chunk, which may contain padding\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_elements_in_final_chunk = if Pad != 0 {\n            InputElements - base64_offset - num_padding_chars\n        } else {\n            InputElements - base64_offset\n        };\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_TABLE[input_byte]\n            } else {\n                BASE64_DECODE_BE_TABLE[input_byte]\n            };\n            validity_check += decoded;\n            slice += decoded as Field;\n            unsafe {\n                //@safety get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                __validate_decoded(decoded, input_byte, offset);\n            }\n        }\n\n        // If any lookups returned an error state, this 32-bit range check will fail.\n        validity_check.assert_max_bit_size::<32>();\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Take a variable-length vector of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\npub fn decode_var<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: BoundedVec<u8, InputElements>,\n) -> BoundedVec<u8, OutputBytes> {\n    // We don't know how many padding bytes the input string contains - we use an unconstrained fn to return a *claim* that we will later validate\n    let (has_first_padding_byte_claim, has_second_padding_byte_claim) = if (Pad == 1) {\n        unsafe {\n            //@safety get claims about whether the bytes input[input.len() - 2] and input[input.len() - 1] are padding chars\n            // we validate this later on by requiring these characters equal BASE64_PADDING_CHAR by looking up BASE64_DECODE_BE_VAR_TABLE\n            crate::decoder::__get_num_padding_chars_var::<InputElements>(input)\n        }\n    } else {\n        (false, false)\n    };\n\n    // num_padding_chars is a claim that depends on has_first_padding_byte_claim and has_second_padding_byte_claim being correct\n    let num_padding_chars: u32 = if Pad == 1 {\n        has_first_padding_byte_claim as u32 + has_second_padding_byte_claim as u32\n    } else {\n        0\n    };\n\n    let input_length = input.len();\n    let input = input.storage();\n\n    // boundary_flags = array of Field elements.\n    // if `i < input_length, boundary_flags[i] = 0`\n    // if `i >= input_length, boundary_flags[i+1] = 1`\n    // used as cheap(ish) predicates when iterating over bounded vector elements\n    let boundary_flags: [Field; InputElements] = boundary_check(input_length);\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n\n    let max_num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    let mut validity_check: Field = 0;\n    // if statement should be known at compile time\n    if max_num_chunks > 0 {\n        let final_chunk: u32 = max_num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n\n                let mut decode_index: Field = 0;\n                if Pad == 1 {\n                    let mut might_be_second_padding_char = 0;\n                    let mut might_be_first_padding_char = 0;\n                    // These if statements should not cost extra gates as the condition is known at compile time\n                    if (offset + 2 < InputElements) {\n                        might_be_first_padding_char = (1 - boundary_flags[offset])\n                            * (1 - boundary_flags[offset + 1])\n                            * boundary_flags[offset + 2];\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else if (offset + 1 < InputElements) {\n                        // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                        might_be_first_padding_char =\n                            (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else // last character\n                    {\n                        might_be_first_padding_char = 0;\n                        might_be_second_padding_char = (1 - boundary_flags[offset]);\n                    }\n\n                    // Cases where we need to require a padding character is present:\n                    // Case 1: we are at byte position `input.len() - 2` and `has_first_padding_byte_claim = true`\n                    // Case 2: we are at byte position `input.len() - 1` and `has_second_padding_byte_claim = true`\n                    let require_padding = might_be_first_padding_char\n                        * has_first_padding_byte_claim as Field\n                        + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n\n                    // The `decode_index` is used to map the input Base64 character into an output decoded character.\n                    // We know `input_byte` is in the range 0-255 , so we use a size 768 lookup to handle the following 3 cases:\n                    // Case 1 (index range 0-255): No special cases. We decode the Base64 ASCII char into an ASCII char\n                    // Case 2 (index range 256-511): We have exceeded the length of the input. The only valid input is 0, which decodes to 0 (all other byte values return an error state)\n                    // Case 3 (index range 512-767): A claim has been made that a padding byte is present, and we are at the appropriate byte location to check this.\n                    //                               The only valid input is BASE64_PADDING_CHAR, which decodes to 0. All other inputs return an error state\n                    decode_index =\n                        input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n                } else {\n                    decode_index = input_byte as Field + boundary_flags[offset] * 256;\n                }\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n                } else {\n                    BASE64_DECODE_BE_VAR_TABLE[decode_index]\n                };\n\n                validity_check += decoded;\n                slice += decoded;\n                unsafe {\n                    //@safety get a sensible error message out if the decoding is invalid.\n                    // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                    // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                    // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                    // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            // convert the decoded slice into bytes and populate result array\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n        // process the final chunk\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        // might include padding characters\n        let base64_elements_in_final_chunk = InputElements - base64_offset;\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n\n            let mut decode_index: Field = 0;\n            if Pad == 1 {\n                let mut might_be_second_padding_char = 0;\n                let mut might_be_first_padding_char = 0;\n                // These if statements should not cost extra gates as the condition is known at compile time\n                if (offset + 2 < InputElements) {\n                    might_be_first_padding_char = (1 - boundary_flags[offset])\n                        * (1 - boundary_flags[offset + 1])\n                        * boundary_flags[offset + 2];\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else if (offset + 1 < InputElements) {\n                    // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                    might_be_first_padding_char =\n                        (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else // last character\n                {\n                    might_be_first_padding_char = 0;\n                    might_be_second_padding_char = (1 - boundary_flags[offset]);\n                }\n\n                let require_padding = might_be_first_padding_char\n                    * has_first_padding_byte_claim as Field\n                    + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n                decode_index =\n                    input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n            } else {\n                decode_index = input_byte as Field + boundary_flags[offset] * 256;\n            }\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n            } else {\n                BASE64_DECODE_BE_VAR_TABLE[decode_index]\n            };\n            unsafe {\n                //@safety get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                __validate_decoded(decoded, input_byte, offset);\n            }\n            validity_check += decoded;\n            slice += decoded as Field;\n        }\n\n        validity_check.assert_max_bit_size::<32>();\n\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    if Pad == 1 {\n        assert(input_length % 4 == 0, \"base64 encoded strings must be a multiple of 4 bytes\");\n    }\n\n    assert_eq(\n        has_first_padding_byte_claim,\n        has_second_padding_byte_claim * has_first_padding_byte_claim,\n        \"if first byte contains padding so must the second\",\n    );\n    let output_length = ((input_length * 3) / 4) - num_padding_chars;\n    BoundedVec::from_parts_unchecked(result, output_length)\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = Base64DecodeBE::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = Base64DecodeBENoPad::decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = Base64DecodeBE::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafeWithPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let input: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result: [u8; 44] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = Base64DecodeBE::decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_empty() {\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBE::decode_var(input);\n    println(f\"result {result}\");\n    println(f\"expected {expected}\");\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 8> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 6> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    // fo\n    println(f\"result {result}, expected {expected}\");\n\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n\n    assert(result == expected);\n\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 61, offset 3\")]\nfn test_decode_var_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([47, 43, 65, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([255, 224]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var() {\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let input: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let input_no_pad: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n    // \"Hello, World!\"\n    let expected: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n\n    // all configurations should decode the same way\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    println(f\"result {result}, expected {expected}\");\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_multi_chunks() {\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir_base64/v0.4.0/src/decoder.nr"},"109":{"source":"use crate::constants::TWO_POW_120;\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n        (limbs[0] + limbs[1] * TWO_POW_120) as Field\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        (\n            limbs[0] as Field\n                + limbs[1] as Field * TWO_POW_120 as Field\n                + limbs[2] as Field * TWO_POW_120 as Field * TWO_POW_120 as Field\n        )\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(field: Field) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(field) };\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n\n        // validate that the last limb is less than the modulus\n        if N > 2 {\n            // validate that the result is less than the modulus\n            let mut grumpkin_modulus = [0; N];\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n            // validate that the limbs are in range\n            validate_in_range::<_, N, MOD_BITS>(result);\n        }\n        // validate the limbs sum up to the field value\n        let TWO_POW_120_FIELD = TWO_POW_120 as Field;\n        let field_val = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field + result[1] as Field * TWO_POW_120_FIELD\n        } else {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field\n                + result[1] as Field * TWO_POW_120_FIELD\n                + result[2] as Field * TWO_POW_120_FIELD * TWO_POW_120_FIELD\n        };\n        assert_eq(field_val, field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: u128 = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as u128 + (1 - need_more_bytes as u128));\n                limb += byte as u128 * need_more_bytes as u128;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, _, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [u128; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        // result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    predicate: bool,\n) -> [u128; N] {\n    let mut result: [u128; N] = lhs;\n    for i in 0..N {\n        // (lhs[i] - rhs[i]) * predicate + rhs[i]\n        // in case lhs < rhs, this will underflow so we have to do one extra multiplication to prevent it\n        result[i] = lhs[i] * predicate as u128 + rhs[i] * (1 - predicate as u128);\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_n *= TWO_POW_120 as Field;\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_n += params.modulus[N - i - 1] as Field;\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [u128; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [u128; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = (modulus[i] as Field - val[i] as Field);\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += (borrow_flags[0] as Field * TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] +=\n            (borrow_flags[i] as Field * TWO_POW_120 as Field - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= (borrow_flags[N - 2] as Field);\n    validate_in_range::<_, _, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, _, MOD_BITS>(result);\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] as Field - rhs[0] as Field + addend[0] - result[0] as Field - 1\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] as Field - rhs[i] as Field + addend[i]\n            - result[i] as Field\n            - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] as Field - rhs[N - 1] as Field + addend[N - 1]\n        - result[N - 1] as Field\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb = modulus[0] + (borrow_flags[0] as u128 * TWO_POW_120) - val[0] - result[0];\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] + (borrow_flags[i] as u128 * TWO_POW_120)\n                - val[i]\n                - result[i]\n                - borrow_flags[i - 1] as u128;\n            assert(result_limb == 0);\n        }\n        let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as u128;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            // __add_u128(params, lhs, rhs)\n            __add(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [u128; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] as Field + rhs[0] as Field\n            - subtrahend[0] as Field\n            - result[0] as Field\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] as Field + rhs[i] as Field\n                - subtrahend[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120 as Field;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = lhs[N - 1] as Field + rhs[N - 1] as Field\n            - subtrahend[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params, lhs, rhs) };\n\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [u128; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n            + addend[0] as Field\n            + lhs[0] as Field\n            - rhs[0] as Field\n            - result[0] as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n                + addend[i] as Field\n                + lhs[i] as Field\n                - rhs[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = addend[N - 1] as Field + lhs[N - 1] as Field\n            - rhs[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/constrained_ops.nr"},"110":{"source":"use crate::utils::split_bits;\n\nuse crate::constants::{TWO_POW_120, TWO_POW_126, TWO_POW_246};\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\n\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n    assert(remainder == [0; N]);\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] as Field * params.modulus[j] as Field;\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{246 - 120} = 2^{126}\n    let downshift: Field = 1 / (TWO_POW_120 as Field);\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits =\n        (mulout_p[0] - mulout_n[0] + (borrow_flags[0] as Field * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n    flags: [bool; M],\n) -> ([u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [u128; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [u128; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + (modulus2[j] as Field - x[i][j] as Field) as u128;\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [u128; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] as Field * rhs[k][j] as Field);\n            }\n        }\n        mulout[i] += add[i] as Field;\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout: [Field; (N * 2)] = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, k, params.modulus);\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([u128; N], [u128; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [u128; N] = params.double_modulus;\n\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i] as Field;\n                    t0[k][i] += double_modulus[i] as Field;\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i] as Field;\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i] as Field;\n                    t1[k][i] += double_modulus[i] as Field;\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i] as Field;\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i] as Field;\n                t4[i] += double_modulus[i] as Field;\n            } else {\n                t4[i] += linear_terms[j][i] as Field;\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term =\n                        t0[k][i] * t1[k][j] - quotient[i] as Field * params.modulus[j] as Field;\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j] as Field;\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] as Field * params.modulus[j] as Field;\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] as Field * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/expressions.nr"},"112":{"source":"/**\n* @brief construct a BigNum instance out of an array of bytes in BIG ENDIAN format\n* @description: each 120-bit limb represents 15 bytes, we require that the size of the byte array\n*               is precisely large enough to cover MOD_BITS\n* @param x: input byte array\n**/\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    x: [u8; NBytes],\n) -> [u128; N] {\n    let num_bits = NBytes * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result: [u128; N] = [0; N];\n\n    let excess_bytes = N * 15 - NBytes;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: u128 = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as u128;\n        k += 1;\n    }\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: u128 = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as u128;\n            k += 1;\n        }\n        result[N - i - 1] = limb;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - (NBytes * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    val: [u128; N],\n) -> [u8; NBytes] {\n    let nbytes = (MOD_BITS / 8) + (MOD_BITS % 8 != 0) as u32;\n    assert(nbytes <= NBytes);\n\n    let mut result: [u8; NBytes] = [0; NBytes];\n    for i in 0..N - 1 {\n        let limb_bytes: [u8; 15] = (val[i] as Field).to_le_bytes();\n        for j in 0..15 {\n            result[i * 15 + j] = limb_bytes[j];\n        }\n    }\n    let last_limb_bytes: [u8; 15] = (val[N - 1] as Field).to_le_bytes();\n    let num_last_bytes = (NBytes - (N - 1) * 15);\n    for i in 0..num_last_bytes {\n        result[(N - 1) * 15 + i] = last_limb_bytes[i];\n    }\n    result\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/serialization.nr"},"113":{"source":"use crate::constants::{TWO_POW_119, TWO_POW_120, TWO_POW_60};\nuse crate::fns::unconstrained_ops::{__add, __gte, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\nuse crate::utils::msb::get_msb64;\nuse crate::utils::split_bits::__normalize_limbs;\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [u128; N] {\n    let mut x = field;\n    let x_first_u128 = (x as u128);\n    let first: u128 = x_first_u128 % TWO_POW_120;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_120 as Field);\n    let x_second_u128 = (x as u128);\n    let second = x_second_u128 % TWO_POW_120;\n    x = (x - (second as Field)) / (TWO_POW_120 as Field);\n    let x_third_u128 = (x as u128);\n    let third = x_third_u128 % TWO_POW_120;\n    let mut result: [u128; N] = [0; N];\n    if N > 2 {\n        result[0] = first;\n        result[1] = second;\n        result[2] = third;\n    }\n    if N == 2 {\n        result[0] = first;\n        result[1] = second;\n    }\n    if N == 1 {\n        result[0] = first;\n    }\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [u128; N] = params.modulus;\n    flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        flags[i] = modulus[i] < val[i] + flags[i - 1] as u128;\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N]) {\n    let mut a = lhs;\n    let mut b = rhs;\n    let underflow = !__gte(lhs, rhs);\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 1;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = a[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = b[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = (borrow * TWO_POW_120 + add_term - sub_term);\n\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry as bool;\n            borrow_flags[i] = borrow as bool;\n        }\n    }\n\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> ([u128; N], [bool; N]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let sub_term = val[i] + borrow_in;\n        let borrow = (sub_term > params.modulus[i]) as u128;\n        result[i] = borrow * TWO_POW_120 + params.modulus[i] - sub_term;\n\n        borrow_in = borrow;\n        borrow_flags[i] = borrow as bool;\n    }\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N], bool) {\n    let add_res = __helper_add(lhs, rhs);\n    let overflow = __gte(add_res, params.modulus);\n\n    let mut subtrahend: [u128; N] = [0; N];\n    let mut result: [u128; N] = [0; N];\n\n    if overflow {\n        subtrahend = params.modulus;\n    }\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term = lhs[i] + rhs[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry as u128;\n\n        let sub_term = subtrahend[i] + borrow_in;\n\n        let mut borrow: u128 = (sub_term > add_term) as u128;\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow as u128;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry as bool;\n            borrow_flags[i] = borrow as bool;\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N], bool) {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let underflow = !__gte(lhs, rhs);\n    let addend: [u128; N] = if underflow { params.modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = rhs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = borrow as u128 * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry as bool;\n            borrow_flags[i] = borrow as bool;\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout_field[i + j] += x[i] as Field * redc_param[j] as Field;\n        }\n    }\n\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field, 3 * N - 1);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n    // the quotient has bunch of zero limbs now, so we can just take the first N limbs as a result\n    let mut smaller_quotient = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = __into_field_array(quotient);\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] +=\n                partial_quotient_full[i] * modulus[j] as Field;\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    let long_quotient_mul_modulus_normalized: [u128; 2 * N] =\n        __normalize_limbs(quotient_mul_modulus_normalized, 2 * N);\n    let mut quotient_mul_modulus_normalized: [u128; N] = [0; N];\n    for i in 0..N {\n        quotient_mul_modulus_normalized[i] = long_quotient_mul_modulus_normalized[i];\n    }\n\n    let mut long_remainder = __helper_sub(x, long_quotient_mul_modulus_normalized);\n    // ugly but have to remove a bunch of zeros from this\n    let mut remainder = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n    // barrett reduction is quirky so might need to remove a few modulus from the remainder\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n\n    (smaller_quotient, remainder)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let mut target = __helper_sub(params.modulus, one);\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target = __shr1(target);\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [u128; N],\n    p_minus_one_over_two: [u128; N],\n) -> (bool, [u128; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [u128; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = exped == neg_one;\n    let mut result: (bool, [u128; N]) = (found, target);\n    if (!found) {\n        let _target: [u128; N] = __add(params, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [u128; N] {\n    let mut target: [u128; N] = __one();\n    let p_minus_one_over_two = __shr1(__helper_sub(params.modulus, __one()));\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [u128; N],\n    i: u32,\n) -> u32 {\n    let one: [u128; N] = __one();\n    let is_one = t2m == one;\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let mut add_term = (val[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u8;\n    let remainder_shift = (120 - limb_shift) as u8;\n    let mask: u128 = (((1 as u128) << limb_shift) - 1) << remainder_shift;\n    result[0] = (input[0 + num_shifted_limbs] >> limb_shift);\n    for i in 1..(N - num_shifted_limbs) {\n        let value = input[i + num_shifted_limbs];\n        result[i] = value >> limb_shift;\n        let remainder: u128 = (value << remainder_shift) & mask;\n        result[i - 1] = result[i - 1] + remainder;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u8;\n    let remainder_shift: u8 = 120 - limb_shift as u8;\n\n    // 83\n    // limb shift = 1\n    // inside shift = 19 bits to the left\n    // meaning we have 19 carry bits and 41 remainder bits\n    let mask: u128 = (1 as u128 << 120) - 1;\n    //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n    let value = input[0];\n\n    let mut remainder = (value >> remainder_shift);\n    result[num_shifted_limbs] = (value << limb_shift) & mask;\n\n    // shift 84. num shifted = 1\n    for i in 1..((N) - num_shifted_limbs) {\n        let value = input[i];\n        let upshift = ((value << limb_shift) + remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = (value >> remainder_shift);\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    for i in 0..N {\n        borrow = ((rhs[i] + borrow_in) > lhs[i]) as u128;\n        let sub = (borrow << 120) + lhs[i] as u128 - rhs[i] as u128 - borrow_in;\n        result[i] = sub;\n        borrow_in = borrow;\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value = input[N - 1];\n    input[N - 1] = value >> 1;\n\n    let mut remainder = (value & 1) << 119;\n\n    for i in 1..N {\n        let value = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) + remainder;\n        remainder = (value << 119) & TWO_POW_119;\n    }\n    input\n}\n\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count = 0;\n    for i in 0..N {\n        let v = val[((N) - 1 - i)];\n        let v_low = v as u64 % TWO_POW_60 as u64;\n        let v_high = ((v - v_low as u128) / TWO_POW_60) as u64;\n        if (v_high > 0) {\n            count = 60 * ((2 * N) - 1 - (i * 2)) + get_msb64(v_high);\n            break;\n        }\n        if (v_low > 0) {\n            count = 60 * ((2 * N) - 1 - (i * 2 + 1)) + get_msb64(v_low);\n            break;\n        }\n    }\n    count\n}\n\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index = bit % 120;\n    let limb: u128 = input[segment_index];\n    let value = (limb >> uint_index as u8) & 1;\n    value == 1\n}\n\npub(crate) fn __into_field_array<let N: u32>(input: [u128; N]) -> [Field; N] {\n    let mut result: [Field; N] = [0; N];\n    for i in 0..N {\n        result[i] = input[i] as Field;\n    }\n    result\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/unconstrained_helpers.nr"},"114":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_sub, __increment,\n    __multiplicative_generator, __primitive_root_log_size, __shl, __shr,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse super::unconstrained_helpers::__shr1;\n\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> [u128; N] {\n    let f: [u128; N] = limbs;\n    __helper_sub(params.modulus, f)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    // check if the result is greater than the modulus\n    if __gte(result, params.modulus) {\n        __helper_sub(result, params.modulus)\n    } else {\n        result\n    }\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += (lhs[i] as Field * rhs[j] as Field);\n        }\n    }\n    let to_reduce: [u128; (N * 2)] = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    // ([0; N], [0; N])\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n\n    let b = divisor;\n    let numerator_msb = __get_msb(numerator);\n    let divisor_msb = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = __get_msb(remainder) - __get_msb(divisor);\n        let mut accumulator: [u128; N] = __one();\n        let mut divisor = __shl(divisor, bit_difference);\n        accumulator = __shl(accumulator, bit_difference);\n\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor); // >>= 1;\n            accumulator = __shr1(accumulator); //  >>= 1;\n        }\n\n        (quotient, remainder)\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one = __one();\n    let exp = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let x = exponent;\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [u128; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if __get_bit(x, num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]; M] = std::mem::zeroed();\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]],\n) -> [[u128; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one = __one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let Q = __shr(\n        __helper_sub(params.modulus, one),\n        primitive_root_log_size - 1,\n    );\n    let two = __helper_add(one, one);\n    let Q_minus_one_over_two = __shr(__helper_sub(Q, two), 2);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [u128; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __gte<let N: u32, let MOD_BITS: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let mut result = false;\n    let mut early_exit = false;\n    for i in 0..(N) {\n        let idx = (N) - 1 - i;\n        if (rhs[idx] == lhs[idx]) {\n            continue;\n        }\n\n        result = rhs[idx] < lhs[idx];\n        early_exit = true;\n        break;\n    }\n    if early_exit {\n        result\n    } else {\n        lhs[0] == rhs[0]\n    }\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/unconstrained_ops.nr"},"116":{"source":"pub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [u128; N],\n\n    // @brief double_modulus: used when performing negations and subtractions\n    // @note we borrow 1 from the last limb. This is for easing up the operations that might underflow\n    pub double_modulus: [u128; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [u128; N],\n}\n\n// To be implemented by the user for any BigNum they define, or within the predefined BigNums in the `fields/` dir.\npub trait BigNumParamsGetter<let N: u32, let MOD_BITS: u32> {\n    fn get_params() -> BigNumParams<N, MOD_BITS>;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [u128; N],\n        redc_param: [u128; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [u128; N]) -> [u128; N] {\n    let TWO_POW_120: u128 = 0x1000000000000000000000000000000;\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (modulus[i] + modulus[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/params.nr"},"117":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, is_zero, mul, neg,\n        sub, udiv, udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::ops::Neg;\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [u128; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {\n\n    pub fn zero(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [u128; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::zero(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [u128]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [u128; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    pub fn from_be_bytes<let NBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        x: [u8; NBytes],\n    ) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x), params }\n    }\n\n    pub fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    pub fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    pub fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    pub fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    pub fn get_limbs(self) -> [u128; N] {\n        self.limbs\n    }\n\n    pub fn get_limb(self, idx: u32) -> u128 {\n        self.limbs[idx]\n    }\n\n    pub fn set_limb(&mut self, idx: u32, value: u128) {\n        self.limbs[idx] = value;\n    }\n\n    pub unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    pub unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs =\n            unsafe { __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn| Self::get_limbs(bn))) };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // Note: can't return a slice from this unconstrained to a constrained function.\n    pub unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs = {\n            let inv_slice =\n                __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn| Self::get_limbs(bn)));\n            inv_slice.as_array()\n        };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let (q_limbs, r_limbs) = unsafe {\n            __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n                params,\n                map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                lhs_flags,\n                map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                rhs_flags,\n                map(linear_terms, |bn| Self::get_limbs(bn)),\n                linear_flags,\n            )\n        };\n        (Self { limbs: q_limbs, params }, Self { limbs: r_limbs, params })\n    }\n\n    pub fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| Self::get_limbs(bn)),\n            linear_flags,\n        )\n    }\n\n    pub fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    pub fn validate_in_range(self) {\n        validate_in_range::<_, _, MOD_BITS>(self.limbs);\n    }\n\n    pub fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    pub fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    pub fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let params = lhs.params;\n        assert(params == rhs.params);\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate), params }\n    }\n\n    pub fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/runtime_bignum.nr"},"124":{"source":"use crate::constants::TWO_POW_120;\n\nunconstrained fn split_120_bits(mut x: Field) -> (u128, u128) {\n    // Here we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low = (x as u128) % TWO_POW_120;\n    let high = ((x - low as Field) / TWO_POW_120 as Field) as u128;\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [u128; N] {\n    let mut normalized: [u128; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n        normalized[i] = lo as u128;\n        next = input[i + 1] + hi as Field;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n        normalized[range - 1] = lo as u128;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/utils/split_bits.nr"},"135":{"source":"use dep::bignum::RuntimeBigNum;\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme.\n * @note The `exponent` can be either 65537 or 3 (i.e. the most common values in use for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    assert((exponent == 3) | (exponent == 65537), \"Exponent must be 65537 or 3\");\n    let mut exponentiated = sig * sig; // sig^2\n    if exponent == 65537 {\n        // e = 65537 = 1 0000 0000 0000 0001\n        exponentiated = exponentiated * exponentiated; // sig^4\n        exponentiated = exponentiated * exponentiated; // sig^8\n        exponentiated = exponentiated * exponentiated; // sig^16\n        exponentiated = exponentiated * exponentiated; // sig^32\n        exponentiated = exponentiated * exponentiated; // sig^64\n        exponentiated = exponentiated * exponentiated; // sig^128\n        exponentiated = exponentiated * exponentiated; // sig^256\n        exponentiated = exponentiated * exponentiated; // sig^512\n        exponentiated = exponentiated * exponentiated; // sig^1024\n        exponentiated = exponentiated * exponentiated; // sig^2048\n        exponentiated = exponentiated * exponentiated; // sig^4096\n        exponentiated = exponentiated * exponentiated; // sig^8192\n        exponentiated = exponentiated * exponentiated; // sig^16384\n        exponentiated = exponentiated * exponentiated; // sig^32768\n        exponentiated = exponentiated * exponentiated; // sig^65536\n    }\n    // otherwise, e = 3 = 11\n    exponentiated = exponentiated * sig; // either sig^2 * sig = sig^3 or sig^65536 * sig = sig^65537\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\nmod tests {\n\n    use crate::types::RBN2048;\n    use super::verify_sha256_pkcs1v15;\n    use bignum::params::BigNumParams;\n    use bignum::RuntimeBigNum;\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_1024() {\n        // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170, 193,\n            96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n        ];\n\n        let params: BigNumParams<9, 1024> = BigNumParams::new(\n            false,\n            [\n                0xab238ad9cb37979a43aefbf10be8fb,\n                0x31347febe45fe8c2dac1dd30900704,\n                0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n                0x5eac6390f7873fe97ff9bb14a173ea,\n                0xbc41f700c91fd733a2c63177bbdbd4,\n                0x41442bd58769a3595b659a2ec9c6be,\n                0x4ddc91395f330382aa2e2d3fbe147,\n                0x3d008ff255a0bc71c7887f5728ba1,\n                0xb640c3a8f511c64e,\n            ],\n            [\n                0x5d53d2634c6a0918266043968ce263,\n                0x5dd4be3dce0323a492ee9340aec4db,\n                0xf82d0e2e5c8319f01a460c72c01854,\n                0x236e6fc6e62e8a1d522acda5fb3892,\n                0xdaf755619d66e580901aa224d03174,\n                0x8366291616480e7e1f202dbcedda87,\n                0x40ba1202537d1e94561ccc05265586,\n                0x69b993d857ba89ea5de9822aeb4b93,\n                0x167968c0000761a273,\n            ],\n        );\n\n        let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xc3850e84ea02da3f028ff422f4d6a9,\n                0x9761f0bd9021f76d45c60df0670a19,\n                0xc1ede421a43607ab623ed4d5a17fc8,\n                0x86197b4315206f4d53200b42555831,\n                0xe95783b69db28c26a83706f39d04cd,\n                0x18b178dc1a9ec76fb22b57e4dfa703,\n                0xdd0e19cd5a09ab48e7af4d0e3470e3,\n                0x10004dfab1cf91304e80e6baa4dfc7,\n                0x241c3fd77b90adef,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048() {\n        // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131, 166,\n            79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n                0xbfb937fc4d3cf02cc0af780f3cab44,\n                0xd20637ef7adcf5d238ee87bccc9bca,\n                0xb9db4f2663108e2f8b673f7612ae8b,\n                0x85f894ef669b36bfd3d86b0a28873,\n                0xdcc70e1884e38b8229cce3b884121d,\n                0x35488d1138e0b03e1676f7f5d8a5b3,\n                0xe1a97820e7dcbb4eab35c9b71bb273,\n                0x97d19eb3c63249ddbfcff915863f54,\n                0x3a78c7af6da0f6af0d67b1ca4b6065,\n                0xd7a3c433c020f624821e5e678c7d69,\n                0x52d5b53240feae82ffea3d2a3d9b09,\n                0xb8aad5e19e2163f68997c6fdd71906,\n                0x5db432d06e8b0bf59511100c7894e2,\n                0xadc0bbc4c54da10d1cc88438ea3127,\n                0xece1cf6a1501109cd2734d5893c8d9,\n                0x7196b90acdf06c31b1288064fd0c27,\n                0xc8,\n            ],\n            [\n                0x1b1deccf4dbde852c34a5d6908a0f,\n                0xbc9e5bdab22f023fbcca58692bccf5,\n                0x1f65439685623e45396ff55751c3bf,\n                0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n                0x5ca2e8e3048243c16c708a8030ab0d,\n                0x30079bfeb1fa51e5501581173ca19c,\n                0xff8d5f6bea485fdcc2716327f69ab4,\n                0x36b599d81589416b5b5f037986b999,\n                0x75612e34a4ff29f0a19a7823512f58,\n                0x288b6897929b54c3b26a5faa07c00f,\n                0x4b5675fa13ab7444f1f047d3eb1bbe,\n                0x6ba0ac610ef9f267ab30fe25bb1c84,\n                0xa386b48ee03168d5cea3ecb9dc901f,\n                0xacf1a01f7dba44e050c976142fb1f6,\n                0x97a63b5cb7efc60d3502946aec63cf,\n                0x12cc1d5cab10a1e9e2398d29b9e3ef,\n                0x4635cf25c66e76bba8034df46204fb,\n                0x146f,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xad29e07d16a278de49a371b9760a27,\n                0x86311920cc0e17a3c20cdff4c56dbb,\n                0x863556c6c5247dd83668dd825716ae,\n                0xc247c960945f4485b46c33b87425ca,\n                0x7326463c5c4cd5b08e21b938d9ed9a,\n                0x4f89fe0c82da08a0259eddb34d0da1,\n                0x43a74e76d4e1bd2666f1591889af0d,\n                0x240f7b80f0ff29f4253ee3019f832d,\n                0xc6edd131fbaaf725fd423dac52b362,\n                0x85f9732679242163e8afff44f6104d,\n                0xd3c3bbcb1757013fd6fb80f31dd9a6,\n                0x9008633f15df440e6df6d21ee585a2,\n                0x324df3425ed256e283be5b6b761741,\n                0xc60c1302929bd0e07caa4aeff4e8fd,\n                0x600d804ff13ba8d0e1bc9508714212,\n                0x50f7e75e5751d7edd61167027926be,\n                0x0db41d39442023e1420a8a84fe81d9,\n                0xab,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n        // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132, 239,\n            227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0xe40ee47801326543c8e84b85d567c1,\n                0x5b54ea87f0ce29de1995697b0696fd,\n                0x457078f8fdce68b437cac0970b2452,\n                0x473ec776fee3731b6ab06e35875ddc,\n                0x62dedd594e5f12c80c3ccb5791a6cd,\n                0xecb934b9d8272c5e3a418145345499,\n                0xd1af643b3d785470ed0c6cd633f706,\n                0xb58a57b9e96eccbdfc7c17f0333d4,\n                0x2ebd34b5039fc596504927c282c60d,\n                0x3a44928a74f25fc1043bb37ce4dfa8,\n                0x91448459f9617fac33a2816162ac9e,\n                0x70cb910d9f3e1a78864640ec6c8240,\n                0x9aed33f6b31f1c9de67248a98c180,\n                0x7f1416e032c79488c94b311e87bd9c,\n                0x7191b4ebb1b3fffa949fa48ed01e5,\n                0x350a75cbaeca6bfdd71ca83cdbcae9,\n                0xfb1d274fa207457c6814d42c09f9cf,\n                0xd4,\n            ],\n            [\n                0x803bf4d38110a7d37fdd05f590dee9,\n                0xa68d317c933f37cab5ab4e7c00a3b9,\n                0x476a05a536bf5f2aa1b8850146cba7,\n                0xca297ea8b5528d91d4836ff27c30ab,\n                0x75cf2eaab76eefa12bbd570f1aea9f,\n                0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n                0xd497db1f6ebe83decacaa647fabea6,\n                0x686b27ca330e25e7a7cf197f6433ef,\n                0xfde04d2225c8308b07580af0058a0f,\n                0xa29fb69777c0e916976243b2b09855,\n                0xf983592285852e7e1c2cb3ae968323,\n                0x673608017f9f5acf67a01b73728d70,\n                0xeeff82521c0bc432a05f4b7444fac0,\n                0x85a89c4d229f60aaa3aa7ac7dac1e2,\n                0xcfecff93bc9fbfe0d6dff6091f2db8,\n                0xf20f047dcb224b4447bd098c07f8c2,\n                0x554bb53cadeb3eaab911a189f90227,\n                0x133b,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa250eff812c63eaaeaa3f04641c05f,\n                0xecc09613cb8b289c1f37c8f92e6a05,\n                0x2c0a0510058360c07af65d46f594fd,\n                0x943d67513363d3de430c94a1dafe7c,\n                0x511ec8e9b10bc6c6ff0d6c232ccf92,\n                0x50ffd07b3c093b3f5fc027de847731,\n                0xc268e1489449943fdafdf89ff168c3,\n                0x0b8b7f9f49b492f78fda58d252f23a,\n                0x491c6c4ef836a6a8730b7bf81e865e,\n                0x8746c75fb079d014e419543f56d7f0,\n                0x65804c417d6168a8bc0025d255cebf,\n                0xf695e91b77890b8e3fd775fa56e627,\n                0x5e90001c0218550f4083ae28025a2f,\n                0x526bd4eff34f25f62a698f0470e0a6,\n                0x7f224306a7d9daf536b1559434c6c6,\n                0x88809f16fe1fcea3c87511d9319735,\n                0x7694685fee0bfab4a9196b92ec6f2e,\n                0xa7,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n    }\n\n    #[test]\n    fn smoke_test() {\n        // Output of `cargo run -- --msg \"hello world\"` in the `signature_gen` directory\n        // Create runtime params:\n        let modulus_limbs = [\n            0x65af46d235241cf0e8fbe8cff4abb7,\n            0xeead39ba3f377ddd5ccb2ef2085190,\n            0xe483f94c0a98e8b618d92fb926f596,\n            0x1fa8c1b2c62cca6db090cd74a29db2,\n            0xc38e22042fcb74585a7e535301f50f,\n            0xcbc4378e5212752743ae78a75a44a9,\n            0xf5acc41788d9a346a0f75630a8b2b6,\n            0xf7a741bb3ecf1aadd5a327f362abd8,\n            0x4d5f24e815db43a1b2cc2ba40f8715,\n            0xe501f1a01305cb198475a4bff0da2e,\n            0xd541b78cfbc2b314083c340840c82c,\n            0xa0ab069c26b2a0458f4c642bf72526,\n            0x2ccb676d8f22517116fee0d2340533,\n            0x7cf2a7cf772025c0a83747bbc18228,\n            0xf9475f17988a56f17b3bdf88dc72dc,\n            0x4ff228bee24415fae7a7c05771e830,\n            0x55acd96b485515c38906106cf0d189,\n            0xb9,\n        ];\n        let redc_limbs = [\n            0x172c8f156f020ad88d30fa3ba47f03,\n            0x1740a43a67cb9a7be1ac1422d77246,\n            0x2d967be1edf369834317e04856e591,\n            0x65d9fa0de5fdab598c04d9a515156a,\n            0xc6791a661ea7621db7e6c4ec48f466,\n            0xa4a1a7c06d3e8a0bcbc540c6af6788,\n            0xdcaffeb149f5bf646caa00d7355715,\n            0xb75471630a9d0fefb5cb61e66991a1,\n            0x97c041a0fc30fdff3d5ed16997da02,\n            0xbfbe7d217694b269e1ed37819c2f17,\n            0x1b44ffc3180531e2ab8bdf7848a3a9,\n            0x9f004af11132cb68bb55998ed7616a,\n            0x1b15dbbb96ce80f479724bbd768a0c,\n            0x59ba1419093ae6ed2592ffb3065867,\n            0xa35b69affa3bb3f4713f315e50b584,\n            0xa873210f83a6de0d8cbb816af3e37,\n            0xbe4fe7cf98da87ec87638030797e92,\n            0x1619,\n        ];\n\n        let signature_limbs = [\n            0x2f397c4611d4a4271453e1e50e1578,\n            0xe506a7f47c721a4943783e8ad459e6,\n            0x6cc4ae1d91cb381cba9673470999fb,\n            0x1e127364d07f94e58227f50fbf5687,\n            0xf64a2579c7189f882d68832d16faa4,\n            0x3b014b74c6c6f76f2f8af170fa0fe4,\n            0x7df41e68c86815a6fdc33968c66b67,\n            0x6a57ac06282527242fddb6ed08dbdc,\n            0xac40d37b819c4b6193f90a634e4fc7,\n            0x96606ed166a7f032d858cd40ac73a5,\n            0x8eb7d4351159a46733f92610d5c597,\n            0xc8e8e9faa9738e82dbe774a3f5cf07,\n            0x89ca84fd54ee3d5cca87c9f178375e,\n            0xdb7a1465fc76507ea498a351af70dd,\n            0x6ac6fe14f51c711f983125c776f712,\n            0x3254c17fef51bf4194a8a1674634e3,\n            0xee38c83c77c6e1ff7b70a5d9d1dd0f,\n            0x26,\n        ];\n\n        let hash: [u8; 32] = [\n            0xb9, 0x4d, 0x27, 0xb9, 0x93, 0x4d, 0x3e, 0x08, 0xa5, 0x2e, 0x52, 0xd7, 0xda, 0x7d,\n            0xab, 0xfa, 0xc4, 0x84, 0xef, 0xe3, 0x7a, 0x53, 0x80, 0xee, 0x90, 0x88, 0xf7, 0xac,\n            0xe2, 0xef, 0xcd, 0xe9,\n        ];\n\n        let has_multiplicative_inverse = false;\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(has_multiplicative_inverse, modulus_limbs, redc_limbs);\n\n        let signature: RBN2048 = RBN2048::from_array(params, signature_limbs);\n\n        assert(verify_sha256_pkcs1v15(hash, signature, 65537));\n    }\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir_rsa/v0.7.0/src/rsa.nr"},"141":{"source":"mod utils;\n\npub use utils::{conditional_select, DebugRandomEngine, lt_f};\nuse std::collections::bounded_vec::BoundedVec;\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\npub struct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    pub byte_length: u32,\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\npub struct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    pub byte_length: u32,\n}\n\npub type StringBody32 = StringBody<62, 2, 32>;\npub type StringBody64 = StringBody<93, 3, 64>;\npub type StringBody128 = StringBody<155, 5, 128>;\npub type StringBody256 = StringBody<279, 9, 256>;\npub type StringBody512 = StringBody<527, 17, 512>;\npub type StringBody1024 = StringBody<1054, 34, 1024>;\npub type StringBody2048 = StringBody<2077, 67, 2048>;\npub type StringBody4096 = StringBody<4123, 133, 4096>;\npub type StringBody8192 = StringBody<8215, 265, 8192>;\npub type StringBody16384 = StringBody<16399, 529, 16384>;\n\npub type SubString32 = SubString<62, 1, 32>;\npub type SubString64 = SubString<93, 2, 64>;\npub type SubString128 = SubString<155, 4, 128>;\npub type SubString256 = SubString<279, 8, 256>;\npub type SubString512 = SubString<527, 16, 512>;\npub type SubString1024 = SubString<1054, 33, 1024>;\n\npub trait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: Field,\n        body_chunk_offset: Field,\n        num_full_chunks: Field,\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: Field) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    pub fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes,\n            \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes,\n            \"SubString::concat, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    pub fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes,\n            \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes,\n            \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: Field) -> u8 {\n        self.body[idx as u32]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: Field,\n        starting_haystack_chunk: Field,\n        num_full_chunks: Field,\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte as Field + (i as Field * 31) + j as Field;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate: Field = lt_f(i as Field, num_full_chunks) as Field;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as Field * (i as Field + starting_haystack_chunk)];\n            assert(predicate * (lhs - rhs) == 0);\n        }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    pub fn substring_match<NeedleSubString>(self, substring: NeedleSubString) -> (bool, u32)\n    where\n        NeedleSubString: SubStringTrait,\n    {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text\n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len(),\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length,\n            \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\",\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: Field = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: Field = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks =\n            lt_f(substring_length as Field, num_bytes_in_first_chunk as Field);\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk =\n                num_full_chunks as Field * 31 + num_bytes_in_first_chunk as Field;\n\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes =\n                num_full_chunks as Field + chunk_index as Field + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index as Field;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n        when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n        a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n        Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n        The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n        If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: Field = chunk_offset as Field;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk =\n            self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: Field = i as Field;\n            let predicate: Field = lt_f(i as Field, offset_to_first_needle_byte_in_chunk) as Field;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = (1 - predicate) * (idx - offset_to_first_needle_byte_in_chunk);\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index: Field =\n                starting_needle_byte_index_of_final_chunk as Field + i as Field;\n            let predicate = lt_f(lhs_index, substring_length as Field);\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n            NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let substring_idx = (predicate as Field) * lhs_index;\n            let byte_from_substring = substring.get(substring_idx) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/\n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field\n            * (final_needle_chunk - initial_needle_chunk)\n            + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset: Field = chunk_index as Field + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk as Field,\n            body_chunk_offset,\n            num_full_chunks as Field,\n        );\n        (true, position)\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for StringBody<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n///\n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(\n    body: [u8; MaxPaddedBytes],\n) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text =\n        \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n\n#[test]\nfn test_substring_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_string_body_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn regression_20() {\n    let haystack: [u8; 128] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x92, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x6e, 0x00, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    let needle: [u8; 32] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let needle_len: u32 = 0x20;\n    let id_haystack: StringBody128 = StringBody::new(haystack, 128);\n    let pk_needle: SubString32 = SubString::new(needle, needle_len);\n    let (result, _): (bool, u32) = id_haystack.substring_match(pk_needle);\n    assert(result);\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir_string_search/v0.3.2/src/lib.nr"},"142":{"source":"pub unconstrained fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32,\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\npub unconstrained fn get_lt_predicate_f(x: Field, y: Field) -> bool {\n    let a = x as u32;\n    let b = y as u32;\n    a < b\n}\n\npub fn lt_f(x: Field, y: Field) -> bool {\n    // Safety: As `x` and `y` are known to be valid `u32`s, this function reimplements the\n    // compiler's internal implementation of `lt`\n    unsafe {\n        let predicate = get_lt_predicate_f(x, y);\n        let delta = y as Field - x as Field;\n        let lt_parameter = 2 * (predicate as Field) * delta - predicate as Field - delta;\n        lt_parameter.assert_max_bit_size::<32>();\n\n        predicate\n    }\n}\n\npub struct DebugRandomEngine {\n    pub seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = std::hash::blake3(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    pub unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir_string_search/v0.3.2/src/utils.nr"},"143":{"source":"use crate::{KEY_LIMBS_1024, KEY_LIMBS_2048, RSA_EXPONENT};\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse rsa::{rsa::verify_sha256_pkcs1v15, types::{RBN1024, RBN2048}};\nuse std::hash::{pedersen_hash, sha256_var};\n\npub struct RSAPubkey<let KEY_LIMBS: u32> {\n    modulus: [Field; KEY_LIMBS],\n    redc: [Field; KEY_LIMBS],\n}\n\nimpl<let KEY_LIMBS: u32> RSAPubkey<KEY_LIMBS> {\n\n    pub fn new(modulus: [Field; KEY_LIMBS], redc: [Field; KEY_LIMBS]) -> Self {\n        let pubkey = Self { modulus, redc };\n        pubkey\n    }\n}\n\nimpl RSAPubkey<KEY_LIMBS_1024> {\n    pub fn verify_dkim_signature<let MAX_HEADER_LENGTH: u32>(\n        self,\n        header: BoundedVec<u8, MAX_HEADER_LENGTH>,\n        signature: [Field; KEY_LIMBS_1024],\n    ) -> [u8; 32] {\n        // hash the header\n        let header_hash = sha256_var(header.storage(), header.len() as u64);\n\n        let params: BigNumParams<KEY_LIMBS_1024, 1024> =\n            BigNumParams::new(false, self.modulus, self.redc);\n\n        let signature: RBN1024 = RuntimeBigNum::from_array(params, signature);\n        signature.validate_in_range();\n\n        // verify the DKIM signature over the header\n        assert(verify_sha256_pkcs1v15(header_hash, signature, RSA_EXPONENT));\n\n        header_hash\n    }\n\n    pub fn hash(self) -> Field {\n        // validate\n        self.validate_in_range();\n        let mut dkim_preimage = [0; 9];\n        // compose first 4 limbs of modulus and redc\n        for i in 0..4 {\n            let modulus_hi = self.modulus[i * 2] * 2.pow_32(120);\n            let redc_hi = self.redc[i * 2] * 2.pow_32(120);\n            dkim_preimage[i] = modulus_hi + self.modulus[i * 2 + 1];\n            dkim_preimage[i + 4] = redc_hi + self.redc[i * 2 + 1];\n        }\n        // compose last two elements of redc and modulus together\n        let modulus_hi = self.modulus[8] * 2.pow_32(120);\n        dkim_preimage[8] = modulus_hi + self.redc[8];\n        // hash the pubkey\n        pedersen_hash(dkim_preimage)\n    }\n\n    pub fn validate_in_range(self) {\n        for i in 0..(KEY_LIMBS_1024 - 1) {\n            self.modulus[i].assert_max_bit_size::<120>();\n            self.redc[i].assert_max_bit_size::<120>();\n        }\n        self.modulus[KEY_LIMBS_1024 - 1].assert_max_bit_size::<1024 - ((KEY_LIMBS_1024 - 1) * 120)>();\n        self.redc[KEY_LIMBS_1024 - 1].assert_max_bit_size::<120>();\n    }\n}\n\nimpl RSAPubkey<KEY_LIMBS_2048> {\n    pub fn verify_dkim_signature<let MAX_HEADER_LENGTH: u32>(\n        self,\n        header: BoundedVec<u8, MAX_HEADER_LENGTH>,\n        signature: [Field; KEY_LIMBS_2048],\n    ) -> [u8; 32] {\n        // hash the header\n        let header_hash = sha256_var(header.storage(), header.len() as u64);\n\n        let params: BigNumParams<KEY_LIMBS_2048, 2048> =\n            BigNumParams::new(false, self.modulus, self.redc);\n\n        let signature: RBN2048 = RuntimeBigNum::from_array(params, signature);\n        signature.validate_in_range();\n\n        // verify the DKIM signature over the header\n        assert(verify_sha256_pkcs1v15(header_hash, signature, RSA_EXPONENT));\n\n        header_hash\n    }\n\n    pub fn hash(self) -> Field {\n        // validate range\n        self.validate_in_range();\n        let mut dkim_preimage = [0; 18];\n        // compose limbs\n        for i in 0..9 {\n            let modulus_hi = self.modulus[i * 2] * 2.pow_32(120);\n            let redc_hi = self.redc[i * 2] * 2.pow_32(120);\n            dkim_preimage[i] = modulus_hi + self.modulus[i * 2 + 1];\n            dkim_preimage[i + 9] = redc_hi + self.redc[i * 2 + 1];\n        }\n        // hash the pubkey\n        pedersen_hash(dkim_preimage)\n    }\n\n    pub fn validate_in_range(self) {\n        for i in 0..(KEY_LIMBS_2048 - 1) {\n            self.modulus[i].assert_max_bit_size::<120>();\n            self.redc[i].assert_max_bit_size::<120>();\n        }\n        self.modulus[KEY_LIMBS_2048 - 1].assert_max_bit_size::<2048 - ((KEY_LIMBS_2048 - 1) * 120)>();\n        self.redc[KEY_LIMBS_2048 - 1].assert_max_bit_size::<120>(); // we get 2053 sometimes?\n    }\n}\n","path":"/Users/unomasanori/nargo/github.com/zkemail/zkemail.nr/v0.4.3/lib/src/dkim.nr"},"144":{"source":"use crate::{\n    BODY_HASH_BASE64_LENGTH, headers::constrain_header_field, MAX_DKIM_HEADER_FIELD_LENGTH,\n    Sequence,\n};\nuse base64::BASE64_DECODER;\n\n// ON DKIM-SIGNATURE PARSING:\n// In the current version, DKIM-SIGNATURE tags are mostly ignored:\n// c= is ignored, meaning we assume the canonicalization is relaxed. This can cause denial of service issues\n// v= is ignored, meaning we do not check for a valid version of dkim signing\n// l= is ignored, meaning we otherwise constrain the body length to be safe\n// x= is ignored, meaning we accept signatures without expiration\n// sdid= is ignored, meaning that we don't explicitly bind dkim keys to exact signing domains\n// See line 42 of this file for parsing bh=;\n// You will need to implement your own parsing for the tags' expected values\n\n/**\n * Constrained access to the body hash in the header\n * \n * @param MAX_HEADER_LENGTH - The maximum length of the email header\n * @param header - The email header as validated in the DKIM signature\n * @param dkim_header_field_sequence - The sequence of the DKIM header field\n * @param body_hash_index - The index of the body hash in the header\n */\npub fn get_body_hash<let MAX_HEADER_LENGTH: u32>(\n    header: BoundedVec<u8, MAX_HEADER_LENGTH>,\n    dkim_header_field_sequence: Sequence,\n    body_hash_index: u32,\n) -> [u8; 32] {\n    // constrain the access of dkim signature field\n    let header_field_name: [u8; 14] = comptime { \"dkim-signature\".as_bytes() };\n    constrain_header_field::<MAX_HEADER_LENGTH, MAX_DKIM_HEADER_FIELD_LENGTH, 14>(\n        header,\n        dkim_header_field_sequence,\n        header_field_name,\n    );\n    // constrain access to the body hash\n    let start_range = body_hash_index > dkim_header_field_sequence.index;\n    let end_range =\n        body_hash_index + BODY_HASH_BASE64_LENGTH < dkim_header_field_sequence.end_index() + 1;\n    assert(start_range & end_range, \"Body hash index accessed outside of DKIM header field\");\n\n    // check bh prefix\n    let bh_prefix_first_no_space: [u8; 5] = comptime { \"e:bh=\".as_bytes() };\n    let bh_prefix_space: [u8; 5] = comptime { \": bh=\".as_bytes() };\n    let bh_prefix_subsequent: [u8; 5] = comptime { \"; bh=\".as_bytes() };\n    let mut found_first = true;\n    let mut found_subsequent = true;\n    for i in 0..5 {\n        let character = header.get_unchecked(body_hash_index - 5 + i);\n        let match_first_no_space = character == bh_prefix_first_no_space[i];\n        let match_first_space = character == bh_prefix_space[i];\n        let match_first = match_first_no_space | match_first_space;\n        found_first = found_first & match_first;\n        let match_subsequent = character == bh_prefix_subsequent[i];\n        found_subsequent = found_subsequent & match_subsequent;\n    }\n    assert(found_first | found_subsequent, \"No ':bh=' or '; bh=' prefix found before body hash\");\n\n    // check that bh is followed by ;\n    let bh_suffix: u8 = comptime { \";\".as_bytes()[0] };\n    assert(\n        header.get_unchecked(body_hash_index + BODY_HASH_BASE64_LENGTH) == bh_suffix,\n        \"No ';' suffix found at asserted bh index\",\n    );\n    // get the body hash\n    get_body_hash_unsafe(header, body_hash_index)\n}\n\n/**\n * Get the body hash from the header without validating the access index. Does not validate body\n * hash is valid base64 sequence (https://github.com/noir-lang/noir_base64/blob/4431d08ac661ada9d8d18b115487ff0190b43856/src/lib.nr#L209-L232)\n *\n * @param MAX_HEADER_LENGTH - The maximum length of the email header\n * @param header - The email header as validated in the DKIM signature\n * @param body_hash_index - The asserted index to find the body hash at\n */\npub fn get_body_hash_unsafe<let MAX_HEADER_LENGTH: u32>(\n    header: BoundedVec<u8, MAX_HEADER_LENGTH>,\n    body_hash_index: u32,\n) -> [u8; 32] {\n    // get the body hash\n    let mut body_hash_encoded: [u8; BODY_HASH_BASE64_LENGTH] = [0; BODY_HASH_BASE64_LENGTH];\n    for i in 0..BODY_HASH_BASE64_LENGTH {\n        body_hash_encoded[i] = header.get_unchecked(body_hash_index + i);\n    }\n    // return the decoded body hash\n    // idk why encode vs decode...\n    BASE64_DECODER.decode(body_hash_encoded)\n}\n","path":"/Users/unomasanori/nargo/github.com/zkemail/zkemail.nr/v0.4.3/lib/src/headers/body_hash.nr"},"146":{"source":"use crate::{CR, LF, Sequence};\n\npub mod body_hash;\npub mod email_address;\n\n/**\n * Constrain a sequence in a header to be within the correct bounds\n *\n * @param MAX_HEADER_LENGTH - The maximum length of the email header\n * @param MAX_HEADER_FIELD_LENGTH - The maximum length of the header field\n * @param HEADER_FIELD_NAME_LENGTH - The length of the header field name\n * @param header - The email header as validated in the DKIM signature\n * @param header_field_sequence - The sequence of the header field\n * @param header_field_name - The name of the header field\n */\nfn check_header_field_bounds<let MAX_HEADER_LENGTH: u32, let MAX_HEADER_FIELD_LENGTH: u32, let HEADER_FIELD_NAME_LENGTH: u32>(\n    header: BoundedVec<u8, MAX_HEADER_LENGTH>,\n    header_field_sequence: Sequence,\n    header_field_name: [u8; HEADER_FIELD_NAME_LENGTH],\n) {\n    // check the range of the sequence is within the header (so we can use get_unchecked)\n    let end_index = header_field_sequence.end_index();\n    assert(end_index <= header.len(), \"Header field out of bounds of header\");\n\n    // if the sequence is not the start, check for a newline\n    if header_field_sequence.index != 0 {\n        assert(\n            header.get_unchecked(header_field_sequence.index - 2) == CR,\n            \"Header field must start with CRLF\",\n        );\n        assert(\n            header.get_unchecked(header_field_sequence.index - 1) == LF,\n            \"Header field must start with CRLF\",\n        );\n    }\n\n    // if the sequence is not the end, check for a newline\n    if end_index != header.len() {\n        assert(header.get_unchecked(end_index) == CR, \"Header field must end with CRLF\");\n        assert(header.get_unchecked(end_index + 1) == LF, \"Header field must end with CRLF\");\n    }\n\n    // check that the header field name matches the expected name\n    for i in 0..HEADER_FIELD_NAME_LENGTH {\n        assert(\n            header.get_unchecked(header_field_sequence.index + i) == header_field_name[i],\n            \"Header field name does not match\",\n        );\n    }\n    assert(\n        header.get_unchecked(header_field_sequence.index + HEADER_FIELD_NAME_LENGTH) == 0x3a,\n        \"Header field name must be followed by a colon\",\n    );\n}\n\n/**\n * Constrain a sequence in a header to match the specific header field\n *\n * @param MAX_HEADER_LENGTH - The maximum length of the email header\n * @param MAX_HEADER_FIELD_LENGTH - The maximum length of the header field\n * @param HEADER_FIELD_NAME_LENGTH - The length of the header field name\n * @param header - The email header as validated in the DKIM signature\n * @param header_field_sequence - The sequence of the header field\n * @param header_field_name - The name of the header field\n */\npub fn constrain_header_field<let MAX_HEADER_LENGTH: u32, let MAX_HEADER_FIELD_LENGTH: u32, let HEADER_FIELD_NAME_LENGTH: u32>(\n    header: BoundedVec<u8, MAX_HEADER_LENGTH>,\n    header_field_sequence: Sequence,\n    header_field_name: [u8; HEADER_FIELD_NAME_LENGTH],\n) {\n    // constrain beginning of header field\n    check_header_field_bounds::<MAX_HEADER_LENGTH, MAX_HEADER_FIELD_LENGTH, HEADER_FIELD_NAME_LENGTH>(\n        header,\n        header_field_sequence,\n        header_field_name,\n    );\n\n    // check the header field is uninterrupted\n    let start_index = header_field_sequence.index + HEADER_FIELD_NAME_LENGTH + 1;\n    for i in 0..MAX_HEADER_FIELD_LENGTH {\n        // is it safe enough to cut this constraint cost in half by not checking lf? i think so\n        let index = start_index + i;\n        if (index < header_field_sequence.end_index()) {\n            assert(header.get_unchecked(index) != CR, \"Header field must not contain newlines\");\n        }\n    }\n}\n\n/**\n * constrain_header_field with checks for the last occurence of \"<\" inside the loop to save constraints\n */\npub fn constrain_header_field_detect_last_angle_bracket<let MAX_HEADER_LENGTH: u32, let MAX_HEADER_FIELD_LENGTH: u32, let HEADER_FIELD_NAME_LENGTH: u32>(\n    header: BoundedVec<u8, MAX_HEADER_LENGTH>,\n    header_field_sequence: Sequence,\n    header_field_name: [u8; HEADER_FIELD_NAME_LENGTH],\n) -> u32 {\n    // constrain beginning of header field\n    check_header_field_bounds::<MAX_HEADER_LENGTH, MAX_HEADER_FIELD_LENGTH, HEADER_FIELD_NAME_LENGTH>(\n        header,\n        header_field_sequence,\n        header_field_name,\n    );\n\n    // check the header field is uninterrupted\n    let mut last_angle_bracket = 0;\n    let start_index = header_field_sequence.index + HEADER_FIELD_NAME_LENGTH + 1;\n    for i in (HEADER_FIELD_NAME_LENGTH + 1)..MAX_HEADER_FIELD_LENGTH {\n        // is it safe enough to cut this constraint cost in half by not checking lf? i think so\n        let index = start_index + i;\n        if (index < header_field_sequence.end_index()) {\n            let byte = header.get_unchecked(index);\n            assert(byte != CR, \"Header field must not contain newlines\");\n            if byte == 0x3c {\n                last_angle_bracket = index;\n            }\n        }\n    }\n    last_angle_bracket\n}\n","path":"/Users/unomasanori/nargo/github.com/zkemail/zkemail.nr/v0.4.3/lib/src/headers/mod.nr"},"147":{"source":"use std::hash::pedersen_hash;\npub mod dkim;\npub mod headers;\npub mod masking;\npub mod partial_hash;\npub mod remove_soft_line_breaks;\npub mod utils;\nmod tests;\n\nglobal RSA_EXPONENT: u32 = 65537;\nglobal KEY_LIMBS_1024: u32 = 9;\nglobal KEY_LIMBS_2048: u32 = 18;\nglobal BODY_HASH_BASE64_LENGTH: u32 = 44;\nglobal CR: u8 = 0x0D;\nglobal LF: u8 = 0x0A;\nglobal MAX_DKIM_HEADER_FIELD_LENGTH: u32 = 300; // kinda arbitrary but gives > 100 chars for selector and domain\nglobal MAX_EMAIL_ADDRESS_LENGTH: u32 = 320; // derived via (https://datatracker.ietf.org/doc/html/rfc5321#section-4.5.3.1.1)\n\npub struct Sequence {\n    index: u32,\n    length: u32,\n}\n\nimpl Sequence {\n    pub fn end_index(self) -> u32 {\n        self.index + self.length\n    }\n}\n// allowable chars in an email address (js/src/utils:makeAllowableEmailCharsTable()\n// \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.-@\" = 1\n// \"<: \" = 2\n// \">\\r\\n\" = 3\nglobal EMAIL_ADDRESS_CHAR_TABLE: [u8; 123] = [\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 2, 0, 3, 0,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n];\n\n/**\n * Create a nullifier for a signature with a blinding factor\n *\n * @param signature - The signature to nullify\n * @param nonce - The nonce to use in the nullifier as a blinding factor\n * @return - The blinded nullifier for the signature\n */\npub fn blinded_nullifier<let KEY_LIMBS: u32>(signature: [Field; KEY_LIMBS], nonce: Field) -> Field {\n    let preimage = unsafe { __blinded_nullifier(signature, nonce) };\n    for i in 0..KEY_LIMBS {\n        assert(preimage[i] == signature[i], \"Preimage does not contain signature\");\n    }\n    assert(preimage[KEY_LIMBS] == nonce, \"Preimage does not contain nonce\");\n    pedersen_hash(preimage)\n}\n\n/**\n * Builds the nullifier preimage with a nonce\n * @notice the nonce should be governed at the app level - i.e. an aztec note can pass this in\n * \n * @param signature - The signature to nullify\n * @param nonce - The nonce to use in the nullifier as a blinding factor\n */\nunconstrained fn __blinded_nullifier<let KEY_LIMBS: u32>(\n    signature: [Field; KEY_LIMBS],\n    nonce: Field,\n) -> [Field; KEY_LIMBS + 1] {\n    let mut nullifier_preimage = [0; KEY_LIMBS + 1];\n    for i in 0..KEY_LIMBS {\n        nullifier_preimage[i] = signature[i];\n    }\n    nullifier_preimage[KEY_LIMBS] = nonce;\n\n    nullifier_preimage\n}\n","path":"/Users/unomasanori/nargo/github.com/zkemail/zkemail.nr/v0.4.3/lib/src/lib.nr"},"154":{"source":"use super::defaults::BASE64_PADDING_CHAR;\n\n/// Standard Base64 Alphabet (base64) with padding.\npub global STANDARD: Base64DecodeBE = Base64DecodeBE::new(true);\n\n/// Standard Base64 Alphabet (base64) without padding.\npub global STANDARD_NO_PAD: Base64DecodeBE = Base64DecodeBE::new(false);\n\n/// URL and Filename Safe Alphabet without padding.\npub global URL_SAFE: Base64DecodeBE = Base64DecodeBE::base64url(false);\n\n/// URL and Filename Safe Alphabet with padding.\npub global URL_SAFE_WITH_PAD: Base64DecodeBE = Base64DecodeBE::base64url(true);\n\n/// Invalid value for the lookup table.\nglobal INVALID_VALUE: u8 = 255;\n\n/// Base64 decoder for big-endian byte arrays.\n///\n/// > Note: If the lookup table is not defined in a struct, access costs are expensive and ROM\n/// tables aren't being used.\nstruct Base64DecodeBE {\n    /// The base64 lookup table.\n    table: [u8; 256],\n    /// Whether the input has padding.\n    pad: bool,\n}\n\nimpl Base64DecodeBE {\n    /// Creates a new decoder that uses the standard Base64 Alphabet (base64) specified in RFC 4648\n    /// (https://datatracker.ietf.org/doc/html/rfc4648#section-4).\n    ///\n    /// ## Value Parameters\n    ///\n    /// - `pad`: Whether the input has padding.\n    ///\n    /// ## Returns\n    ///\n    /// The Base64 decoder instance.\n    ///\n    /// ## Usage\n    ///\n    /// ```nr\n    /// let decoder = Base64DecodeBE::new(true);\n    /// ```\n    fn new(pad: bool) -> Self {\n        Base64DecodeBE {\n            table: [\n                // 0-42\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                62, // 43\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE, // 44-46\n                63, // 47\n                52,\n                53,\n                54,\n                55,\n                56,\n                57,\n                58,\n                59,\n                60,\n                61, // 48-57\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE, // 58-64\n                0,\n                1,\n                2,\n                3,\n                4,\n                5,\n                6,\n                7,\n                8,\n                9,\n                10,\n                11,\n                12,\n                13,\n                14,\n                15,\n                16,\n                17,\n                18,\n                19,\n                20,\n                21,\n                22,\n                23,\n                24,\n                25, // 65-90 (A-Z)\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE, // 91-96\n                26,\n                27,\n                28,\n                29,\n                30,\n                31,\n                32,\n                33,\n                34,\n                35,\n                36,\n                37,\n                38,\n                39,\n                40,\n                41,\n                42,\n                43,\n                44,\n                45,\n                46,\n                47,\n                48,\n                49,\n                50,\n                51, // 97-122 (a-z)\n                // 123-255\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n            ],\n            pad,\n        }\n    }\n\n    /// Creates a new decoder that uses the URL and Filename Safe Alphabet specified in RFC 4648\n    /// (https://datatracker.ietf.org/doc/html/rfc4648#section-5).\n    ///\n    /// ## Value Parameters\n    ///\n    /// - `pad`: Whether the input has padding.\n    ///\n    /// ## Returns\n    ///\n    /// The Base64 decoder instance.\n    ///\n    /// ## Usage\n    ///\n    /// ```nr\n    /// let decoder = Base64DecodeBE::base64url(true);\n    /// ```\n    fn base64url(pad: bool) -> Self {\n        Base64DecodeBE {\n            table: [\n                // 0-44 (no mapping)\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                62, // 45 (-)\n                INVALID_VALUE,\n                INVALID_VALUE, // 46-47 (no mapping)\n                52,\n                53,\n                54,\n                55,\n                56,\n                57,\n                58,\n                59,\n                60,\n                61, // 48-57 (0-9)\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE, // 58-64 (no mapping)\n                0,\n                1,\n                2,\n                3,\n                4,\n                5,\n                6,\n                7,\n                8,\n                9,\n                10,\n                11,\n                12,\n                13,\n                14,\n                15,\n                16,\n                17,\n                18,\n                19,\n                20,\n                21,\n                22,\n                23,\n                24,\n                25, // 65-90 (A-Z)\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE, // 91-94 (no mapping)\n                63, // 95 (_)\n                INVALID_VALUE, // 96 (no mapping)\n                26,\n                27,\n                28,\n                29,\n                30,\n                31,\n                32,\n                33,\n                34,\n                35,\n                36,\n                37,\n                38,\n                39,\n                40,\n                41,\n                42,\n                43,\n                44,\n                45,\n                46,\n                47,\n                48,\n                49,\n                50,\n                51, // 97-122 (a-z)\n                // 123-255\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n            ],\n            pad,\n        }\n    }\n\n    /// Gets the lookup table value at a given index.\n    ///\n    /// ## Value Parameters\n    ///\n    /// - `idx`: The index to get the value for.\n    ///\n    /// ## Returns\n    ///\n    /// The value from the lookup table.\n    ///\n    /// ## Usage\n    ///\n    /// ```nr\n    /// let value = Base64DecodeBE::new(true).get(65);\n    /// ```\n    fn get(self, idx: Field) -> u8 {\n        self.table[idx]\n    }\n\n    /// Converts an array of ASCII values into a packed byte array of base64 values.\n    ///\n    /// > Note: Each Base64 value is 6 bits. This method will produce a byte array where data is\n    /// > concatenated so that there are no sparse bits (e.g. encoding 4 ASCII values produces 24\n    /// > bits of Base64 data = 3 bytes of output data).\n    ///\n    /// ## Type Parameters\n    ///\n    /// - `InputElements`: The number of input elements.\n    /// - `OutputBytes`: The number of output bytes.\n    ///\n    /// ## Value Parameters\n    ///\n    /// - `self`: The Base64 decoder instance.\n    /// - `input`: The input array.\n    ///\n    /// ## Constraints\n    ///\n    /// - input and output lengths are correct, including padding.\n    ///\n    /// ## Returns\n    ///\n    /// The packed byte array of base64 values.\n    ///\n    /// ## Usage\n    ///\n    /// ```nr\n    /// let result = Decoder::new(false).decode::<4, 3>([65, 66, 67, 68]);\n    /// ```\n    pub fn decode<let InputElements: u32, let OutputBytes: u32>(\n        self,\n        input: [u8; InputElements],\n    ) -> [u8; OutputBytes] {\n        let rem = OutputBytes % 3;\n        // Calculate the number of padding characters and the length of the input without padding\n        let num_padding_chars = if rem == 1 {\n            2\n        } else if rem == 2 {\n            1\n        } else {\n            0\n        };\n\n        // Assert that the output length & input length are correct\n        // Every 3 output chars will be encoded as 4 base64 input chars\n        let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n        if self.pad {\n            assert(\n                encoded_length == InputElements,\n                f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n            );\n            // enforce Base64 padding is valid\n            if num_padding_chars == 2 {\n                assert(input[InputElements - 1] == BASE64_PADDING_CHAR);\n                assert(input[InputElements - 2] == BASE64_PADDING_CHAR);\n            } else if num_padding_chars == 1 {\n                assert(input[InputElements - 1] == BASE64_PADDING_CHAR);\n            }\n        } else {\n            let expected = encoded_length - num_padding_chars;\n            assert(\n                encoded_length - num_padding_chars == InputElements,\n                f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n            );\n        }\n\n        // 240 bits fits 40 6-bit chunks and 30 8-bit chunks\n        // we pack 40 base64 values into a field element and convert into 30 bytes\n        // TODO: once we support arithmetic ops on generics, derive OutputBytes from InputBytes\n        let mut result: [u8; OutputBytes] = [0; OutputBytes];\n        let BASE64_ELEMENTS_PER_CHUNK: u32 = 40;\n        let BYTES_PER_CHUNK: u32 = 30;\n        let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n            + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n        if num_chunks > 0 {\n            let final_chunk = num_chunks - 1;\n\n            for i in 0..final_chunk {\n                let mut slice: Field = 0;\n                for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                    slice *= 64;\n                    let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                    let input_byte = input[offset];\n                    let decoded = self.get(input_byte as Field);\n                    assert(\n                        decoded != INVALID_VALUE,\n                        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n                    );\n                    slice += decoded as Field;\n                }\n                let slice_bytes: [u8; 30] = slice.to_be_bytes();\n                for j in 0..BYTES_PER_CHUNK {\n                    result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n                }\n            }\n\n            // process the final chunk, which may contain padding\n            let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n            let byte_offset = final_chunk * BYTES_PER_CHUNK;\n            let base64_elements_in_final_chunk = if self.pad {\n                InputElements - base64_offset - num_padding_chars\n            } else {\n                InputElements - base64_offset\n            };\n\n            // pack the base64 values into the field element\n            let mut slice: Field = 0;\n            for j in 0..base64_elements_in_final_chunk {\n                slice *= 64;\n                let offset = base64_offset + j;\n                let input_byte = input[offset];\n                let decoded = self.get(input_byte as Field);\n                assert(\n                    decoded != INVALID_VALUE,\n                    f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n                );\n                slice += decoded as Field;\n            }\n            for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n            }\n\n            // TODO: check is it cheaper to use a constant value in `to_be_bytes` or can we use `bytes_in_final_chunk`?\n            // extract the bytes from the Field element\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n            for i in 0..num_bytes_in_final_chunk {\n                result[byte_offset + i] = slice_bytes[i];\n            }\n        }\n\n        result\n    }\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = STANDARD.decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = STANDARD.decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = STANDARD.decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = STANDARD.decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = STANDARD_NO_PAD.decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = STANDARD_NO_PAD.decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = STANDARD_NO_PAD.decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = STANDARD.decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = STANDARD_NO_PAD.decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = URL_SAFE_WITH_PAD.decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = URL_SAFE.decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = STANDARD_NO_PAD.decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = STANDARD_NO_PAD.decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = STANDARD.decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = STANDARD.decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = URL_SAFE_WITH_PAD.decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = URL_SAFE.decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = URL_SAFE.decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = URL_SAFE.decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = STANDARD.decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = STANDARD_NO_PAD.decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = URL_SAFE_WITH_PAD.decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = URL_SAFE.decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = STANDARD.decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = STANDARD_NO_PAD.decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = URL_SAFE_WITH_PAD.decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = URL_SAFE.decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    let expected = \"The quick brown fox jumps over the lazy dog, while 42 ravens perch atop a rusty mailbox. Zany quilters fabricate 9 cozy blankets, as 3 jovial wizards expertly mix 5 potent elixirs. Bright neon signs flash \\\"OPEN 24/7\\\" in the misty night air, illuminating 8 vintage cars parked along Main Street. A gentle breeze carries the aroma of fresh coffee and warm cinnamon rolls from Joe's Diner, enticing 6 sleepy truckers to stop for a late-night snack. Meanwhile, 11 mischievous kittens playfully chase a ball of yarn across Mrs. Johnson's porch, their antics observed by 2 wise old owls perched on a nearby oak tree.\";\n\n    let input: [u8; 816] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 119, 103, 100, 50,\n        104, 112, 98, 71, 85, 103, 78, 68, 73, 103, 99, 109, 70, 50, 90, 87, 53, 122, 73, 72, 66,\n        108, 99, 109, 78, 111, 73, 71, 70, 48, 98, 51, 65, 103, 89, 83, 66, 121, 100, 88, 78, 48,\n        101, 83, 66, 116, 89, 87, 108, 115, 89, 109, 57, 52, 76, 105, 66, 97, 89, 87, 53, 53, 73,\n        72, 70, 49, 97, 87, 120, 48, 90, 88, 74, 122, 73, 71, 90, 104, 89, 110, 74, 112, 89, 50, 70,\n        48, 90, 83, 65, 53, 73, 71, 78, 118, 101, 110, 107, 103, 89, 109, 120, 104, 98, 109, 116,\n        108, 100, 72, 77, 115, 73, 71, 70, 122, 73, 68, 77, 103, 97, 109, 57, 50, 97, 87, 70, 115,\n        73, 72, 100, 112, 101, 109, 70, 121, 90, 72, 77, 103, 90, 88, 104, 119, 90, 88, 74, 48, 98,\n        72, 107, 103, 98, 87, 108, 52, 73, 68, 85, 103, 99, 71, 57, 48, 90, 87, 53, 48, 73, 71, 86,\n        115, 97, 88, 104, 112, 99, 110, 77, 117, 73, 69, 74, 121, 97, 87, 100, 111, 100, 67, 66,\n        117, 90, 87, 57, 117, 73, 72, 78, 112, 90, 50, 53, 122, 73, 71, 90, 115, 89, 88, 78, 111,\n        73, 67, 74, 80, 85, 69, 86, 79, 73, 68, 73, 48, 76, 122, 99, 105, 73, 71, 108, 117, 73, 72,\n        82, 111, 90, 83, 66, 116, 97, 88, 78, 48, 101, 83, 66, 117, 97, 87, 100, 111, 100, 67, 66,\n        104, 97, 88, 73, 115, 73, 71, 108, 115, 98, 72, 86, 116, 97, 87, 53, 104, 100, 71, 108, 117,\n        90, 121, 65, 52, 73, 72, 90, 112, 98, 110, 82, 104, 90, 50, 85, 103, 89, 50, 70, 121, 99,\n        121, 66, 119, 89, 88, 74, 114, 90, 87, 81, 103, 89, 87, 120, 118, 98, 109, 99, 103, 84, 87,\n        70, 112, 98, 105, 66, 84, 100, 72, 74, 108, 90, 88, 81, 117, 73, 69, 69, 103, 90, 50, 86,\n        117, 100, 71, 120, 108, 73, 71, 74, 121, 90, 87, 86, 54, 90, 83, 66, 106, 89, 88, 74, 121,\n        97, 87, 86, 122, 73, 72, 82, 111, 90, 83, 66, 104, 99, 109, 57, 116, 89, 83, 66, 118, 90,\n        105, 66, 109, 99, 109, 86, 122, 97, 67, 66, 106, 98, 50, 90, 109, 90, 87, 85, 103, 89, 87,\n        53, 107, 73, 72, 100, 104, 99, 109, 48, 103, 89, 50, 108, 117, 98, 109, 70, 116, 98, 50, 52,\n        103, 99, 109, 57, 115, 98, 72, 77, 103, 90, 110, 74, 118, 98, 83, 66, 75, 98, 50, 85, 110,\n        99, 121, 66, 69, 97, 87, 53, 108, 99, 105, 119, 103, 90, 87, 53, 48, 97, 87, 78, 112, 98,\n        109, 99, 103, 78, 105, 66, 122, 98, 71, 86, 108, 99, 72, 107, 103, 100, 72, 74, 49, 89, 50,\n        116, 108, 99, 110, 77, 103, 100, 71, 56, 103, 99, 51, 82, 118, 99, 67, 66, 109, 98, 51, 73,\n        103, 89, 83, 66, 115, 89, 88, 82, 108, 76, 87, 53, 112, 90, 50, 104, 48, 73, 72, 78, 117,\n        89, 87, 78, 114, 76, 105, 66, 78, 90, 87, 70, 117, 100, 50, 104, 112, 98, 71, 85, 115, 73,\n        68, 69, 120, 73, 71, 49, 112, 99, 50, 78, 111, 97, 87, 86, 50, 98, 51, 86, 122, 73, 71, 116,\n        112, 100, 72, 82, 108, 98, 110, 77, 103, 99, 71, 120, 104, 101, 87, 90, 49, 98, 71, 120, 53,\n        73, 71, 78, 111, 89, 88, 78, 108, 73, 71, 69, 103, 89, 109, 70, 115, 98, 67, 66, 118, 90,\n        105, 66, 53, 89, 88, 74, 117, 73, 71, 70, 106, 99, 109, 57, 122, 99, 121, 66, 78, 99, 110,\n        77, 117, 73, 69, 112, 118, 97, 71, 53, 122, 98, 50, 52, 110, 99, 121, 66, 119, 98, 51, 74,\n        106, 97, 67, 119, 103, 100, 71, 104, 108, 97, 88, 73, 103, 89, 87, 53, 48, 97, 87, 78, 122,\n        73, 71, 57, 105, 99, 50, 86, 121, 100, 109, 86, 107, 73, 71, 74, 53, 73, 68, 73, 103, 100,\n        50, 108, 122, 90, 83, 66, 118, 98, 71, 81, 103, 98, 51, 100, 115, 99, 121, 66, 119, 90, 88,\n        74, 106, 97, 71, 86, 107, 73, 71, 57, 117, 73, 71, 69, 103, 98, 109, 86, 104, 99, 109, 74,\n        53, 73, 71, 57, 104, 97, 121, 66, 48, 99, 109, 86, 108, 76, 103, 61, 61,\n    ];\n    let result: [u8; 610] = STANDARD.decode(input);\n    assert(result == expected.as_bytes());\n\n    let input: [u8; 814] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 119, 103, 100, 50,\n        104, 112, 98, 71, 85, 103, 78, 68, 73, 103, 99, 109, 70, 50, 90, 87, 53, 122, 73, 72, 66,\n        108, 99, 109, 78, 111, 73, 71, 70, 48, 98, 51, 65, 103, 89, 83, 66, 121, 100, 88, 78, 48,\n        101, 83, 66, 116, 89, 87, 108, 115, 89, 109, 57, 52, 76, 105, 66, 97, 89, 87, 53, 53, 73,\n        72, 70, 49, 97, 87, 120, 48, 90, 88, 74, 122, 73, 71, 90, 104, 89, 110, 74, 112, 89, 50, 70,\n        48, 90, 83, 65, 53, 73, 71, 78, 118, 101, 110, 107, 103, 89, 109, 120, 104, 98, 109, 116,\n        108, 100, 72, 77, 115, 73, 71, 70, 122, 73, 68, 77, 103, 97, 109, 57, 50, 97, 87, 70, 115,\n        73, 72, 100, 112, 101, 109, 70, 121, 90, 72, 77, 103, 90, 88, 104, 119, 90, 88, 74, 48, 98,\n        72, 107, 103, 98, 87, 108, 52, 73, 68, 85, 103, 99, 71, 57, 48, 90, 87, 53, 48, 73, 71, 86,\n        115, 97, 88, 104, 112, 99, 110, 77, 117, 73, 69, 74, 121, 97, 87, 100, 111, 100, 67, 66,\n        117, 90, 87, 57, 117, 73, 72, 78, 112, 90, 50, 53, 122, 73, 71, 90, 115, 89, 88, 78, 111,\n        73, 67, 74, 80, 85, 69, 86, 79, 73, 68, 73, 48, 76, 122, 99, 105, 73, 71, 108, 117, 73, 72,\n        82, 111, 90, 83, 66, 116, 97, 88, 78, 48, 101, 83, 66, 117, 97, 87, 100, 111, 100, 67, 66,\n        104, 97, 88, 73, 115, 73, 71, 108, 115, 98, 72, 86, 116, 97, 87, 53, 104, 100, 71, 108, 117,\n        90, 121, 65, 52, 73, 72, 90, 112, 98, 110, 82, 104, 90, 50, 85, 103, 89, 50, 70, 121, 99,\n        121, 66, 119, 89, 88, 74, 114, 90, 87, 81, 103, 89, 87, 120, 118, 98, 109, 99, 103, 84, 87,\n        70, 112, 98, 105, 66, 84, 100, 72, 74, 108, 90, 88, 81, 117, 73, 69, 69, 103, 90, 50, 86,\n        117, 100, 71, 120, 108, 73, 71, 74, 121, 90, 87, 86, 54, 90, 83, 66, 106, 89, 88, 74, 121,\n        97, 87, 86, 122, 73, 72, 82, 111, 90, 83, 66, 104, 99, 109, 57, 116, 89, 83, 66, 118, 90,\n        105, 66, 109, 99, 109, 86, 122, 97, 67, 66, 106, 98, 50, 90, 109, 90, 87, 85, 103, 89, 87,\n        53, 107, 73, 72, 100, 104, 99, 109, 48, 103, 89, 50, 108, 117, 98, 109, 70, 116, 98, 50, 52,\n        103, 99, 109, 57, 115, 98, 72, 77, 103, 90, 110, 74, 118, 98, 83, 66, 75, 98, 50, 85, 110,\n        99, 121, 66, 69, 97, 87, 53, 108, 99, 105, 119, 103, 90, 87, 53, 48, 97, 87, 78, 112, 98,\n        109, 99, 103, 78, 105, 66, 122, 98, 71, 86, 108, 99, 72, 107, 103, 100, 72, 74, 49, 89, 50,\n        116, 108, 99, 110, 77, 103, 100, 71, 56, 103, 99, 51, 82, 118, 99, 67, 66, 109, 98, 51, 73,\n        103, 89, 83, 66, 115, 89, 88, 82, 108, 76, 87, 53, 112, 90, 50, 104, 48, 73, 72, 78, 117,\n        89, 87, 78, 114, 76, 105, 66, 78, 90, 87, 70, 117, 100, 50, 104, 112, 98, 71, 85, 115, 73,\n        68, 69, 120, 73, 71, 49, 112, 99, 50, 78, 111, 97, 87, 86, 50, 98, 51, 86, 122, 73, 71, 116,\n        112, 100, 72, 82, 108, 98, 110, 77, 103, 99, 71, 120, 104, 101, 87, 90, 49, 98, 71, 120, 53,\n        73, 71, 78, 111, 89, 88, 78, 108, 73, 71, 69, 103, 89, 109, 70, 115, 98, 67, 66, 118, 90,\n        105, 66, 53, 89, 88, 74, 117, 73, 71, 70, 106, 99, 109, 57, 122, 99, 121, 66, 78, 99, 110,\n        77, 117, 73, 69, 112, 118, 97, 71, 53, 122, 98, 50, 52, 110, 99, 121, 66, 119, 98, 51, 74,\n        106, 97, 67, 119, 103, 100, 71, 104, 108, 97, 88, 73, 103, 89, 87, 53, 48, 97, 87, 78, 122,\n        73, 71, 57, 105, 99, 50, 86, 121, 100, 109, 86, 107, 73, 71, 74, 53, 73, 68, 73, 103, 100,\n        50, 108, 122, 90, 83, 66, 118, 98, 71, 81, 103, 98, 51, 100, 115, 99, 121, 66, 119, 90, 88,\n        74, 106, 97, 71, 86, 107, 73, 71, 57, 117, 73, 71, 69, 103, 98, 109, 86, 104, 99, 109, 74,\n        53, 73, 71, 57, 104, 97, 121, 66, 48, 99, 109, 86, 108, 76, 103,\n    ];\n    let result = STANDARD_NO_PAD.decode(input);\n    assert(result == expected.as_bytes());\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = STANDARD.decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir_base64/v0.3.1/src/decoder.nr"},"190":{"source":"use crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_120: Field = 0x1000000000000000000000000000000;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> Field {\n    let TWO_POW_120 = 0x1000000000000000000000000000000;\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0]\n    } else if N == 2 {\n        validate_in_range::<N, MOD_BITS>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120 + limbs[2] * TWO_POW_120 * TWO_POW_120\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    field: Field,\n) -> [Field; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result = unsafe { __from_field::<N>(field) };\n\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n\n        let TWO_POW_120 = 0x1000000000000000000000000000000;\n        // validate that the last limb is less than the modulus\n        if N > 2 {\n            // validate that the result is less than the modulus\n            let mut grumpkin_modulus = [0; N];\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n            // validate that the limbs are in range\n            validate_in_range::<N, MOD_BITS>(result);\n        }\n        // validate the limbs sum up to the field value\n        let field_val = if N < 2 {\n            result[0]\n        } else if N == 2 {\n            validate_in_range::<N, MOD_BITS>(result);\n            result[0] + result[1] * TWO_POW_120\n        } else {\n            validate_in_range::<N, MOD_BITS>(result);\n            result[0] + result[1] * TWO_POW_120 + result[2] * TWO_POW_120 * TWO_POW_120\n        };\n        assert(field_val == field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[Field; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [Field; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: Field = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as Field + (1 - need_more_bytes as Field));\n                limb += byte as Field * need_more_bytes as Field;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [Field; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [Field; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n    predicate: bool,\n) -> [Field; N] {\n    let mut result: [Field; N] = lhs;\n    for i in 0..N {\n        result[i] = (lhs[i] - rhs[i]) * predicate as Field + rhs[i];\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120;\n        r *= TWO_POW_120;\n        modulus_mod_n *= TWO_POW_120;\n        l += lhs[N - i - 1];\n        r += rhs[N - i - 1];\n        modulus_mod_n += params.modulus[N - i - 1];\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [Field; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [Field; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = modulus[i] - val[i];\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += borrow_flags[0] as Field * TWO_POW_120;\n    for i in 1..N - 1 {\n        p_minus_self[i] += (borrow_flags[i] as Field * TWO_POW_120 - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= borrow_flags[N - 2] as Field;\n    validate_in_range::<_, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N - 1) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [Field; N], rhs: [Field; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] - 1\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb =\n            modulus[0] - val[0] - result[0] + (borrow_flags[0] as Field * TWO_POW_120);\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] - val[i] - result[i] - borrow_flags[i - 1] as Field\n                + (borrow_flags[i] as Field * TWO_POW_120);\n            assert(result_limb == 0);\n        }\n        let result_limb =\n            modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __add(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [Field; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb =\n            lhs[0] + rhs[0] - subtrahend[0] - result[0] + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] + rhs[i] - subtrahend[i] - result[i] - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb =\n            lhs[N - 1] + rhs[N - 1] - subtrahend[N - 1] - result[N - 1] - borrow_sub_carry;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [Field; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb =\n            lhs[N - 1] - rhs[N - 1] + addend[N - 1] - result[N - 1] - borrow_sub_carry;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/fns/constrained_ops.nr"},"191":{"source":"use crate::utils::split_bits;\n\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * __compute_quadratic_expression_with_borrow_flags\n * __add_linear_expression\n * __compute_quadratic_expression_product\n * __compute_quadratic_expression\n * evaluate_quadratic_expression\n */\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let modulus: [Field; N] = params.modulus;\n    let modulus_bits = MOD_BITS;\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        modulus_bits,\n        modulus,\n        params.modulus_u60_x4,\n    );\n    assert(remainder == [0; N]);\n\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] * modulus[j];\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let downshift: Field = 1 / two_pow_120;\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits = (mulout_p[0] - mulout_n[0] + (borrow_flags[0] * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n    flags: [bool; M],\n) -> ([Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [Field; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [Field; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + modulus2[j] - x[i][j];\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut add: [Field; N] = [0; N];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] * rhs[k][j]);\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        k,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([Field; N], [Field; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [Field; N] = params.double_modulus;\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i];\n                    t0[k][i] += double_modulus[i];\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i];\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i];\n                    t1[k][i] += double_modulus[i];\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i];\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i];\n                t4[i] += double_modulus[i];\n            } else {\n                t4[i] += linear_terms[j][i];\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term = t0[k][i] * t1[k][j] - quotient[i] * params.modulus[j];\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j];\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] * params.modulus[j];\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/fns/expressions.nr"},"193":{"source":"/**\n* @brief construct a BigNum instance out of an array of bytes in BIG ENDIAN format\n* @description: each 120-bit limb represents 15 bytes, we require that the size of the byte array\n*               is precisely large enough to cover MOD_BITS\n* @param x: input byte array\n**/\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    x: [u8; NBytes],\n) -> [Field; N] {\n    let num_bits = NBytes * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result = [0; N];\n\n    let excess_bytes = N * 15 - NBytes;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        result[N - i - 1] = limb;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - (NBytes * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    val: [Field; N],\n) -> [u8; NBytes] {\n    let nbytes = (MOD_BITS / 8) + (MOD_BITS % 8 != 0) as u32;\n    assert(nbytes <= NBytes);\n\n    let mut result: [u8; NBytes] = [0; NBytes];\n    for i in 0..N - 1 {\n        let limb_bytes: [u8; 15] = val[i].to_le_bytes();\n        for j in 0..15 {\n            result[i * 15 + j] = limb_bytes[j];\n        }\n    }\n    let last_limb_bytes: [u8; 15] = val[N - 1].to_le_bytes();\n    let num_last_bytes = (NBytes - (N - 1) * 15);\n    for i in 0..num_last_bytes {\n        result[(N - 1) * 15 + i] = last_limb_bytes[i];\n    }\n    result\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/fns/serialization.nr"},"194":{"source":"use crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\nuse crate::fns::unconstrained_ops::{__add, __eq, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_60: u64 = 0x1000000000000000;\n\n/**\n * In this file:\n *\n * __validate_in_field_compute_borrow_flags\n * __validate_gt_remainder\n * __neg_with_flags\n * __add_with_flags\n * __sub_with_flags\n * __barrett_reduction\n * __tonelli_shanks_sqrt\n */\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [Field; N] {\n    // cast the field to a u60 representation\n    let res_u60: U60Repr<N, 2> = U60Repr::from_field(field);\n    let result: [Field; N] = U60Repr::into(res_u60);\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [Field; N] = params.modulus;\n    flags[0] = modulus[0].lt(val[0]);\n    for i in 1..N - 1 {\n        flags[i] = modulus[i].lt(val[i] + flags[i - 1] as Field);\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N]) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let mut b_u60: U60Repr<N, 2> = From::from(rhs);\n\n    let underflow = b_u60.gte(a_u60);\n    b_u60 += U60Repr::one();\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                carry_flags[i / 2] = carry as bool;\n                borrow_flags[i / 2] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> ([Field; N], [bool; N]) {\n    let x_u60: U60Repr<N, 2> = From::from(val);\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut borrow_in: u64 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let sub_term = x_u60.limbs[i] + borrow_in;\n        let borrow = (sub_term > params.modulus_u60.limbs[i]) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + params.modulus_u60.limbs[i] - sub_term;\n\n        borrow_in = borrow;\n        if ((i & 1) == 1) {\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let b_u60: U60Repr<N, 2> = From::from(rhs);\n    let add_u60 = a_u60 + b_u60;\n\n    let overflow = add_u60.gte(params.modulus_u60);\n\n    let mut subtrahend_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    if overflow {\n        subtrahend_u60 = params.modulus_u60;\n    }\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + b_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = subtrahend_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                let idx = (i - 1) / 2;\n                carry_flags[idx] = carry as bool;\n                borrow_flags[idx] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60 + U60Repr::one());\n\n    let addend_u60: U60Repr<N, 2> = if underflow {\n        params.modulus_u60\n    } else {\n        U60Repr { limbs: [0; 2 * N] }\n    };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + addend_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                carry_flags[i / 2] = carry as bool;\n                borrow_flags[i / 2] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [Field; 2 * N],\n    redc_param: [Field; N],\n    k: u32,\n    modulus: [Field; N],\n    modulus_u60: U60Repr<N, 4>,\n) -> ([Field; N], [Field; N]) {\n    // for each i in 0..(N + N), adds x[i] * redc_param[j] to mulout[i + j] for each j in 0..N\n    let mut mulout: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout[i + j] += x[i] * redc_param[j];\n        }\n    }\n\n    mulout = split_bits::__normalize_limbs(mulout, 3 * N - 1);\n    let mulout_u60: U60Repr<N, 6> = U60Repr::new(mulout);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient_u60 = mulout_u60.shr((k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = quotient_u60.into_field_array();\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] += partial_quotient_full[i] * modulus[j];\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    for i in 0..(N + N) {\n        let (lo, hi) = split_bits::split_120_bits(quotient_mul_modulus_normalized[i]);\n        quotient_mul_modulus_normalized[i] = lo;\n\n        // Propagate higher bits to the next index\n        // TODO: what is faster, leaving this if statement in or out?\n        // (array is size-1 too large so we can tolerate adding 0 into max element)\n        if (i + 1 < N + N) {\n            quotient_mul_modulus_normalized[i + 1] += hi;\n        }\n    }\n\n    let quotient_mul_modulus_u60: U60Repr<N, 4> = U60Repr::new(quotient_mul_modulus_normalized);\n    // convert the input into U60Repr\n    let x_u60: U60Repr<N, 4> = U60Repr::new(x);\n    let mut remainder_u60 = x_u60 - quotient_mul_modulus_u60;\n    // barrett reduction is quirky so might need to remove a few modulus_u60 from the remainder\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n\n    let q: [Field; N] = U60Repr::into(quotient_u60);\n    let r: [Field; N] = U60Repr::into(remainder_u60);\n\n    (q, r)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut target: U60Repr<N, 2> = params.modulus_u60 - U60Repr::one();\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target.limbs[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target.shr1();\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [Field; N],\n    p_minus_one_over_two: [Field; N],\n) -> (bool, [Field; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [Field; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = __eq(exped, neg_one);\n    let mut result: (bool, [Field; N]) = (found, target);\n    if (!found) {\n        let _target = __add(params, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [Field; N] {\n    let mut target: [Field; N] = __one();\n    let p_minus_one_over_two: U60Repr<N, 2> = (params.modulus_u60 - U60Repr::one()).shr(1);\n    let p_minus_one_over_two: [Field; N] = U60Repr::into(p_minus_one_over_two);\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [Field; N],\n    i: u32,\n) -> u32 {\n    let one: [Field; N] = __one();\n    let is_one = __eq(t2m, one);\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/fns/unconstrained_helpers.nr"},"195":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __multiplicative_generator, __primitive_root_log_size,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\n/**\n * In this file:\n *\n * __one\n * __derive_from_seed\n * __eq\n * __is_zero\n * __neg\n * __add\n * __sub\n * __mul_with_quotient\n * __mul\n * __div\n * __udiv_mod\n * __invmod\n * __pow\n * __batch_invert\n * __batch_invert_slice\n */\n\npub(crate) unconstrained fn __one<let N: u32>() -> [Field; N] {\n    let mut limbs: [Field; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [Field; N], rhs: [Field; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [Field; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> [Field; N] {\n    let f: [Field; N] = limbs;\n    let x_u60: U60Repr<N, 2> = U60Repr::from(f);\n    U60Repr::into(params.modulus_u60 - x_u60)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let x_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let y_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let mut z_u60 = x_u60 + y_u60;\n\n    if z_u60.gte(params.modulus_u60) {\n        z_u60 = z_u60 - params.modulus_u60;\n    }\n    U60Repr::into(z_u60)\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += lhs[i] * rhs[j];\n        }\n    }\n    let to_reduce = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(\n        to_reduce,\n        params.redc_param,\n        MOD_BITS,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    let inv_divisor = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut quotient_u60: U60Repr<N, 2> = U60Repr::from([0; N]);\n    let mut remainder_u60: U60Repr<N, 2> = U60Repr::from(numerator);\n\n    let mut divisor_u60: U60Repr<N, 2> = U60Repr::from(divisor);\n    let b = divisor_u60;\n\n    let mut bit_difference = remainder_u60.get_msb() - divisor_u60.get_msb();\n\n    let mut accumulator_u60: U60Repr<N, 2> = U60Repr::one();\n    divisor_u60 = divisor_u60.shl(bit_difference);\n    accumulator_u60 = accumulator_u60.shl(bit_difference);\n\n    if (divisor_u60.gte(remainder_u60 + U60Repr::one())) {\n        divisor_u60.shr1();\n        accumulator_u60.shr1();\n    }\n    for _ in 0..(N * 120) {\n        if (remainder_u60.gte(b) == false) {\n            break;\n        }\n\n        // we've shunted 'divisor' up to have the same bit length as our remainder.\n        // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n        if (remainder_u60.gte(divisor_u60)) {\n            remainder_u60 -= divisor_u60;\n            // we can use OR here instead of +, as\n            // accumulator is always a nice power of two\n            quotient_u60 = quotient_u60 + accumulator_u60;\n        }\n        divisor_u60.shr1(); // >>= 1;\n        accumulator_u60.shr1(); //  >>= 1;\n    }\n\n    (U60Repr::into(quotient_u60), U60Repr::into(remainder_u60))\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let exp_u60 = params.modulus_u60 - (one_u60 + one_u60);\n    let exp = U60Repr::into(exp_u60);\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n    exponent: [Field; N],\n) -> [Field; N] {\n    let x: U60Repr<N, 2> = U60Repr::from(exponent);\n\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [Field; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if x.get_bit(num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n) -> [[Field; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]; M] = [[0; N]; M];\n    let mut temporaries: [[Field; N]; N] = std::mem::zeroed();\n    for i in 0..N {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..N {\n        let idx = N - 1 - i;\n        if (!__is_zero(x[idx])) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]],\n) -> [[Field; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]] = [[0; N]];\n    let mut temporaries: [[Field; N]; N] = std::mem::zeroed();\n    for i in 0..N {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n        result = result.push_back([0; N]);\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (__is_zero(x[idx]) == false) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [Field; N],\n) -> std::option::Option<[Field; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let mut Q = (params.modulus_u60 - one_u60).shr(primitive_root_log_size - 1);\n    let Q_minus_one_over_two_u60 = (Q - one_u60).shr(2);\n    let Q_minus_one_over_two: [Field; N] = U60Repr::into(Q_minus_one_over_two_u60);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [Field; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    let one: [Field; N] = __one::<N>();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/fns/unconstrained_ops.nr"},"197":{"source":"use crate::utils::u60_representation::U60Repr;\n\npub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [Field; N],\n\n    // @brief modulus but represented in a U60Repr form\n    pub modulus_u60: U60Repr<N, 2>,\n    pub modulus_u60_x4: U60Repr<N, 4>,\n\n    // @brief double_modulus: used when performing negations and subtractions\n    pub double_modulus: [Field; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [Field; N],\n}\n\n// To be implemented by the user for any BigNum they define, or within the predefined BigNums in the `fields/` dir.\npub trait BigNumParamsGetter<let N: u32, let MOD_BITS: u32> {\n    pub fn get_params() -> BigNumParams<N, MOD_BITS>;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [Field; N],\n        redc_param: [Field; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            modulus_u60: U60Repr::from(modulus),\n            modulus_u60_x4: U60Repr::from(modulus),\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.modulus_u60 == other.modulus_u60)\n            & (self.modulus_u60_x4 == other.modulus_u60_x4)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [Field; N]) -> [Field; N] {\n    let TWO_POW_120: Field = 0x1000000000000000000000000000000;\n    let m: U60Repr<N, 2> = U60Repr::from(modulus);\n    let mut result: [Field; N] = U60Repr::into(m + m);\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/params.nr"},"198":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, is_zero, mul, neg,\n        sub, udiv, udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [Field; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\npub(crate) trait RuntimeBigNumTrait<let N: u32, let MOD_BITS: u32>: Neg + Add + Sub + Mul + Div + Eq {\n    pub fn new(params: BigNumParams<N, MOD_BITS>) -> Self;\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self;\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self;\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self;\n    pub fn from_be_bytes<let NBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        x: [u8; NBytes],\n    ) -> Self;\n\n    pub fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes];\n\n    pub fn modulus(self) -> Self;\n    pub fn modulus_bits() -> u32;\n    pub fn num_limbs() -> u32;\n    // pub fn get(self) -> [Field];\n    pub fn get_limbs(self) -> [Field; N];\n    pub fn get_limb(self, idx: u32) -> Field;\n    pub fn set_limb(&mut self, idx: u32, value: Field);\n\n    unconstrained fn __eq(self, other: Self) -> bool;\n    unconstrained fn __is_zero(self) -> bool;\n\n    // unconstrained\n    pub fn __neg(self) -> Self;\n    // unconstrained\n    pub fn __add(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __sub(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __mul(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __div(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    // unconstrained\n    pub fn __invmod(self) -> Self;\n    // unconstrained\n    pub fn __pow(self, exponent: Self) -> Self;\n\n    // unconstrained\n    pub fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M];\n    unconstrained fn __batch_invert_slice<let M: u32>(to_invert: [Self]) -> [Self];\n\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n\n    // unconstrained\n    pub fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self);\n\n    pub fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    );\n\n    pub fn eq(lhs: Self, rhs: Self) -> bool {\n        lhs == rhs\n    }\n    pub fn assert_is_not_equal(self, other: Self);\n    pub fn validate_in_field(self);\n    pub fn validate_in_range(self);\n    // pub fn validate_gt(self, lhs: Self, rhs: Self);\n\n    pub fn udiv_mod(numerator: Self, divisor: Self) -> (Self, Self);\n    pub fn udiv(numerator: Self, divisor: Self) -> Self;\n    pub fn umod(numerator: Self, divisor: Self) -> Self;\n\n    pub fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self;\n    pub fn is_zero(self) -> bool;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNumTrait<N, MOD_BITS> for RuntimeBigNum<N, MOD_BITS> {\n\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [Field; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::new(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x), params }\n    }\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    fn get_limbs(self) -> [Field; N] {\n        self.limbs\n    }\n\n    fn get_limb(self, idx: u32) -> Field {\n        self.limbs[idx]\n    }\n\n    fn set_limb(&mut self, idx: u32, value: Field) {\n        self.limbs[idx] = value;\n    }\n\n    unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs =\n            unsafe { __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn| Self::get_limbs(bn))) };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // Note: can't return a slice from this unconstrained to a constrained function.\n    unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs = {\n            let inv_slice =\n                __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn| Self::get_limbs(bn)));\n            inv_slice.as_array()\n        };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let (q_limbs, r_limbs) = unsafe {\n            __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n                params,\n                map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                lhs_flags,\n                map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                rhs_flags,\n                map(linear_terms, |bn| Self::get_limbs(bn)),\n                linear_flags,\n            )\n        };\n        (Self { limbs: q_limbs, params }, Self { limbs: r_limbs, params })\n    }\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| Self::get_limbs(bn)),\n            linear_flags,\n        )\n    }\n\n    fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    fn validate_in_range(self) {\n        validate_in_range::<_, MOD_BITS>(self.limbs);\n    }\n\n    fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let params = lhs.params;\n        assert(params == rhs.params);\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate), params }\n    }\n\n    fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/runtime_bignum.nr"},"205":{"source":"global TWO_POW_56: u64 = 0x100000000000000;\npub(crate) global TWO_POW_60: u64 = 0x1000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n//fields to u60rep conversion\n// field elements are 254 bits\n// so there will be 5 limbs\npub(crate) unconstrained fn field_to_u60rep(mut x: Field) -> (u64, u64, u64, u64, u64) {\n    // get the first 60 bits by casting to u64 and then taking the lower 60 bits\n    // we use the fact that this casting drops everything above 64 bits\n    let x_first_u64 = (x as u64);\n    let first: u64 = x_first_u64 % TWO_POW_60;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_60 as Field);\n    let x_second_u64 = (x as u64);\n    let second = x_second_u64 % TWO_POW_60;\n    x = (x - (second as Field)) / (TWO_POW_60 as Field);\n    let x_third_u64 = (x as u64);\n    let third = x_third_u64 % TWO_POW_60;\n    x = (x - (third as Field)) / (TWO_POW_60 as Field);\n    let x_fourth_u64 = (x as u64);\n    let fourth = x_fourth_u64 % TWO_POW_60;\n    x = (x - (fourth as Field)) / (TWO_POW_60 as Field);\n    let x_fifth_u64 = (x as u64);\n    let fifth = x_fifth_u64 % TWO_POW_60;\n    (first, second, third, fourth, fifth)\n}\n\n// Decomposes a single field into two 120 bit fields\npub unconstrained fn split_120_bits(mut x: Field) -> (Field, Field) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_56 = ((x as u64) % TWO_POW_56) as Field;\n\n    let low = low_lower_64 + TWO_POW_64 * low_upper_56;\n    let high = (x - low_upper_56) / TWO_POW_56 as Field;\n\n    (low, high)\n}\n\n/// Decomposes a single field into two 60 bit fields\n///\n/// Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\nunconstrained fn __split_60_bits(x: Field) -> (u64, u64) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let x_lower_64 = (x as u64);\n    let low = x_lower_64 % TWO_POW_60;\n    let high = ((x - (low as Field)) / TWO_POW_60 as Field) as u64;\n\n    (low, high)\n}\n\n/// Decomposes a single field into two 60 bit fields\n///\n/// Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\npub fn split_60_bits(x: Field) -> (u64, u64) {\n    // We assert that the two returned limbs fit within 60 bits each\n    // and reconstruct `x` when added together.\n    let (lo, hi) = unsafe { __split_60_bits(x) };\n    if !std::runtime::is_unconstrained() {\n        let lo_field = lo as Field;\n        let hi_field = hi as Field;\n        lo_field.assert_max_bit_size::<60>();\n        hi_field.assert_max_bit_size::<60>();\n        assert_eq(lo_field + (TWO_POW_60 as Field) * hi_field, x);\n    }\n\n    (lo, hi)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [Field; N] {\n    let mut normalized: [Field; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[i] = lo;\n        next = input[i + 1] + hi;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n        normalized[range - 1] = lo;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/utils/split_bits.nr"},"206":{"source":"use crate::utils::msb::get_msb64;\nuse crate::utils::split_bits;\nuse crate::utils::split_bits::{field_to_u60rep, TWO_POW_60};\n\n/**\n * @brief U60Repr represents a BigNum element as a sequence of 60-bit unsigned integers.\n *\n * @description: used in unconstrained functions when computing witness values.\n * It is helpful to use u60 types when evaluating addition operations that can overflow the field modulus,\n * as well as when performing bit shifts.\n */\npub struct U60Repr<let N: u32, let NumSegments: u32> {\n    pub(crate) limbs: [u64; N * NumSegments],\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Add for U60Repr<N, NumSegments> {\n    fn add(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut carry: u64 = 0;\n        for i in 0..N * NumSegments {\n            let mut add: u64 = self.limbs[i] + b.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            result.limbs[i] = add;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Sub for U60Repr<N, NumSegments> {\n    fn sub(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        for i in 0..N * NumSegments {\n            borrow = ((b.limbs[i] + borrow_in) > self.limbs[i]) as u64;\n            let sub = (borrow << 60) + self.limbs[i] - b.limbs[i] - borrow_in;\n            result.limbs[i] = sub;\n            borrow_in = borrow;\n        }\n\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::From<[Field; N]> for U60Repr<N, NumSegments> {\n    fn from(input: [Field; N]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..N {\n            let (lo, hi) = split_bits::split_60_bits(input[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n}\n\n// impl<let N: u32, let NumSegments: u32> std::convert::From<Field> for U60Repr<N, NumSegments> {\n//     fn from(input: Field) -> Self {\n//        let (low, mid, high) =  unsafe { field_to_u60rep(input) } ;\n//         let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n//         let N_u60: u32 = N * NumSegments;\n//         assert(N_u60 >=1, \"N must be at least 1\");\n//         if N_u60 == 1 {\n//             assert((mid ==0) & (high == 0), \"input field is too large to fit in a single limb\");\n//             result.limbs[0] = low;\n//         }\n//         else if N_u60 == 2{\n//             assert(high == 0, \"input field is too large to fit in two limbs\");\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//         }else{\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//             result.limbs[2] = high;\n//         }\n//         result\n//     }\n// }\n\nimpl<let N: u32, let NumSegments: u32> std::convert::Into<[Field; N]> for U60Repr<N, NumSegments> {\n    fn into(x: U60Repr<N, NumSegments>) -> [Field; N] {\n        let mut result: [Field; N] = [0; N];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..N {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::cmp::Eq for U60Repr<N, NumSegments> {\n    fn eq(self, other: Self) -> bool {\n        self.limbs == other.limbs\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> U60Repr<N, NumSegments> {\n\n    pub(crate) fn new<let NumFieldSegments: u32>(x: [Field; N * NumFieldSegments]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N * NumFieldSegments) {\n            let (lo, hi) = split_bits::split_60_bits(x[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n\n    pub(crate) fn one() -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub(crate) unconstrained fn from_field(input: Field) -> Self {\n        let (first, second, third, fourth, fifth) = field_to_u60rep(input);\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        let N_u60: u32 = N * NumSegments;\n        assert(N_u60 >= 1, \"N must be at least 1\");\n        if N_u60 == 1 {\n            assert(\n                (second == 0) & (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in a single limb\",\n            );\n            result.limbs[0] = first;\n        } else if N_u60 == 2 {\n            assert(\n                (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in two limbs\",\n            );\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n        } else if N_u60 == 3 {\n            assert((fourth == 0) & (fifth == 0), \"input field is too large to fit in three limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n        } else if N_u60 == 4 {\n            assert((fifth == 0), \"input field is too large to fit in four limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n        } else {\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n            result.limbs[4] = fifth;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn into_field_array(\n        x: U60Repr<N, NumSegments>,\n    ) -> [Field; N * NumSegments / 2] {\n        let mut result: [Field; N * NumSegments / 2] = [0; N * NumSegments / 2];\n        for i in 0..(N * NumSegments / 2) {\n            result[i] =\n                x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * TWO_POW_60 as Field);\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn gte(self, b: Self) -> bool {\n        let mut result = false;\n        let mut early_exit = false;\n        for i in 0..(N * NumSegments) {\n            let idx = (N * NumSegments) - 1 - i;\n            if (b.limbs[idx] == self.limbs[idx]) {\n                continue;\n            }\n\n            result = b.limbs[idx] < self.limbs[idx];\n            early_exit = true;\n            break;\n        }\n        if early_exit {\n            result\n        } else {\n            self.limbs[0] == b.limbs[0]\n        }\n    }\n\n    pub(crate) fn get_bit(self, bit: u32) -> bool {\n        let segment_index = bit / 60;\n        let uint_index = bit % 60;\n\n        let limb: u64 = self.limbs[segment_index];\n        let value = (limb >> uint_index as u8) & 1;\n        value == 1\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift = (60 - limb_shift) as u8;\n        let mask: u64 = (((1 as u64) << limb_shift) - 1) << remainder_shift;\n        result.limbs[0] = (self.limbs[0 + num_shifted_limbs] >> limb_shift);\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i + num_shifted_limbs];\n            result.limbs[i] = value >> limb_shift;\n            let remainder: u64 = (value << remainder_shift) & mask;\n            result.limbs[i - 1] = result.limbs[i - 1] + remainder;\n        }\n        result\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr1(&mut self) {\n        let value = self.limbs[NumSegments * N - 1];\n        self.limbs[NumSegments * N - 1] = value >> 1;\n\n        let mut remainder = (value & 1) << 59;\n\n        for i in 0..N * NumSegments {\n            let value = self.limbs[N * NumSegments - 1 - i];\n            self.limbs[N * NumSegments - 1 - i] = (value >> 1) + remainder;\n            remainder = (value << 59) & 0x800000000000000;\n        }\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shl(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; NumSegments * N] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift: u8 = 60 - limb_shift as u8;\n\n        // 83\n        // limb shift = 1\n        // inside shift = 19 bits to the left\n        // meaning we have 19 carry bits and 41 remainder bits\n        let mask: u64 = (1 as u64 << 60) - 1;\n        //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        let value = self.limbs[0];\n\n        let mut remainder = (value >> remainder_shift);\n        result.limbs[num_shifted_limbs] = (value << limb_shift) & mask;\n\n        // shift 84. num shifted = 1\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i];\n            let upshift = ((value << limb_shift) + remainder) & mask;\n            result.limbs[i + num_shifted_limbs] = upshift;\n            remainder = (value >> remainder_shift);\n            // let remainder: u64 = (self.limbs.get(i + num_shifted_limbs as u64) << remainder_shift as u8) & mask;\n            // result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    pub(crate) fn increment(&mut self) {\n        let mut carry: u64 = 0;\n\n        let mut add: u64 = self.limbs[0] + 1;\n        carry = add >> 60;\n        add = add - (carry << 60);\n        self.limbs[0] = add;\n\n        for i in 1..NumSegments * N {\n            let mut add: u64 = self.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            self.limbs[i] = add;\n        }\n    }\n\n    pub(crate) unconstrained fn get_msb(val: Self) -> u32 {\n        let mut count = 0;\n        for i in 0..N * NumSegments {\n            let v = val.limbs[((N * NumSegments) - 1 - i)];\n            if (v > 0) {\n                count = 60 * ((N * NumSegments) - 1 - i) + get_msb64(v);\n                break;\n            }\n        }\n        count\n    }\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/utils/u60_representation.nr"},"209":{"source":"use dep::bignum::{params::BigNumParams, RuntimeBigNum};\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme.\n * @note The `exponent` can be either 65537 or 3 (i.e. the most common values in use for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    assert((exponent == 3) | (exponent == 65537), \"Exponent must be 65537 or 3\");\n    let mut exponentiated = sig * sig; // sig^2\n    if exponent == 65537 {\n        // e = 65537 = 1 0000 0000 0000 0001\n        exponentiated = exponentiated * exponentiated; // sig^4\n        exponentiated = exponentiated * exponentiated; // sig^8\n        exponentiated = exponentiated * exponentiated; // sig^16\n        exponentiated = exponentiated * exponentiated; // sig^32\n        exponentiated = exponentiated * exponentiated; // sig^64\n        exponentiated = exponentiated * exponentiated; // sig^128\n        exponentiated = exponentiated * exponentiated; // sig^256\n        exponentiated = exponentiated * exponentiated; // sig^512\n        exponentiated = exponentiated * exponentiated; // sig^1024\n        exponentiated = exponentiated * exponentiated; // sig^2048\n        exponentiated = exponentiated * exponentiated; // sig^4096\n        exponentiated = exponentiated * exponentiated; // sig^8192\n        exponentiated = exponentiated * exponentiated; // sig^16384\n        exponentiated = exponentiated * exponentiated; // sig^32768\n        exponentiated = exponentiated * exponentiated; // sig^65536\n    }\n    // otherwise, e = 3 = 11\n    exponentiated = exponentiated * sig; // either sig^2 * sig = sig^3 or sig^65536 * sig = sig^65537\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_1024() {\n    // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"hello world! test#123\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170,\n                193, 96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n            ],\n    );\n\n    let params: BigNumParams<9, 1024> = BigNumParams::new(\n        false,\n        [\n            0xab238ad9cb37979a43aefbf10be8fb,\n            0x31347febe45fe8c2dac1dd30900704,\n            0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n            0x5eac6390f7873fe97ff9bb14a173ea,\n            0xbc41f700c91fd733a2c63177bbdbd4,\n            0x41442bd58769a3595b659a2ec9c6be,\n            0x4ddc91395f330382aa2e2d3fbe147,\n            0x3d008ff255a0bc71c7887f5728ba1,\n            0xb640c3a8f511c64e,\n        ],\n        [\n            0x5d53d2634c6a0918266043968ce263,\n            0x5dd4be3dce0323a492ee9340aec4db,\n            0xf82d0e2e5c8319f01a460c72c01854,\n            0x236e6fc6e62e8a1d522acda5fb3892,\n            0xdaf755619d66e580901aa224d03174,\n            0x8366291616480e7e1f202dbcedda87,\n            0x40ba1202537d1e94561ccc05265586,\n            0x69b993d857ba89ea5de9822aeb4b93,\n            0x167968c0000761a273,\n        ],\n    );\n\n    let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xc3850e84ea02da3f028ff422f4d6a9,\n            0x9761f0bd9021f76d45c60df0670a19,\n            0xc1ede421a43607ab623ed4d5a17fc8,\n            0x86197b4315206f4d53200b42555831,\n            0xe95783b69db28c26a83706f39d04cd,\n            0x18b178dc1a9ec76fb22b57e4dfa703,\n            0xdd0e19cd5a09ab48e7af4d0e3470e3,\n            0x10004dfab1cf91304e80e6baa4dfc7,\n            0x241c3fd77b90adef,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048() {\n    // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"Hello World! This is Noir-RSA\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131,\n                166, 79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n            ],\n    );\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n            0xbfb937fc4d3cf02cc0af780f3cab44,\n            0xd20637ef7adcf5d238ee87bccc9bca,\n            0xb9db4f2663108e2f8b673f7612ae8b,\n            0x85f894ef669b36bfd3d86b0a28873,\n            0xdcc70e1884e38b8229cce3b884121d,\n            0x35488d1138e0b03e1676f7f5d8a5b3,\n            0xe1a97820e7dcbb4eab35c9b71bb273,\n            0x97d19eb3c63249ddbfcff915863f54,\n            0x3a78c7af6da0f6af0d67b1ca4b6065,\n            0xd7a3c433c020f624821e5e678c7d69,\n            0x52d5b53240feae82ffea3d2a3d9b09,\n            0xb8aad5e19e2163f68997c6fdd71906,\n            0x5db432d06e8b0bf59511100c7894e2,\n            0xadc0bbc4c54da10d1cc88438ea3127,\n            0xece1cf6a1501109cd2734d5893c8d9,\n            0x7196b90acdf06c31b1288064fd0c27,\n            0xc8,\n        ],\n        [\n            0x1b1deccf4dbde852c34a5d6908a0f,\n            0xbc9e5bdab22f023fbcca58692bccf5,\n            0x1f65439685623e45396ff55751c3bf,\n            0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n            0x5ca2e8e3048243c16c708a8030ab0d,\n            0x30079bfeb1fa51e5501581173ca19c,\n            0xff8d5f6bea485fdcc2716327f69ab4,\n            0x36b599d81589416b5b5f037986b999,\n            0x75612e34a4ff29f0a19a7823512f58,\n            0x288b6897929b54c3b26a5faa07c00f,\n            0x4b5675fa13ab7444f1f047d3eb1bbe,\n            0x6ba0ac610ef9f267ab30fe25bb1c84,\n            0xa386b48ee03168d5cea3ecb9dc901f,\n            0xacf1a01f7dba44e050c976142fb1f6,\n            0x97a63b5cb7efc60d3502946aec63cf,\n            0x12cc1d5cab10a1e9e2398d29b9e3ef,\n            0x4635cf25c66e76bba8034df46204fb,\n            0x146f,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xad29e07d16a278de49a371b9760a27,\n            0x86311920cc0e17a3c20cdff4c56dbb,\n            0x863556c6c5247dd83668dd825716ae,\n            0xc247c960945f4485b46c33b87425ca,\n            0x7326463c5c4cd5b08e21b938d9ed9a,\n            0x4f89fe0c82da08a0259eddb34d0da1,\n            0x43a74e76d4e1bd2666f1591889af0d,\n            0x240f7b80f0ff29f4253ee3019f832d,\n            0xc6edd131fbaaf725fd423dac52b362,\n            0x85f9732679242163e8afff44f6104d,\n            0xd3c3bbcb1757013fd6fb80f31dd9a6,\n            0x9008633f15df440e6df6d21ee585a2,\n            0x324df3425ed256e283be5b6b761741,\n            0xc60c1302929bd0e07caa4aeff4e8fd,\n            0x600d804ff13ba8d0e1bc9508714212,\n            0x50f7e75e5751d7edd61167027926be,\n            0x0db41d39442023e1420a8a84fe81d9,\n            0xab,\n        ],\n    };\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n    // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"hello world\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132,\n                239, 227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n            ],\n    );\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0xe40ee47801326543c8e84b85d567c1,\n            0x5b54ea87f0ce29de1995697b0696fd,\n            0x457078f8fdce68b437cac0970b2452,\n            0x473ec776fee3731b6ab06e35875ddc,\n            0x62dedd594e5f12c80c3ccb5791a6cd,\n            0xecb934b9d8272c5e3a418145345499,\n            0xd1af643b3d785470ed0c6cd633f706,\n            0xb58a57b9e96eccbdfc7c17f0333d4,\n            0x2ebd34b5039fc596504927c282c60d,\n            0x3a44928a74f25fc1043bb37ce4dfa8,\n            0x91448459f9617fac33a2816162ac9e,\n            0x70cb910d9f3e1a78864640ec6c8240,\n            0x9aed33f6b31f1c9de67248a98c180,\n            0x7f1416e032c79488c94b311e87bd9c,\n            0x7191b4ebb1b3fffa949fa48ed01e5,\n            0x350a75cbaeca6bfdd71ca83cdbcae9,\n            0xfb1d274fa207457c6814d42c09f9cf,\n            0xd4,\n        ],\n        [\n            0x803bf4d38110a7d37fdd05f590dee9,\n            0xa68d317c933f37cab5ab4e7c00a3b9,\n            0x476a05a536bf5f2aa1b8850146cba7,\n            0xca297ea8b5528d91d4836ff27c30ab,\n            0x75cf2eaab76eefa12bbd570f1aea9f,\n            0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n            0xd497db1f6ebe83decacaa647fabea6,\n            0x686b27ca330e25e7a7cf197f6433ef,\n            0xfde04d2225c8308b07580af0058a0f,\n            0xa29fb69777c0e916976243b2b09855,\n            0xf983592285852e7e1c2cb3ae968323,\n            0x673608017f9f5acf67a01b73728d70,\n            0xeeff82521c0bc432a05f4b7444fac0,\n            0x85a89c4d229f60aaa3aa7ac7dac1e2,\n            0xcfecff93bc9fbfe0d6dff6091f2db8,\n            0xf20f047dcb224b4447bd098c07f8c2,\n            0x554bb53cadeb3eaab911a189f90227,\n            0x133b,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xa250eff812c63eaaeaa3f04641c05f,\n            0xecc09613cb8b289c1f37c8f92e6a05,\n            0x2c0a0510058360c07af65d46f594fd,\n            0x943d67513363d3de430c94a1dafe7c,\n            0x511ec8e9b10bc6c6ff0d6c232ccf92,\n            0x50ffd07b3c093b3f5fc027de847731,\n            0xc268e1489449943fdafdf89ff168c3,\n            0x0b8b7f9f49b492f78fda58d252f23a,\n            0x491c6c4ef836a6a8730b7bf81e865e,\n            0x8746c75fb079d014e419543f56d7f0,\n            0x65804c417d6168a8bc0025d255cebf,\n            0xf695e91b77890b8e3fd775fa56e627,\n            0x5e90001c0218550f4083ae28025a2f,\n            0x526bd4eff34f25f62a698f0470e0a6,\n            0x7f224306a7d9daf536b1559434c6c6,\n            0x88809f16fe1fcea3c87511d9319735,\n            0x7694685fee0bfab4a9196b92ec6f2e,\n            0xa7,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir_rsa/v0.5.1/lib/src/rsa.nr"}},"names":["main"],"brillig_names":["build_msg_block_iter","pad_msg_block","attach_len_to_msg_block","__mul","__compute_quadratic_expression_with_borrow_flags","extract_claim_unconstrained","__boundary_check","__validate_decoded","search","get_lt_predicate_f","extract_claim_unconstrained","get_domain_start_index_in_email","__split_60_bits","__mul","__compute_quadratic_expression_with_borrow_flags","decompose_hint","is_position_found_in_email_body","is_salary_found_in_email_body","directive_integer_quotient","directive_invert","directive_to_radix"]}