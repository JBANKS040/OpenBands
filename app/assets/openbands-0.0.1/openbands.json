{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":4825609713880094386,"abi":{"parameters":[{"name":"partial_data","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":640,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"partial_hash","type":{"kind":"array","length":8,"type":{"kind":"integer","sign":"unsigned","width":32}},"visibility":"private"},{"name":"full_data_length","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"base64_decode_offset","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"jwt_pubkey_modulus_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"public"},{"name":"jwt_pubkey_redc_params_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"jwt_signature_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"domain","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"},{"name":"position","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":128,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"},{"name":"salary","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"},{"name":"work_life_balance","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"culture_values","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"career_growth","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"compensation_benefits","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"leadership_quality","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"operational_efficiency","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"header","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":512,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"body","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":1024,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"pubkey","type":{"kind":"struct","path":"zkemail::dkim::RSAPubkey","fields":[{"name":"modulus","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"redc","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"body_hash_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"dkim_header_sequence","type":{"kind":"struct","path":"zkemail::Sequence","fields":[{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"}],"return_type":null,"error_types":{"1745191622261247408":{"error_kind":"string","string":"rating must be at least 1"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3951064283418873378":{"error_kind":"fmtstring","length":123,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32}]},"4118337510742699159":{"error_kind":"string","string":"No ';' suffix found at asserted bh index"},"4128061241751547076":{"error_kind":"string","string":"Position can not be found in email body"},"4524007320076231485":{"error_kind":"string","string":"Header field out of bounds of header"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5466606472443271855":{"error_kind":"string","string":"Header field must not contain newlines"},"5634341720269277520":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":32}]},"5675127253506927136":{"error_kind":"string","string":"utils::search could not find needle in haystack"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6314603625877298116":{"error_kind":"string","string":"haystack length of size 0 not supported"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6543056410826478903":{"error_kind":"string","string":"incorrect value for claim"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7788270038095378938":{"error_kind":"string","string":"substring not present in main text (match found if a padding text included. is main text correctly formatted?)"},"8133541709288850676":{"error_kind":"string","string":"No ':bh=' or '; bh=' prefix found before body hash"},"8386845565670372523":{"error_kind":"string","string":"SHA256 hash computed over body does not match body hash found in DKIM-signed header"},"8397817944888091498":{"error_kind":"string","string":"rating must be at most 5"},"9281715815618326061":{"error_kind":"string","string":"invalid domain"},"9619408434855056367":{"error_kind":"string","string":"Header field name must be followed by a colon"},"10713088778935619315":{"error_kind":"string","string":"char before domain is not '@'"},"11883698362854120768":{"error_kind":"string","string":"Header field must start with CRLF"},"12712340723692189130":{"error_kind":"string","string":"Header field name does not match"},"13815800804469369678":{"error_kind":"string","string":"partial_data length is too long"},"14044520943542572812":{"error_kind":"string","string":"Salary can not be found in email body"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14304927234259905409":{"error_kind":"fmtstring","length":129,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32}]},"14734181347393705282":{"error_kind":"string","string":"Header field must end with CRLF"},"15412340888643424233":{"error_kind":"string","string":"needle length of size 0 not supported"},"15512795827244806757":{"error_kind":"string","string":"Body hash index accessed outside of DKIM header field"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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ampjNbUfNbW5mtoKTa1RoOdapyDPtf6aWpimNldTW6epHdTUrmpqKQr959+94w/u+GVE0xb22otCnv+7iIX/82/p9+fKLwkdlt1ei1zY838XVVNLqHnOxJr/LqmmllHznJk1/11WTc1P85wBmv8uUFMrpXnOMpr/rpymVkvznJ9r/ru6mlozzXO20Px3rTS1Lprn7Kb573poaoM0zzlE898N09RCNc85XvPfTdDUZmqec7bmv5ujqS3TPOcKzX+3SlPbonnObZr/boemdkTznMc0/90JTe2K5jmvaf67G5raE81zPtP8dy80tYhFPD9n5CKe/7uomlpCzXMm1vx3STW15JpaSk0ttaaWVlNLr6ll1NQya2pZNbXsmlpOTS23ppZXU3Noan6aWoCmFqj5uDd01qbNS7sy1bWIX9prjTS1xppaE02tqabWTFNrrqm10NRaamqtNLXWmlobTa2tpva1ptZOU2uvqXXQ1Dpqap00tW80tc6aWhdNraum1k1T666p9dDUempq32pqvTS13ppaH02tr6bWT1P7TlPrr6kN0NQGamqDNLXBmtoQTW2opjZMUxuuqY3Q1EZqaqM0tdGa2vea2hhNbaymFqyphWhqoZraeE1tgqb2g6b2o6Y2WVObqqlN19RmamqzNbU5mtovmtqvmtoCTW2RprZEU1umqa3Q1FZpaqs1tbWa2u+a2gZNbZOmtkVT26ap7dDUdmlqezS1fZraAU3tkKZ2RFM7pqm909Tea2ofNLWPmtoff0DdQ+0zTS2iphZJU4usqUXR1KJqatE0teiaWgxNLaamFktTi62pxdHU4mpq8TS1+JpaAk0toaaWSFNLrKkl0dSSamrJNLXkmloKTS2lppZKU0utqaXR1NJqauk0tfSaWgZNLaOmlklTy6ypZdHUsmpq2TS17JpaDk0tp6aWS1PLranl0dTyamr5NDVLU/PX1PJrakGaWkFNrbCmVlRTK66pldTUSmtqZTW18ppaRU2tsqZWVVOrrqnV1NRqa2p1NLV6mlp9Ta2BptZQU2usqTXV1Jprai01tdaaWltNrZ2m1kFT66SpddbUumpqP2lqkzW1KZraVE1tmqY2XVOboanN1NRmaWqzNbWfNbU5mtpcTe0XTW2epvarpjZfU1ugqS3U1BZpaos1tSWa2lJNbZmmtlxTW6GprdTUVmlqv2lqqzW1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tubmbramLOS227e737am7Grlt6bcoXzUlHdvzy1tTdlrbltTdue2NeVSzW1ryu5ma8ruZmvKQm5bU3Y1W1MWctuasqvZmrKQ29aU3bltTdnVbE1Z6LetKbuarbm5m625uZutKQu57fbt7retKbta+a0pdywfNeXd28V5tqbsNbetKbtz25pyqea2NWV3szVld7M1ZSG3rSm7mq0pC7ltTdnVbE1ZyG1ryu7ctqbsaramLPTb1pRdzdbc3M3W3NzN1pSF3Hb7dvfb1pRdrfzWlDuVj5ry7m2ura0pe81ta8ru3LamXKq5bU3Z3WxN2d1sTVnIbWvKrmZrykJuW1N2NVtTFnLbmrI7t60pu5qtKQv9tjVlV7M1N3ezNTd3szVlIbfdvt39tjVlVyu/NeUu5aOmvHtfaW9ryl5z25qyO7etKZdqbltTdjdbU3Y3W1MWctuasqvZmrKQ29aUXc3WlIXctqbszm1ryq5ma8pCv21N2dVszc3dbM3N3WxNWchtt293v21N2dXKb025W/moKeeEc3S0NWWvuW1N2Z3b1pRLNbetKbubrSm7m60pC7ltTdnVbE1ZyG1ryq5ma8pCbltTdue2NWVXszVlod+2puxqtubmbrbm5m62pizkttu3u9+2puxq5bem3KN81JRzwzk625qy19y2puzObWvKpZrb1pTdzdaU3c3WlIXctqbsaramLOS2NWVXszVlIbetKbtz25qyq9mastBvW1N2NVtzczdbc3M3W1MWctvt291vW1N2tfJbU+5ZPmrKu891utmastfctqbszm1ryqWa29aU3c3WlN3N1pSF3Lam7Gq2pizktjVlV7M1ZSG3rSm7c9uasqvZmrLQb1tTdjVbc3M3W3NzN1tTFnLb7dvdb1tTdrXyW1PuVT5qyrvrPBfZmnK6t2ZrykJuW1Mu1dy2puxutqbsbramLOS2NWVXszVlIbetKbuarSkLuW1N2Z3b1pRdzdaUhX7bmrKr2Zqbu9mam7vZmrKQ227f7n7bmrKrld+acn75qCnvHj962Zqy19y2puzObWvKpZrb1pTdzdaU3c3WlIXctqbsaramLOS2NWVXszVlIbetKbtz25qyq9mastBvW1N2NVtzczdbc3M3W1MWctvt291vW1N2tfJbU+5TPmrKu4+9Bbam7DW3rSm7c9uacqnmtjVld7M1ZXezNWUht60pu5qtKQu5bU3Z1WxNWchta8ru3Lam7Gq2piz029aUXc3W3NzN1tzczdaUhdx2+3b329aUXa381pT7lY+a8u5118/WlL3mtjVld25bUy7V3Lam7G62puxutqYs5LY1ZVezNWUht60pu5qtKQu5bU3ZndvWlF3N1pSFftuasqvZmpu72Zqbu9maspDbbt/uftuasquV35py//JRU969fC+xNWWvuW1N2Z3b1pRLNbetKbubrSm7m60pC7ltTdnVbE1ZyG1ryq5ma8pCbltTdue2NWVXszVlod+2puxqtubmbrbm5m62pizkttu3u9+2puxq5bemPKB81JR37+MDbU3Za25bU3bntjXlUs1ta8ruZmvK7mZrykJuW1N2NVtTFnLbmrKr2ZqykNvWlN25bU3Z1WxNWei3rSm7mq25uZutubmbrSkLue327e63rSm7WvmtKQ8sFzXljN25B9uastfctqbszm1ryqWa29aU3c3WlN3N1pSF3Lam7Gq2pizktjVlV7M1ZSG3rSm7c9uasqvZmrLQb1tTdjVbc3M3W3NzN1tTFnLb7dvdb1tTdrXyW1MeVD5qyrtrA0NtTdlrbltTdue2NeVSzW1ryu5ma8ruZmvKQm5bU3Y1W1MWctuasqvZmrKQ29aU3bltTdnVbE1Z6LetKbuarbm5m625uZutKQu57fbt7retKbta+a0pDykfNeXdy+BKW1P2mtvWlN25bU25VHPbmrK72Zqyu9maspDb1pRdzdaUhdy2puxqtqYs5LY1ZXduW1N2NVtTFvpta8quZmtu7mZrbu5ma8pCbrt9u/tta8quVn5rykPLR0159/Y8wtaUvea2NWV3bltTLtXctqbsbram7G62pizktjVlV7M1ZSG3rSm7mq0pC7ltTdmd29aUXc3WlIV+25qyq9mam7vZmpu72ZqykNtu3+5+25qyq5XfmvKw8lFT3r1dXGNryl5z25qyO7etKZdqbltTdjdbU3Y3W1MWctuasqvZmrKQ29aUXc3WlIXctqbszm1ryq5ma8pCv21N2dVszc3dbM3N3WxNWchtt293v21N2dXKb015ePmoKe/e5kK2puw1t60pu3PbmnKp5rY1ZXezNWV3szVlIbetKbuarSkLuW1N2dVsTVnIbWvK7ty2puxqtqYs9NvWlF3N1tzczdbc3M3WlIXcdvt299vWlF2t/NaUR5SPmvLufeV6W1P2mtvWlN25bU25VHPbmrK72Zqyu9maspDb1pRdzdaUhdy2puxqtqYs5LY1ZXduW1N2NVtTFvpta8quZmtu7mZrbu5ma8pCbrt9u/tta8quVn5ryiPLR005J5xjrK0pe81ta8ru3LamXKq5bU3Z3WxN2d1sTVnIbWvKrmZrykJuW1N2NVtTFnLbmrI7t60pu5qtKQv9tjVlV7M1N3ezNTd3szVlIbfdvt39tjVlVyu/NeVR5aOmnBvOcZOtKXvNbWvK7ty2plyquW1N2d1sTdndbE1ZyG1ryq5ma8pCbltTdjVbUxZy25qyO7etKbuarSkL/bY1ZVezNTd3szU3d7M1ZSG33b7d/bY1ZVcrvzXlUPmoKe8+15lga8pec9uasju3rSmXam5bU3Y3W1N2N1tTFnLbmrKr2ZqykNvWlF3N1pSF3Lam7M5ta8quZmvKQr9tTdnVbM3N3WzNzd1sTVnIbbdvd79tTdnVym9NeXT5qCnvrvPcamvKXnPbmrI7t60pl2puW1N2N1tTdjdbUxZy25qyq9maspDb1pRdzdaUhdy2puzObWvKrmZrykK/bU3Z1WzNzd1szc3dbE1ZyG23b3e/bU3Z1cpvTXlM+agp7x4/Jtuastfctqbszm1ryqWa29aU3c3WlN3N1pSF3Lam7Gq2pizktjVlV7M1ZSG3rSm7c9uasqvZmrLQb1tTdjVbc3M3W3NzN1tTFnLb7dvdb1tTdrXyW1MeWz5qyruPvXfYmrLX3Lam7M5ta8qlmtvWlN3N1pTdzdaUhdy2puxqtqYs5LY1ZVezNWUht60pu3PbmrKr2Zqy0G9bU3Y1W3NzN1tzczdbUxZy2+3b3W9bU3a18ltTHlc+asq71900W1P2mtvWlN25bU25VHPbmrK72Zqyu9maspDb1pRdzdaUhdy2puxqtqYs5LY1ZXduW1N2NVtTFvpta8quZmtu7mZrbu5ma8pCbrt9u/tta8quVn5ryuPLR0159/K929aUvea2NWV3bltTLtXctqbsbram7G62pizktjVlV7M1ZSG3rSm7mq0pC7ltTdmd29aUXc3WlIV+25qyq9mam7vZmpu72ZqykNtu3+5+25qyq5XfmvKE8lFT3r2Pz7Q1Za+5bU3ZndvWlEs1t60pu5utKbubrSkLuW1N2dVsTVnIbWvKrmZrykJuW1N257Y1ZVezNWWh37am7Gq25uZutubmbramLOS227e737am7Grlt6Y8sVzUlP8dm+6zNWWvuW1N2Z3b1pRLNbetKbubrSm7m60pC7ltTdnVbE1ZyG1ryq5ma8pCbltTdue2NWVXszVlod+2puxqtubmbrbm5m62pizkttu3u9+2puxq5bemPKl81JR31wbm2Jqy19y2puzObWvKpZrb1pTdzdaU3c3WlIXctqbsaramLOS2NWVXszVlIbetKbtz25qyq9mastBvW1N2NVtzczdbc3M3W1MWctvt291vW1N2tfJbU55cPmrKu5fBg7am7DW3rSm7c9uacqnmtjVld7M1ZXezNWUht60pu5qtKQu5bU3Z1WxNWchta8ru3Lam7Gq2piz029aUXc3W3NzN1tzczdaUhdx2+3b329aUXa381pSnlI+a8u7teb6tKXvNbWvK7ty2plyquW1N2d1sTdndbE1ZyG1ryq5ma8pCbltTdjVbUxZy25qyO7etKbuarSkL/bY1ZVezNTd3szU3d7M1ZSG33b7d/bY1ZVcrvzXlqeWjprx7u3jE1pS95rY1ZXduW1Mu1dy2puxutqbsbramLOS2NWVXszVlIbetKbuarSkLuW1N2Z3b1pRdzdaUhX7bmrKr2Zqbu9mam7vZmrKQ227f7n7bmrKrld+a8rTyUVPevc0tsjVlr7ltTdmd29aUSzW3rSm7m60pu5utKQu5bU3Z1WxNWchta8quZmvKQm5bU3bntjVlV7M1ZaHftqbsarbm5m625uZutqYs5Lbbt7vftqbsauW3pjy9fNSUd+8rj9uastfctqbszm1ryqWa29aU3c3WlN3N1pSF3Lam7Gq2pizktjVlV7M1ZSG3rSm7c9uasqvZmrLQb1tTdjVbc3M3W3NzN1tTFnLb7dvdb1tTdrXyW1OeUT5qyjnhHG/bmrLX3Lam7M5ta8qlmtvWlN3N1pTdzdaUhdy2puxqtqYs5LY1ZVezNWUht60pu3PbmrKr2Zqy0G9bU3Y1W3NzN1tzczdbUxZy2+3b3W9bU3a18ltTnlk+asq54Rzv2pqy19y2puzObWvKpZrb1pTdzdaU3c3WlIXctqbsaramLOS2NWVXszVlIbetKbtz25qyq9mastBvW1N2NVtzczdbc3M3W1MWctvt291vW1N2tfJbU55VPmrKu891ttqastfc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","debug_symbols":"7P3NjiTJ1l0Jvss35kDlX4Sv0mg02F2sBoEC2WiyRgTfvSwKGZEXcE3dVYDRYi14zPJeODKXe4SfvfWIyrL//m//y3/8f//v/9//13/6z//rf/mv//bv/x///d/+t//y//kP/+0//Zf//Ppf//3fat/X//n//tf/33/4zz/+j//63/7D//+//du/7/3Uf/dv//E//y+vf1x1/Y9/92//63/63/7jv/37Wf7Hv/vyxW3W668vbnP8yxev//H//Hc//hPlf/5/ov7P/0+0//n/iX77n1it/fpP9Pb8n+h9/PxP9NnHv/4nvn7x3Nf564vnrvvvL95/8QwYz4TxLBjP/jTP/vmXf55rfuU5LJ5zwXgKjKd+lmfV+pPnNTvrV54G4+kwngHjmTCeBePZMJ6D4hnXBeMpMB7WfB4Xaz6PizWfx8Waz+NizedxsebzuFjzeVyw+Vxg87nA5nOBzecCm88FNp8LbD4X2HwusPlcYPO5wOZzhc3nCpvPFTafK2w+V9h8rrD5XGHzucLmc4XN5wqbzw02nxtsPjfYfG6w+dxg87nB5nODzecGm88NNp8bbD532HzusPncYfO5w+Zzh83nDpvPHTafO2w+d9h87rD5PGDzecDm84DN5wGbzwM2nwdsPg/YfB6w+Tw+Pp/3+snTSvnKc1g884LxFBjPp+fz6wTwJ89Y17/yfP3i19/98dcXv/5pfoVvZPiy+y/46/oK383wwww/zfDL8gvb91f4bYY/Yvh1meGLGV6TsHfw6IRN8OiETfDohE3w6IRN8OaEXeaEXeaE3eaE3eaE3eaE3eaE/fTt4PfCmxN2mxN2mxN2mxN2mxP2mBP2mBP2mBP2mBP24/e73wpvTthjTthjTthjTtgjTth5iRN2XuKEnZc4YeclTth5iRN2XuKEnZc4YeclTth5iRN2XuaELeaELeaELeaELeaE/bhj4a3w5oQt5oQt5oQt5oQt5oSt5oSt5oSt5oSt5oT9uCXjrfDmhK3mhK3mhK3mhK3mhG3mhG3mhG3mhG3mhP245+SN96RmE9/WmU18W2c2dMImeHTCJnhzwnZzwnZzwnZzwnZNwt6E1MdNNf/34Pf8Cd+u+hWe/Qwb4NnPsAGe/Qwb4NnPsAEenbChHgx0wiZ4dMImeHTCJnjzM+zHXUNvhTdviYd5SzzMW+Jh3hIPzTPsTZ+f7GfY524z2c+wAZ79DBvg2Qkb4NkJG+DNW2Kz02mynU4J3rwlNjudptnpNM1Op2l2Ok2z02manU7T43S66fNwp9Nzt4E7nQK8eUsMdzo9w8OdTgHevCVmO50SvNhLPNlOpwRv3hKbnU7T7HSaZqfTNDudptnpND1Op5s+D3c6PXcbuNMpwKMTNsGb33SCO50CvHlLzHY6JXjxm06L7XRK8OIt8TI7nZbZ6bQudsIGePEz7DI7nZbH6fS1zy+40+mx2yy40+kZHu50CvDiN50W3OkU4MVb4sV2OiV48ZtOi+10SvDiLfEyO52W2em0zE6nZXY6LbPTaXmcTjd9Hu50eu42cKdTgBdviRfc6RTgzc+wbKdTKGZsp1OCF7/ptNhOpwRv3hJ7nE538OYtMdvplODNz7Bsp1OCF9+HXXCn03O3gTudArx5Swx3OgV4dsIGePOWmO10SvDiN50W2+mU4M1bYrbTKcGbt8Rsp1OCNz/Dmp1Oy+N0uunzcKfTc7eBO50CvHlLDHc6PcObnU6L7XQKxYztdErw5jed2E6nBG/eErOdTgnevCVmO50SvPkZ1ux0Wh6n002fhzudnrsN3OkU4NEJm+DNbzqZnU6L7XQKxYztdErw5jed2E6nBG/eErOdTgnevCVmO50SvPkZ1ux0Wh6n002fhzudnrsN3On0DA93OgV485tOZqfTYjudQjFjO50SvPlNJ7bTKcGbt8Rsp1OCF2+JN9vplODFz7Db7HTaHqfT1z6/L3TCPnebDXc6BXjxlnjDnU4BXvwMu9lOp+dittlOpwQvftNps51OCV68Jd5sp1OCF2+JN9vplODFz7Db7HTaHqfTTZ+HO52euw3c6RTgxVviDXc6BXh2wgZ48ZZ4s51OCV78ptNmO50SvHlLzHY6JXjzlpjtdErw5mdYs9Npe5xON30e7nR67jZwp1OAN2+J4U6nZ3iz02mznU6hmLGdTgle/KbTZjudErx5S8x2OiV485aY7XRK8OZnWLPTaXucTjd9Hu50eu42cKdTgEcnbII3v+lkdjptttMpFDO20ynBm990YjudErx5S8x2OiV485aY7XRK8OZnWLPTaXucTjd9Hu50eu42cKfTMzzc6RTgzW86mZ1Om+10CsWM7XRK8OY3ndhOpwRv3hKznU4J3rwlZjudErz5GdbsdNoep9NNn4c7nZ67DdzpFODNW2K40ynAm59h2U6nUMzYTqcEb37Tie10SvDmLTHb6ZTgzVtittMpwZufYc1Op+1xOn3t8wfudHrsNgfudArw4i3xgTudAjw7YQO8eEt82E6nBC9+0+mwnU4JXrwlPmynU4IXb4kP2+mU4MXPsMfsdDoep9NNn4c7nZ67DdzpFODFW+IDdzo9w5udToftdArFjO10SvDiN50O2+mU4MVb4sN2OiV48Zb4sJ1OCd78DGt2Oh2P0+mmz8OdTs/dBu50CvDohE3w4jedjtnpdNhOp1DM2E6nBC9+0+mwnU4J3rwlZjudErx5S8x2OiV48zOs2el0PE6nmz4Pdzo9dxu40+kZHu50CvDmN53MTqfDdjqFYsZ2OiV485tObKdTgjdvidlOpwRv3hKznU4J3vwMa3Y6HY/T6abPw51Oz90G7nQK8OYtMdzpFODNz7Bsp1MoZmynU4I3v+nEdjolePOWmO10SvDmLTHb6ZTgzc+wZqfT8Tidbvo83On03G3gTqcAb94Sw51OAZ6dsAHevCVmO50SvPlNJ7bTKcGbt8Rsp1OCN2+J2U6nBG9+hjU7nY7H6XTT5+FOp+duA3c6BXjzlhjudHqCb5fY6fSC926JX/DeLfEL3vum0wsenbAJ3rslfsF7t8QveO+W+AXv3RK/4L3PsO0SO51e8N77sC9475b4Be/dEr/g0Qmb4L1vOr3gvc+wL3jvlvgF790Sv+C9bzq9/iJ533R6wXu3xC9475b4Be/dEr/g2Qkb4M3PsGKn0wveex/2Be/dEr/+H/OWGO50CvDeN51e8OZnWLbTKRQzttMpwXvfdHrBe990esGbt8Rsp1OCN2+J2U6nBG9+hhU7nV7w3vuwL3h0woZuA3c6BXjzlhjudArw5mdYttMpFDO20ynBm990YjudErx5S8x2OiV485aY7XRK8OZnWLHT6QXvvQ/bLrjT6bnbwJ1OAd68JYY7nQI8O2EDvHlLzHY6JXjzm05sp1OCN2+J2U6nBG/eErOdTgne/Awrdjq94L33YV/w5i0x3OkU4M1bYrjT6Rle7HR6wZu3xGynU4I3v+nEdjolePOWmO10SvDmLTHb6ZTgzc+wYqfTC958HxbudHruNnCnU4BHJ2yCN7/pJHY6veDNW2K20ynBi990KmynU4IXb4kL2+mU4MVb4nKxEzbAi59hi9npVDxOp699vsCdTo/dpsCdTs/wcKdTgBe/6VTMTqfCdjqFYsZ2OiV48ZtOhe10SvDiLXFhO50SvHhLXNhOpwRvfoY1O52Kx+l00+fhTqfnbgN3OgV48Za4wJ1OAd78DMt2OoVixnY6JXjxm06F7XRK8OYtMdvplODNW2K20ynBm59hzU6n4nE63fR5uNPpudvAnU4B3rwlhjudAjw7YQO8eUvMdjolePGbToXtdErw5i0x2+mU4M1bYrbTKcGbn2HNTqficTrd9Hm40+m528CdTgHevCWGO52e4c1Op8J2OoVixnY6JXjzm05sp1OCN2+J2U6nBG/eErOdTgne/AxrdjoVj9Ppps/DnU7P3QbudArw6IRN8OY3ncxOp8J2OoVixnY6JXjzm05sp1OCN2+J2U6nBG/eErOdTgne/AxrdjoVj9Ppps/DnU7P3QbudHqGhzudArz5TSez06mwnU6hmLGdTgne/KYT2+mU4M1bYrbTKcGLt8SV7XRK8OJn2Gp2OlWP0+lrn68XOmGfu02FO50CvHhLXOFOpwAvfoatbKfTczGrbKdTghe/6VTZTqcEL94SV7bTKcGLt8SV7XRK8OJn2Gp2OlWP0+mmz8OdTs/dBu50CvDiLXGFO50CPDthA7x4S1zZTqcEL37TqbKdTgnevCVmO50SvHlLzHY6JXjzM6zZ6VQ9TqebPg93Oj13G7jTKcCbt8Rwp9MzvNnpVNlOp1DM2E6nBC9+06mynU4J3rwlZjudErx5S8x2OiV48zOs2elUPU6nmz4Pdzo9dxu40ynAoxM2wZvfdDI7nSrb6RSKGdvplODNbzqxnU4J3rwlZjudErx5S8x2OiV48zOs2elUPU6nmz4Pdzo9dxu40+kZHu50CvDmN53MTqfKdjqFYsZ2OiV485tObKdTgjdvidlOpwRv3hKznU4J3vwMa3Y6VY/T6abPw51Oz90G7nQK8OYtMdzpFODNz7Bsp1MoZmynU4I3v+nEdjolePOWmO10SvDmLTHb6ZTgzc+wZqdT9Tidvvb5Bnc6PXabBnc6BXjxlrjBnU4Bnp2wAV68JW5sp1OCF7/p1NhOpwQv3hI3ttMpwYu3xI3tdErw4mfYZnY6NY/T6abPw51Oz90G7nQK8OItcYM7nZ7hzU6nxnY6hWLGdjolePGbTo3tdErw4i1xYzudErx4S9zYTqcEb36GNTudmsfpdNPn4U6n524DdzoFeHTCJnjxm07N7HRqbKdTKGZsp1OCF7/p1NhOpwRv3hKznU4J3rwlZjudErz5GdbsdGoep9NNn4c7nZ67Ddzp9AwPdzoFePObTmanU2M7nUIxYzudErz5TSe20ynBm7fEbKdTgjdvidlOpwRvfoY1O52ax+l00+fhTqfnbgN3OgV485YY7nQK8OZnWLbTKRQzttMpwZvfdGI7nRK8eUvMdjolePOWmO10SvDmZ1iz06l5nE43fR7udHruNnCnU4A3b4nhTqcAz07YAG/eErOdTgne/KYT2+mU4M1bYrbTKcGbt8Rsp1OCNz/Dmp1OzeN0uunzcKfTc7eBO50CvHlLDHc6PcJ3s9Ops51Oz8Wss51OCV78plO/0Amb4MVb4s52OiV48Za4s51OCV78DNvNTqfucTp97fMd7nR67jZwp1OARydsghe/6dTNTqfOdjqFYsZ2OiV48ZtOne10SvDiLXFnO50SvHhL3NlOpwRvfoY1O526x+l00+fhTqfnbgN3Oj3Dw51OAV78plM3O5062+kUihnb6ZTgxW86dbbTKcGbt8Rsp1OCN2+J2U6nBG9+hjU7nbrH6XTT5+FOp+duA3c6BXjzlhjudArw5mdYttMpFDO20ynBm990YjudErx5S8x2OiV485aY7XRK8OZnWLPTqXucTjd9Hu50eu42cKdTgDdvieFOpwDPTtgAb94Ss51OCd78phPb6ZTgzVtittMpwZu3xGynU4I3P8OanU7d43S66fNwp9Nzt4E7nQK8eUsMdzo9w5udTp3tdArFjO10SvDmN53YTqcEb94Ss51OCd68JWY7nRK8+RnW7HTqHqfTTZ+HO52euw3c6RTg0Qmb4M1vOpmdTp3tdArFjO10SvDiN50G2+mU4MVb4sF2OiV48ZZ4XOyEDfDiZ9hhdjoNj9Ppa58fcKfTY7cZcKfTMzzc6RTgxW86DbPTabCdTqGYsZ1OCV78ptNgO50SvHhLPNhOpwQv3hIPttMpwZufYc1Op+FxOt30ebjT6bnbwJ1OAV68JR5wp1OANz/Dsp1OoZixnU4JXvym02A7nRK8eUvMdjolePOWmO10SvDmZ1iz02l4nE43fR7udHruNnCnU4A3b4nhTqcAz07YAG/eErOdTgle/KbTYDudErx5S8x2OiV485aY7XRK8OZnWLPTaXicTjd9Hu50eu42cKdTgDdvieFOp2d4s9NpsJ1OoZixnU4J3vymE9vplODNW2K20ynBm7fEbKdTgjc/w5qdTsPjdLrp83Cn03O3gTudAjw6YRO8+U0ns9NpsJ1OoZixnU4J3vymE9vplODNW2K20ynBm7fEbKdTgjc/w5qdTsPjdLrp83Cn03O3gTudnuHhTqcAb37Tyex0GmynUyhmbKdTgje/6cR2OiV485aY7XRK8OIt8WQ7nRK8+Bl2mp1O0+N0+trn54VO2OduM+FOpwAv3hJPuNMpwIufYSfb6fRczCbb6ZTgxW86TbbTKcGLt8ST7XRK8OIt8WQ7nRK8+Bl2mp1O0+N0uunzcKfTc7eBO50CvHhLPOFOpwDPTtgAb36GNTud5sedTufX6F5nlK88G8ZzWDwflyklnk+n1Tk/v3hfpT//5Z/n/GQv4yt69aI3L3r3og8v+vSiLy/69qIfLfrHbUhvRPemafemafem6cctSG9E96Zp96Zp96Zp96Zp96bp8Kbp8Kbp8Kbp8Kbpx41Hb0T3punwpunwpunwpunwpun0pun0pun0pun0punH7UZvRPem6fSm6fSm6fSm6fSm6fKm6fKm6fKm6fKm6cdNRm9E96bp8qbp8qbp8qbp8qbp9qbp9qbp9qbp9qbpx61Fb0T3pun2pun2pun2pun2punxpunxpunxpunxpunHDUVvRPem6fGm6fGm6fGm6dGm6bq0aboubZquS5um69Km6bq0aboubZquS5um69Km6bq0aboub5oWb5oWb5oWb5oWb5p+3Dz0RnRvmhZvmhZvmhZvmhZvmlZvmlZvmlZvmlZvmn7cMvRGdG+aVm+aVm+aVm+aVm+aNm+ael1Iy+tCWl4X0vK6kJbXhbS8LqTldSEtrwtpeV1Iy+tCWl4X0vK6kJbXhbS8LqTldSEtrwtpeV1Iy+tCWl4X0vK6kJbXhbS8LqTldSEtrwtpeV1Iy+tCWl4X0vK6kJbXhbS8LqTldSEtrwtpeV1Iy+tCWl4X0vK6kJbXhbS8LqTldSEtrwtpeV1Iy+tCWl4X0vK6kNbnXUir/I2+v/JMGM+C8Xw6zGqtP//61FW/8hwWz8elQYmnwHgqjKfBeDqMZ8B4JoxnwXhg83nD5vOBzecDm88HNp8PbD4f2Hw+sPl8YPP5wObzgc3nw5rP+2LN532x5vO+WPN5X6z5vC/WfN4Xaz7vizWf98Waz/tized9weZzgc3nApvPBTafC2w+F9h8LrD5XGDzucDmc4HN5wKbzxU2nytsPlfYfK6w+Vxh87nC5nOFzecKm88VNp8rbD432HxusPncYPO5weZzg83nBpvPDTafG2w+N9h8brD53GHzucPmc4fN5w6bzx+/dF33+snTSvnKM2A8E8azYDyfns+j/Pw3r7Guf+X5+sWvv/vjry9+/dP8Cn/E8B+/zPxW+EKGL7v/gr+ur/DVDN/M8N0MPyy/sH1/hZ9m+GWG1yTsHbwmYW/gpyZh7+DRCZvg0Qmb4NEJm+DRCZvgzQk7zQk7zQk7zQk7zQm7zAm7zAm7zAm7zAn78cvPb4U3J+wyJ+wyJ+wyJ+wyJ+w2J+w2J+w2J+w2J+zH76S/Fd6csNucsNucsNucsNucsMecsMecsMecsMecsB+3CrwV3pywx5ywx5ywx5ywR5yw5xIn7LnECXsuccKeS5yw5xIn7LnECXsuccKeS5yw5xIn7LnMCVvMCVvMCVvMCVvMCftxs8db4c0JW8wJW8wJW8wJW8wJW80JWzUJ+/Wq0ani2zqnim/rnI+7Wd4Kj07YBG9O2GpO2Cq+D3sqO2H3/Anfri832U9jJ2yAF9+HPc2csM2csB+367wV3vwM28wJ28wJ28zPsM38DNvNz7Dd/Azb2Vvi527T2VviAG9O2G5+hu3ohE3w6IRN8OaE9TidbuA9Tqc7ePM5LNvpFOoB2+kUEpbtdErw5oRlO50SvDlh2U6nBG9OWLPT6ZidTsfsdDpmp9PxOJ1uug3c6fRcD+BOpwBvTli20ynBoxM2wLOdTgnenLBmp9MxO52O2el0zE6nY3Y6HY/T6aaYwZ1Oz90G7nR6hmc7nULCsp1OCd78phPb6ZTgzQlrdjods9PpmJ1Ox+N0uqkHcKfTc8LCnU4B3pywbKdTgjcnLNvplODNCWt2Oh2z0+mYnU5H7HTql9jp9IL3vkv8gve+S/yC977p9IL3JuwL3vum0wve+6bTC957DvuC9ybsC96csGKn0wveew77gveew77gveewL3h0wiZ4zTPsTauEO52eixnc6RTgvW86veC9bzr1i+10SvDeLfEL3pywbKdTgjcnLNvplOA1W+KbegB3Oj0nLNzpFODNCct2OiV4c8KKnU4veHPCsp1OCd6csGKn0wveew77gjdviT1Op5tiBnc6PXcbuNMpwJsTlu10SvDohE3w5nNYttMpzHm20ynBmxNW7HTql9jp9II3n8OKnU4vePObTmKn0wvenLBip9ML3vymk9jp9II3J6zY6fSCNyes2On0gjdviT1Opzt485tOYqfTC958Dit2Or3gzeewYqfTC958Dit2Or3gzQkrdjq94M3nsGKn0wvevCWGO50CvPkclu10CsWM7XRK8OZzWLHT6QWPTtgEb94Si51OL3hzwnqcTnfw5i0x3OkU4M1bYrbTKRQzttMpdBu20ynBmxOW7XRK8OZzWLbTKcGLE7aYnU7F43S6gxdviQvc6RTg2Qn72G0K2+n0XA8K2+mU4MUJW9hOpwQvPoctbKdTgjcnrNnpVMxOp2J2OhWP0+kOXrwlLnCn03MxYzudQrdhO50CvNnpVMxOp8J2OiV48TlsMTuditnpVDxOpzt48TlsgTudArx5S8x2OiV48zMs2+mU4DXPsDd9Hu50eq7EcKdTgBefwxa20ynBm7fEbKdTgIc7nZ7nPNzpFODNCct2OiV4dsIGePF92AJ3Oj3XA7jTKcCbE5btdArwbKdTgjdviT1Op5s5D3c6BXhzwrKdTgnevCVmO50SvPcT2F/w5nNYuNMpwJsTlu10SvDmc1i20ynBmxMW7nQK8OaEZTudErz5HJbtdErw4k9gL3Cn03O3gTudArw5YdlOpwRvPodlO50SvDlhPU6nG3i40ynAm89h2U6nBG/eErOdTgnefA4Ldzo9FzO40ynAm89h2U6nAM92OiV485bY43S6mfNwp1OANycs2+mU4M1bYrbTKcGbn2E9TqevrbLCnU6PxazCnU4BXnwOW9lOpwSPTtgEL94SV7jT6XHOV7bTKcGLE7aynU4Bnu10SvDiLXE1O52qx+l00yrhTqfnYgZ3OgV48TlsZTudErx4S1zZTqcAz3Y6hTnPdjoleHPCsp1OCZ6dsAFefA5b4U6n53oAdzoFeHPCsp1OAZ7tdErw4nPYanY6VY/T6Q7enLBwp1OAN2+J2U6nBG/eErOdTqFVwp1Oz8UM7nQK8OZzWLbTKcGjEzbBm89h4U6n5zkPdzoFeHPCsp1OAZ7tdErw5i2x2elUzU6nanY6VY/T6abPw51Oz5UY7nQK8OYtMdvpFODZTqcEb94Ss51OYc6znU4J3pywZqdTNTudqsfpdNNt4E6n53oAdzo9w7OdTiGk2E6nBG/eErOdTgnenLBsp1OCNycs2+mU4M1bYrPTqXqcTjfFDO50eu42cKdTgDcnLNvplODN57Bsp1OCNycs2+mU4M0Jy3Y6JXjzOazZ6VQ9TqebYgZ3Oj13G7jTKcCbE5btdErw5nNYttPpGb7BnU6Pc77BnU4BXpywje10SvDshA3w4i1x8zidvhazBnc6PXabBnc6BXhzwrKdTglefA7b2E6nBG9OWLjTKcCbE5btdErw4i1xYzudErx4S9w8TqebVgl3Oj0XM7jTKcCLz2Eb2+mU4MXnsI3tdErw5oRlO50SvDlh2U6nBG/eEpudTs3jdLopZnCn03O3gTudArw5YdlOpwQvPodtbKdTgIc7nZ7nPNzpFODNCct2OiV4dsIGeLFxosGdTs/1AO50CvDmhGU7nQI82+mU4M3nsGanUzM7nZrZ6dQ8Tqc7ePM5LNzpFOA1W+KbYsZ2OoVuw3Y6JXhzwrKdTgnefA7LdjoleHPCmp1OzeN0uoM3n8PCnU7P8GynU4I3b4nZTqcEb36G9Tidbvo83On0XInhTqcAbz6HZTudErx5S8x2OiV4c8LCnU4B3pywbKdTgjc/w7KdTgle7CVucKfTc7eBO52e4dlOp5CwbKdTgjdvidlOpwRvTli40ynAmxOW7XRK8OYtMdvp9AzfzU6n7nE6fW2VHe50eixmHe50CvDohH2uB53tdErw4ts6ne10SvDihO1sp1OAZzudErx4S9zZTqcEL94Sd7PTqZudTt3jdLqpxHCn03OrhDudArz4HLaznU4JXrwl7mynU4I3Jyzb6ZTgzQnLdjolePGWuJudTt3sdOpmp1P3OJ1uKjHc6fTcKuFOpwCPTtjQbdhOpwRv3hKbnU6d7XRKc96csGanUzc7nbrZ6dTNTqdudjp1j9PpDt68JTY7nTrb6ZTgzVtis9Opm51One10SvDmhDU7nbrZ6dTNTqdudjp1j9PpDl7zDHtTzMxOp852OiV4c8KanU7d7HTqbKdTgjcnrNnp1M1Op252OnWz06l7nE433QbudHquB3CnU4A3Jyzb6ZTgzeewZqdTZzud0pw3Jyzb6ZTgzeewZqdTNzudusfpdFPM4E6n524DdzoFeHPCsp1OCd58Dmt2OnW20ynMebbTKcGbE9bsdOpmp1M3O5262enUzU6n7nE6fa3EA+50emyVA+50CvDic9jBdjoleHTCJnjxlniwnU7Pc36wnU4JXpyww+x0Gman0/A4nW66Ddzp9FwP4E6nAG9OWLbTKcGLz2EH2+mU4M0Jy3Y6BXi20ynBi7fEg+10SvDiLfHwOJ1uihnc6fTcbeBOpwBvTli20ynBi89hB9vplODNCQt3OgV4c8KynU4JXnwOO9hOpwQv/vS6AXc6PXcbuNPpGZ7tdAoJy3Y6JXjzOSzb6ZTgzQlrdjoNj9PpDt58Dgt3OgV485aY7XQKxYztdArdhu10SvDmhGU7nRK8+RyW7XRK8OaENTudhsfpdAMPdzoFePOWmO10SvDmLTHb6RRaJdvpFIoZ3OkU4M3nsGynU4I3n8OynU4J3pywcKdTgDcnLNvplODNW2K20ynBm59hPU6nm1YJdzo9FzO40ynAm89h2U6nBG/eErOdTgnenLBwp1OANycs2+mU4M1bYrbTKcGb78PCnU7P3QbudArw5oRlO50SvPkclu10SvDmhPU4nb7CT7jTKcCLt8ST7XRK8OIt8bzQCZvgNc+wX1vlhDudHovZhDudArz4HHaynU4Bnu10SvDiLfGEO52e5zzc6RTgzQnLdjolePGWeLKdTgle/Aw7zU6naXY6TbPTaXqcTjcPI3Cn03OfhzudArx4SzzZTqcEL94ST7PTabKdTmHOs51OCd6csGan0zQ7nabH6XTTbeBOp+d6AHc6BXhzwrKdTgnevCU2O50m2+kU5jzb6ZTgzQlrdjpNs9Npmp1O0+N0uilmcKfTc7eBO52e4dlOp5CwbKdTghff1plmp9NkO53CnGc7nRK8OWHNTqdpdjpNs9NpepxON8UM7nR67jZwp1OANycs2+mU4M3nsGynU4I3Jyzb6ZTgzQnLdjolePOW2Ox0mh6n000xgzudnrsN3OkU4M0Jy3Y6JXjzOSzb6RTg4U6n5znPdjoleHPCsp1OCZ6dsAHevCU2O52mx+l00yrhTqfnYgZ3Oj3Ds51OoR6wnU4J3nwOy3Y6JXhzwrKdTgnenLBsp1OCN2+JzU6n5XE6fS1mC+50euw2C+50CvDihF0XOmETvPgcdrGdTglenLCL7XRK8OaEZTudErx4S7w8TqebbgN3Oj3XA7jTKcCbE5btdErw4nPYxXY6JXhzwpqdTsvsdFoep9MdvPgcdsGdTgFe7CVebKdT6DZsp1OCNycs2+kU4NlOpwQvPoddZqfTMjudlsfpdAcvPoddcKdTgDdvidlOp1DM2E6n0G3YTqcEbz6H/bjT6fz6a7zOKF95Goynw3gGjGfCeBaMZ8N4Ph0T5/z84n2V/jys5jk/2cv4gv5xLdEb0YsXvXrRmxe9e9GHF3160ZcXfXvRvWk6vWk6vWk6vWk6vWn6cfXQG9G9aTq9aTq9aTq9aTq9abq8abq8abq8abq8afpxzdAb0b1purxpurxpurxpurxpur1pur1pur1pur1p+nGl0BvRvWm6vWm6vWm6vWm6vWl6vGl6vGl6vGl6vGn6cX3QG9G9aXq8aXq8aXq8aXq0abovbZruS5um+9Km6b60abovbZruS5um+9Km6b60abovbZruy5umxZumxZumxZumxZumH9cCvRHdm6bFm6bFm6bFm6bFm6bVm6bVm6bVm6bVm6YfVwC9Ed2bptWbptWbptWbptWbps2bps2bps2bps2bph/X/bwR3ZumzZumzZumzZumzZum3Zum3Zum3Zum3Zumn5cGvQ/dm6bdm6bdm6bdm6ZeF9L2upC214W0vS6k7XUhba8LaXtdSNvrQtpeF9L2upC214W0vS6k7XUhba8LaXtdSNvrQtpeF9L2upC214W0vS6k7XUhba8LaXtdSNvrQtpeF9L2upC214W0vS6k7XUhba8LaXtdSNvrQtpeF9L2upC214W0vS6k7XUhba8LaXtdSNvrQtpeF9L2upC214W0vS6k/XkX0ip/o++vPB3GM2A8E8azYDwbxnNQPOfzep/AU2A8FcbDms/n+vR8rrX+jK+66leeAeOZMJ4F49kwnsPi+bgwJvEUGE+F8TQYD2w+F9h8LrD5XGDzucDmc4HN5wqbzxU2nytsPlfYfK6w+Vxh87nC5nOFzecKm88VNp8bbD432HxusPncYPO5weZzg83nBpvPDTafG2w+N9h87rD53GHzucPmc4fN5w6bzx02nztsPnfYfO6w+dxh83nA5vOAzecBm88DNp8HbD4P2HwesPk8YPN5wObzgM3nCZvPEzafJ2w+T9h8nrD5PGHzecLm84TN5wmbzxM2nz9+Obju9ZOnlfKVp8B4KoynwXg+PZ9H+flvXmNd/8rz9Ytff/fHX1/8+qf5FX6Y4acZfpHhy+6/4K/rK/w2wx8x/Mcv374Vvlh+YfvX96g/fgH3rfDNDK9J2Dt4TcLewWsS9g4enbAJHp2wCR6dsAH+oBM2wZsT9pgT9pgT9uN3eN8Kb07YY07YY07YY07Y403YcV3ehH3BexP2Be9N2Be8N2Ff8N6EfcF7E/YF703YF7w3YV/w3oR9wZsTtpgTtpgTtpgTtpgT9uP36N8Kb07YYk7YYk7YYk7YYk7Yak7Yak7Yak7Yak7Yj5sQ3gpvTthqTthqTthqTthqTthmTthmTthmTthmTtiPuyzeCm9O2GZO2GZO2GZO2GZO2G5O2G5O2G5O2G5O2I/bSN4Kb07Ybk7YrknYL1eNXvDe2zoveO9tnXEN722dFzw6YRO8OWGHOWE/7pN556gc7ITd8yd8u+pXeHbCBnjvfdgXvDlhhzlhpzlhp/kZdpoTdpoT9uNGoLfCm59hp/kZdpqfYSd7S/zcbSZ7S/wMv8wJu8zPsAudsAkenbAJ3pywHqfTHbw5YdlOpwSvOYe9qQdsp1NIWLbTKcGbE5btdErw5oRlO50SvDlhxU6nF7w5YcVOpxe8+U0nj9PpptvAnU7P9QDudArw5oRlO50SPDphEzw6YRO8OWHFTqcXvDhhi9npVMxOp2J2OhWP0+lrMSsXOmGfu02BO50CvDhhC9vplODFbzoVttMpwJudTsXsdCpmp1MxO52Kx+l0Uw/gTqfnhIU7nQK8OWHZTqcEb05YttMpwZsT1ux0KmanUzE7nYrZ6VTMTqficTrdFDO40+m528CdTs/wbKdTSFi20ynBi990KmynU4I3J6zZ6VTMTqdidjoVs9OpmJ1Oxex0Kh6n002rhDudnosZ3OkU4NEJG+oB2+mU4M3nsGynU4I3Jyzb6RTg2U6nBG/eEnucTjf1AO50ek5YuNMpwJsTlu10SvDmhDU7nQrb6RTmPNvplODNCWt2OhWz06mYnU7F43S6KWZwp9Nzt4E7nQK8OWHZTqcAb3Y6FbPTqbCdTmHOs51OCd6csGanUzE7nYrZ6VTMTqdidjoVs9OpmJ1Oxex0KmanUzE7nYrZ6VTMTqdidjoVs9OpmJ1OxeN0uoM3v+lkdjoVttMpwZsT1ux0KmanU2E7nRK8OWHNTqdqdjpVs9Opmp1O1eN0uoNHJ2yCF5/DVrbT6bmYVbbTKcGLz2Gr2elU2U6nBC/eElez06manU7V43S6gxdviSvc6RTgxVviynY6hWLGdjqFbsN2OiV4c8KynU4JXnwOW9lOpwRvTliz06l6nE538OItcYU7nZ7h2U6n0G3YTqdQD9hOpwRvTli20ynBi89hK9vplODNCWt2OlWz06manU7V43S6gzdvieFOp+dixnY6hW7DdjoleHPCmp1Ole10SvDmc1iz06manU7V43S6gzefw8KdTgHevCVmO50SvPkZlu10SvCaZ9ibPg93Oj1XYrjTKcCbz2HZTqcEj07YBG/eEsOdTs9zHu50CvDmhGU7nQI82+mU4MX3YSvc6fRcD+BOpwBvTli20ynBm7fEbKdTgjcnLNzp9AwPdzoFePOWmO10SvDmLTHb6RSKGdzp9Nxt4E6nAG9OWLbTKcGbz2HZTqcEb05YuNMpwJsTlu10SvDmc1i20ynBiz+BvcKdTs/dBu50eoRvbKfTc8I2ttMpwYvPYRvb6ZTgxQnbPE6nO3hxwja40ynAi7fEje10CvBsp1OCF5/DNrjT6bmYwZ1OAR6dsKEesJ1OCV58DtvYTqcEb05YuNPpGR7udArw4i1xYzudErx4S9zYTqcEL/YSN7jT6bmYwZ1OAV58DtvYTqcAz3Y6JXjzlhjudHqe82ynU4I3Jyzb6ZTgzVtis9OpmZ1OzeN0ummVcKfTczGDO50CvPkclu10SvDohE3w5i0x2+kU5jzb6ZTgzQnLdjoFeLPTqXmcTjfdBu50eq4HcKdTgDcnLNvplODN57Bsp1OCNyesx+l0Aw93OgV48zks2+mU4M1bYrbTKcGbz2HhTqfnYgZ3OgV48zks2+kU4NlOpwRvPoeFO52e5zzc6RTgzQnLdjolePOWmO10SvDmZ1iz06mZnU7N43S66fNwp9NzJYY7nQI8OmFDMWM7nRK8eUtsdjo1ttMpzXlzwrKdTgnevCU2O52ax+l0023gTqfnegB3OgV4c8KynU4J3rwlZjudnuE72+n0POc72+mU4MUJ29lOpwTPTtgAL94Sd4/T6Wsx63Cn02O36XCnU4A3Jyzb6ZTgxeewne10SvDmhGU7nRK8OWHZTqcELz6H7WanU/c4nW6KGdzp9Nxt4E6nAG9OWLbTKcGjEzbBi89hO9zp9Dzn4U6nAG9OWLbTKcCznU4J3rwl9jidbooZ3On03G3gTqcAb05YttMpwYvPYTvb6ZTgzQkLdzoFeHPCsp1OCd68JWY7nRK8eUvscTrdtEq40+m5mMGdTgHefA7LdjolePM5LNvplODNCct2OiV4c8KynU4J3rwlNjudusfpdFPM4E6n524DdzoFeHPCsp1OCR6dsAnevCWGO52e5zzc6RTgzQnLdjoFeLbTKcGLjRMd7nR6rgdwp1OANycs2+mU4M3nsGynU4I3J6zZ6dTNTqfucTrdwZvPYeFOpwCPTthQzNhOp9Bt2E6nBG9OWLbTKcGbz2HZTqcEb05Ys9Ope5xOd/CahL2DN5/Dsp1OCd68JWY7nRK8+Bl2eJxOX/v8gDudHivxgDudArz4HHZc6IRN8OIt8WA7nRK8OGEH3OkU4M0Jy3Y6JXjxM+xgO50SvNhLPOBOp+duA3c6BXhzwrKdTglevCUebKdTgIc7nZ7nPNzpFODNCct2OiV4dsIGePGWeJidTsPjdLpplXCn03MxgzudnuHZTqdQD9hOpwQvvq0z2E6nBG9OWLbTKcGbE5btdErw5i2x2ek0zE6nYXY6DY/T6aYSw51Oz60S7nQK8OZzWLbTKcGbt8Rsp1OCNycs2+mU4M0Jy3Y6JXjzltjsdBpmp9MwO52Gx+l0U4nhTqfnVgl3Oj3Ds51OoduwnU4J3rwlNjudBtvpFOY82+mU4M0Ja3Y6DbPTaZidTsPsdBoep9MdvHlLbHY6DbbTKcGbt8Rmp9MwO50G2+mU4M0Ja3Y6DbPTaZidTsPsdBoep9MdvOYZ9qaYmZ1Og+10SvDmhDU7nYbZ6TTYTqcEb05Ys9NpmJ1Ow+x0Gman0/A4nW66Ddzp9FwP4E6nR/jJdjo9h9RkO50SvPgcdpqdTvMSJ+xkO50SvDhhp9npNM1Op2l2Ok2P0+lrMZtwp9Nzt4E7nQK8OWHZTqcELz6HnWan02Q7ndKcNycs2+kU4M1Op2l2Ok2z02manU7T7HSaHqfTTSWGO52eWyXc6RTgxeewk+10CvBmp9M0O50m2+kU5jzb6ZTgzQlrdjpNs9NpepxON90G7nR6rgdwp9MzPNvpFEKK7XRK8OZzWLbTKcGbE5btdErw5oRlO50SvHlLbHY6TY/T6aaYwZ1Oz90G7nQK8OaEZTudErz5HJbtdErw5oSFO50CvDlh2U6nBG8+h2U7nRK8+NPrJtzp9Nxt4E6nAG9OWLbTKcGbz2HZTqcAb3Y6TbPTaXqcTnfw5nNYuNMpwJu3xGynUyhmbKdT6DZsp1OCNycs2+mU4M3nsGynU4I3J6zZ6TQ9Tqc7ePM5LNzpFODNW2K20ynAs51OoVWynU6hmMGdTgHefA7LdjolePM5LNvplODNCQt3OgV4ccIuttMpwYu3xIvtdErw4mfYdaET9rlVLrjT6bGYLbjTKcCLz2EX2+mU4MVb4sV2OiV4c8LCnU4B3pywbKdTghdviRfb6ZTgxfdhF9zp9Nxt4E6nZ3i20ykkLNvplODF57CL7XRK8OaE9Tid7uDNCQt3OgV48ZZ4sZ1OAZ7tdErwmmfYm1YJdzo9FzO40ynAoxM21AO20ynBi89hF9vplODNCQt3Oj3Ds51OCd68JWY7nRK8eUtsdjots9NpmZ1Oy+x0Wh6n083DCNzp9Nzn4U6nAG/eErOdTgnevCU2O50W2+kU5jzb6ZTgzQlrdjots9NpeZxON90G7nR6rgdwp1OANycs2+mU4M1bYrPTabGdTmnOmxOW7XQK8Gan0zI7nZbZ6bQ8TqebYgZ3Oj13G7jTKcCbE5btdErw5ts6ZqfTYjudwpxnO50SvDlhzU6nZXY6LbPTaXmcTjfFDO50eu42cKdTgDcnLNvplODN57Bsp1OCNycs2+mU4M0Jy3Y6JXjzltjsdFoep9PXYrbhTqfHbrPhTqcAL07YzXY6JXh0wiZ48TnshjudHuf8ZjudErw4YTfb6RTg2U6nBC/eEm+z02l7nE43rRLudHouZnCnU4AXn8NuttMpwYvPYTfb6RTg2U6nMOfZTqcEb05YttMpwbMTNsCLt8Tb43S6KWZwp9Nzt4E7nQK8OWHZTqcELz6H3WynU4I3Jyzb6ZTgzQnLdjolePOW2ON0uuk2cKfTcz2AO50CvDlh2U6nBG8+h2U7nRK8OWHNTqdtdjptj9PpDt58Dgt3OgV4sZd4s51OoduwnU4J3pywbKdTgjefw7KdTgnenLBmp9P2OJ3u4M3nsHCnU4A3b4nZTqdQzNhOp9Bt2E6nBG8+h/240+n8+mu8zihfeQ6L5+PmpcRTYDwVxtNgPB3G8+mYOOfnF++r9OdhNc/5yV7GV/TpRV9e9O1FP1r0j+uI3ohevOjVi9686N2L7k3T7U3T7U3T7U3T7U3T403T403T403T403TjyuH3ojuTdPjTdPjTdPjTdOjTdNzadP0XNo0PZc2Tc+lTdNzadP0XNo0PZc2Tc+lTdNzadP0XN40Ld40Ld40Ld40Ld40/bhK6I3o3jQt3jQt3jQt3jQt3jSt3jSt3jSt3jSt3jT9uDbojejeNK3eNK3eNK3eNK3eNG3eNG3eNG3eNG3eNP24IuiN6N40bd40bd40bd40bd407d407d407d407d40/bgO6I3o3jTt3jTt3jTt3jTt3jQd3jQd3jQd3jQd3jT9uPrnjejeNB3eNB3eNB3eNB3eNJ3eNJ3eNJ3eNJ3eNP245ueN6N40nd40nd40nd40nd40Xd40Xd40Xd40Xd40/bzg6H3o3jT1upCO14V0vC6k43UhHa8L6XhdSMfrQjpeF9LxupCO14V0vC6k43UhHa8L6XhdSMfrQjpeF9LxupCO14V0vC6k43UhHa8L6XhdSMfrQjpaF9K8tC6kF7o1TV/o1jR9oVvT9IVuTdMXujVNX+jWNH2hW9P0hW5N0xe6N021LqQXujdNtS6kF7o3TbUupBe6N021LqQXujdNtS6kF/rH03SVv9H3F57PC44CT4HxVBhPg/F0GM+A8UwYz4LxbBgPbD5/XJlTa/0ZX3XVrzwFxlNhPA3G02E8A8YzYTwLxrNhPIfF02HzucPmc4fN5w6bzx02nztsPnfYfO6w+dxh87nD5vOAzecBm88DNp8HbD4P2HwesPk8YPN5wObzgM3nAZvPEzafJ2w+T9h8nrD5PGHzecLm84TN5wmbzxM2nydsPi/YfF6w+bxg83nB5vOCzecFm88LNp8XbD4v2HxesPm8YfN5w+bzhs3nDZvPGzafN2w+b9h83rD5vGHzecPm84HN5wObzwc2nw9sPh/YfD6w+fzxy8F1r588rZSvPAvGs2E8B8VTPn7hdpSf/+Y11vWvPF+/+PV3f/z1xa9/ml/hixm+muEbGb7s/gv+ur7CdzP8MMNPM/yy/ML2/RV+m+GPGL5oEvYOXpOwd/CahL2DRydsgkcnbIJHJ2yCRydsgjcnbDEnbDEnbDUnbDUnbDUnbDUn7MfvHb8V3pyw1Zyw1Zyw1Zyw1ZywzZywzZywzZywzZywH785/lZ4c8I2c8I2c8I2c8I2c8J2c8J2c8J2c8J2c8J+/O7/W+HNCdvNCdvNCdvNCdvNCTvMCTvMCTvMCTvMCftxe8Nb4c0JO8wJO8wJO8wJO8wJO80JO80JO80JO80J+3H/xlvhzQk7zQk7zQk7zQk7zQm7zAm7zAm7zAm7NAl7c9Xo4waVd94ZWebbOst8W2ehEzbBmxN2mRN2m+/DbnbC7vkTvl31Kzw7YQO8+T7sxx04b4U3J+w2J+w2P8Nuc8Juc8Ie8zPsMT/DHvMz7DE/w37cYvTObnPYW+IAb07YY36GPeiETfDohH2Grx6n09c5Xz1Opzt4ccJWttMpwbMT9rEeVLbT6TlhK9vplODFCVvZTqcEb05YttMpwZsT1ux0qmanUzU7narZ6VQ9TqebbgN3Oj3XA7jTKcCbE5btdErw6IRN8OiETfDmhDU7narZ6VTNTqdqdjpVs9OpepxON8UM7nR67jZwp1OANycs2+mU4NEJm+DFbzpVs9Opmp1O1ex0qmanU/U4nW7qAdzp9JywcKdTgDcnLNvplODNCct2OiV4c8KanU7V7HSqZqdTNTudqtnpVD1Op5tiBnc6PXcbuNMpwJsTlu10SvDmN53YTqcAb3Y6VbPTqZqdTtXsdKpmp1M1O52q2elUPU6nm1YJdzo9FzO40+kZnu10CvWA7XRK8OZzWLbTKcGbE5btdErw5oRlO50SvGZLfFMP4E6n54SFO50CvDlh2U6nBG9OWLPTqbKdTmHOs51OCd6csGanUzU7narZ6VQ9TqebYgZ3Oj13G7jTKcCbE5btdErw5nNYs9Opsp1Oac6LE7aZnU7N7HRqZqdTMzud2oVO2Odi1sxOp3aJnU7N7HRqZqdTMzudmtnp1MxOp2Z2OjWz06mZnU7N7HRqHqfTHbz4Tadmdjo1ttMpwJudTs3sdGpmp1NjO50SvDlhzU6nZnY6NbPTqZmdTs3jdLqBhzudArz4HLaxnU6hmLGdTgkenbChHpidTo3tdErw5i2x2enUzE6n5nE63cGbt8Rwp1OAN2+J2U6nUMzYTqfQbdhOpwRvTli20ynBm89h2U6nBG9OWLPTqXmcTnfwmoS9gzdvidlOp9Bt2E6nUA/YTqcEb05YttMpwZvPYdlOpwRvTliz06mZnU7N7HRqHqfTHbx5Swx3Oj0XM7bTKXQbttMpwZsT1ux0amynU4I3n8OanU7N7HRqHqfTHbz5HBbudArw5i0x2+mU4M3PsGynU4LXPMPe9Hm40+m5EsOdTgHefA7LdjoFeLbTKcGbt8Rwp9PznIc7nQK8OWHZTqcEb36GZTudQreBO52e6wHc6fQI39lOp+eQ6mynU4IXb4k72+mU4MUJ2+FOpwAvTtjOdjolePGWuLOdTgGe7XR6LmYd7nR67jZwp1OANycs2+mU4MXnsJ3tdErw5oSFO50CvDlh2U6nBC8+h+1sp1OCF38Ce4c7nZ67DdzpFODNCct2OiV48TlsZzudArzZ6dQ9Tqc7eHPCwp1OAZ6dsAHevCVmO50SvPgctsOdTs/FDO50eoZnO51CPWA7nRK8+RyW7XRK8OaEhTudArw5YdlOpwRv3hKznU4Bnu10SvBiL3GHO52eixnc6RTg0Qkb6gHb6ZTgzVtittMpwZsTlu10CvBsp1OCN2+J2U6nBG/eEpudTt3jdLpplXCn03MxgzudArz5HJbtdArwbKdTgjdvidlOpzDn2U6nBG9OWLbTKcGbt8Qep9NNt4E7nZ7rAdzp9AzPdjqFkGI7nRK8+RyW7XRK8OaE9Tid7uDNCQt3OgV485aY7XQK8GynU4I3n8PCnU7PxQzudArw6IQN9YDtdErw5nNYttMpwZsTFu50eoQfbKdTghefww620ynBi7fE40InbIIXP8MOs9NpeJxOX/v8gDudHivxgDudnuHZTqfnYjbYTqcEL94SD7PTabCdTmHOs51OCd6csGan0zA7nYbH6XTTbeBOp+d6AHc6BXhzwrKdTgkenbAJXrwlHmynU5jzbKdTgjcnLNvpFODNTqdhdjoNj9PpppjBnU7P3QbudArw5oRlO50SvPgcdrCdTgnenLBsp1OCNycs2+mU4M3nsGan0/A4nW6KGdzp9Nxt4E6nAG9OWLbTKcCznU4J3nwOC3c6Pc95uNMpwJsTlu10SvDmLTHb6ZTgNVvim2IGdzo9dxu40ynAmxOW7XRK8OZzWLbTKcGbExbudArw5oRlO50SvHlLzHY6JXjzltjjdLpplXCn03MxgzudArz5HJbtdErw5nNYttMpwZsTlu10SvDmhGU7nRK8eUtsdjoNj9PpppjBnU7P3QbudArw5oRlO50CPNvplODNW2K40+l5zsOdTgHenLBsp1OCN2+J2U6n0G3gTqfnegB3Oj3CT7bT6TmkJtvplODF57CT7XRK8OKEnWan0zQ7nabH6XQHLz6HnXCn0zM82+n0XMwm2+kUug3b6ZTgzQnLdjolePE57GQ7nRK8OWHNTqfpcTrdwMOdTgFefA472U6nBC/eEk+20ynBm59hPU6nmz4Pdzo9V2K40ynAi89hJ9vplODNW2K20ynBmxMW7nQK8OaEZTudErz5GZbtdErwYi/xhDudnrsN3OkU4M0Jy3Y6JXh0wiZ485YY7nR6nvNwp1OANycs2+kU4NlOpwRv3hKbnU7T43S6aZVwp9NzMYM7nQK8+RyW7XRK8OLbOpPtdArwcKfT85xnO50SvDlh2U6nBM9O2ABv3hKbnU7T7HSaHqfTTSWGO52eWyXc6RTgzeewbKdTgjdvidlOpwRvTli20ynBmxOW7XRK8OYtsdnpNM1Op2l2Ok2P0+mmEsOdTs+tEu50CvDmLTHb6ZTgzVtis9Npsp1OYc6znU4J3pywZqfTNDudptnpNM1Op+lxOt3Bm7fEZqfTYjudErx4S7zMTqdldjqtC52wCV6csMvsdFpmp9MyO52W2em0PE6nO3jNM+zXYrbMTqfFdjoleHPCmp1Oy+x0WmynU4I3J6zZ6bTMTqdldjots9NpeZxON90G7nR6rgdwp1OANycs2+mU4MXnsMvsdFpsp1OY82ynU4I3J6zZ6bTMTqdldjotj9PpppjBnU7P3QbudArw5oRlO50SvPkc1ux0WmynU5jzbKdTgjcnrNnptMxOp2V2Oi2z02mZnU7L43S6qcRwp9Nzq4Q7nQI8OmFDt2E7nRK8eUtsdjotttMpzXlzwpqdTsvsdFpmp9PyOJ1uug3c6fRcD+BOpwBvTli20ynBm89h2U6nAA93Oj3PebbTKcGbE5btdErw7IQN8OYtscfpdFPM4E6n524DdzoFeHPCsp1OCd58Dst2OiV4c8LCnU4B3pywbKdTgjefw7KdTgle/Ol1C+50eu42cKdTgDcnLNvplODRCZvgzeewZqfTMjudlsfpdAcvPofdcKdTgBdviTfb6fRczDbb6fTcbfaFTtgEL07YzXY6JXjxOexmO50SvDlhzU6n7XE63cGLz2E33OkU4NkJG+DFW+LNdjqFVsl2OoViBnc6BXjxOexmO50SvPgcdrOdTgnenLBwp1OANycs2+mU4MVb4s12OiV48zOsx+l00yrhTqfnYgZ3OgV48TnsZjudErx5S8x2OiV4c8LCnU4B3pywbKdTgjdvidlOpwQvvg+74U6n524DdzoFeHPCsp1OCd58Dst2OgV4s9Npe5xOd/DmhIU7nQI8O2EDvHlLzHY6JXjNM+xNq4Q7nZ6LGdzp9AzPdjqFesB2OiV48zks2+mU4M0JC3c6BXhzwrKdTgnevCVmO50CvNnptM1Op212Om2z02l7nE43DyNwp9Nzn4c7nQK8eUvMdjolePOW2Ox02mynU5jzbKdTgjcnrNnptM1Op+1xOt10G7jT6bkewJ1OAd6csGynU4I3b4nNTqfNdjqFOc92OiV4c8KanU7b7HTaZqfT9jidvhazA3c6PXabA3c6BXhxwh620ynBoxM2wYtv6xy20+l5zh+20ynBixP2mJ1Ox+x0Oman0/E4nW6KGdzp9Nxt4E6nAG9OWLbTKcGLz2EP2+mU4M0Jy3Y6JXhzwrKdTglevCU+ZqfT8TidbooZ3On03G3gTqcAb05YttMpwLOdTglefA574E6n5znPdjoleHPCsp1OCd68JTY7nY7Z6XQ8TqebVgl3Oj0XM7jTKcCbz2HZTqcEj07YBG/eErOdTmHOs51OCd6csGynU4A3O52O2el0PE6nm2IGdzo9dxu40ynAmxOW7XRK8OZzWLbTKcGbE5btdErw5oRlO50SvHlL7HE63XQbuNPpuR7AnU4B3pywbKdTgjefw7KdTgnenLBmp9MxO52Ox+l0B28+h4U7nQK82Et82E6n0G3YTqcAb3Y6HbbTKcGbz2HZTqcEb05Ys9PpeJxOd/Dmc1i40ynAm7fEbKdTKGZsp1PoNmynU4I3n8N+3Ol0fv01XmeUrzwDxjNhPAvGs2E8h8Szro9bjBLPp2Pilap/ffG+Sn8eVq8/vp/sZXxFr1705kXvXvThRZ9e9OVF3170o0X/uIbojejeNC3eNC3eNP24fuiN6N40Ld40Ld40Ld40Ld40rd40rd40rd40rd40/bhq6I3o3jSt3jSt3jSt3jSt3jRt3jRt3jRt3jRt3jT9uFbojejeNG3eNG3eNG3eNG3eNO3eNO3eNO3eNO3eNP24QuiN6N407d407d407d407d40Hd40Hd40Hd40Hd40/bgu6I3o3jQd3jQd3jQd3jQd3jSd3jSd3jSd3jSd3jT9uBrojejeNJ3eNJ3eNJ3eNJ3eNF3eNF3eNF3eNF3eNP24BuiN6N40Xd40Xd40Xd40Xd403d403d403d403d40/bjy543o3jTd3jTd3jTd3jTd3jQ93jQ93jQ93jQ93jT9vN7nfejeND3eND3eND3eND3aNC2XNk2L14VUvC6k4nUhlUubpsXrQipeF1LxupCK14VUvC6k4nUhFa8LqXhdSMXrQipeF1LxupCK14VUvC6k4nUhFa8LqXhdSMXrQipeF1LxupCK14VUvC6k4nUhFa8LqXhdSMXrQipeF1LxupCK14VUvC6k4nUhFa8LqXhdSMXrQipeF1LxupCK14VUvC6k4nUhFa8LqXhdSOXzLqRV/kbfX3kmjGfBeDaM57B4Pi8NCjwFxlNhPA3G02E8sPn8cWVOrfVnfNVVv/IsGM+G8RwWz8c1NImnwHgqjKfBeDqMZ8B4YPN5wubzhM3nCZvPCzafF2w+L9h8XrD5vGDzecHm84LN5wWbzws2nxdsPm/YfN6w+bxh83nD5vOGzecNm88bNp83bD5v2HzesPl8YPP5wObzgc3nA5vPBzafD2w+H9h8PrD5fGDz+bDmc71Y87lerPlcL9Z8rhdrPteLNZ/rxZrP9WLN53qx5nO9WPO5XrD5XGDzucDmc4HN5wKbzwU2nwtsPhfYfC6w+Vxg87nA5nOFzecKm88fvxxc9/rJ00r5ytNgPB3GM2A8n57Po/z8N6+xrn/l+frFr7/d468vfv3T/Aq/zPDbDH/I8K9Tp1/w1/UF/uMXb98KX8zw1QzfLL+wfX+F72b4YYbXJOwdvCZh7+A1CXsHj07YAN/RCZvg0Qmb4NEJm+DNCfvxS7lvhTcnbDcnbDcnbDcnbDcn7DAn7DAn7DAn7DAn7MfvSr8V3pyww5yww5yww5yww5yw05yw05yw05yw05ywH7/t/lZ4c8JOc8JOc8JOc8JOc8Iuc8Iuc8Iuc8Iuc8J+3FfwVnhzwi5zwi5zwi5zwi5zwm5zwm5zwm5zwm5zwn7cOPFWeHPCbnPCbnPCbnPCbnPCHnPCHnPCHnPCHnPCftwZ8lZ4c8Iec8Iec8Iec8IeTcJ+vWrULvFtnXaJb+u0S3xbp13ohE3w4oRtlzhh2yW+D9sudsLu+RP+NVq+wrMTNsCL78O2Yk7YYk7YYk7YIn6GbR/39rwV3pywRfwM24r4GbYV8TNsK+Zn2MreEj93m8reEgd4c8JW8zPsx81Lb4VHJ2yCNyesx+l0B29OWLbTKcCznU6hHrCdTiFh2U6nBG9OWLbTKcGbE5btdErw5oQ1O52a2enUzE6nZnY6NY/T6abbwJ1Oz/UA7nQK8OaEZTudEjw6YRM8OmETvDlhzU6nZnY6NbPTqZmdTs3sdGoep9NNMYM7nZ67DdzpFODNCct2OgV4ttMpwZvfdDI7nZrZ6dTMTqdmdjo1j9Ppph7AnU7PCQt3OgV4c8KynU4J3pywbKdTgjcnrNnp1MxOp2Z2OjWz06mZnU7N43S6KWZwp9Nzt4E7nQK8OWHZTqcEj07YBG8+hzU7nZrZ6dTMTqdmdjo1s9OpmZ1Ozex0ah6n002rhDudnosZ3OkU4M1vOrGdTgnefA7Ldjo9w3e20+l5zne20ynBixO2s51OCZ6dsI/1oMOdTo8J2+FOpwAvTtjOdjoleHPCmp1One10CnOe7XRK8OaENTudutnp1M1Op+5xOt0UM7jT6bnbwJ1Oz/Bsp1NIWLbTKcGLz2G72enU2U6nMOfZTqcEb05Ys9Opm51O3ex06manUzc7nbrZ6dTNTqdudjp1s9Opm51O3ex06manUzc7nbrZ6dTNTqfucTrdwYvfdOpmp1NnO50SvDlhzU6nbnY6dbbTKcCbnU7d7HTqZqdTNzudutnp1D1Opzt485YY7nR6bpVsp1MoZmynU4A3O5262enU2U6nBG/eEpudTt3sdOoep9MdvHlLDHc6BXjzlpjtdArFjO10Ct2G7XRK8OaEZTudErz5HJbtdErw5oQ1O526x+l0Aw93OgV485aY7XQK3YbtdAr1gO10SvDmhGU7nRK8+RyW7XRK8OaENTudutnp1M1Op+5xOt3BsxM2wIs/W6eznU6h27CdTgnenLBmp9NgO50SvPgcdpidTsPsdBqXOGEH3OkU4MXnsIPtdErw4i3xYDudAjzb6ZTgNc+wX/v8gDudHivxgDudAjw6YUMxYzudErx4SzzYTqcEb05YuNPpGZ7tdErw4i3xYDudErz4PuyAO52e6wHc6RTgzQnLdjolePGWeLCdTgHe43S6mfNwp1OANycs2+mU4NkJG+DNW2K20ykUM7jT6bnbwJ1OAd6csGynU4I3n8OynU4J3pywcKdTgDcnLNvplODN57Bsp1OCF38C+4A7nZ67DdzpFODNCct2OiV4dMImePM5rNnpNDxOpzt4c8LCnU7P8GynU4I3b4nZTqcEbz6HhTudnosZ3OkU4M3nsGynU4I3n8OynU4B3uN0upnzcKdTgDcnLNvplODZCRvgzVtittMpwYu9xAPudHouZnCn0zM82+kU6gHb6ZTgzVtittMpwZsTlu10SvDmhGU7nRK8eUtsdjoNs9NpeJxON60S7nR6LmZwp1OARydsqAdsp1OCN2+J2U6nBG9OWLbT6Rl+sp1OCV68JZ5mp9P0OJ2+dpt5oRP2uR5MuNMpwIsTdrKdTglefA472U6nAG92Ok2P0+kO3pywcKdTgGcnbIAXb4kn2+mU4MXnsBPudHouZnCn0zM82+kU6gHb6ZTgxeewk+10SvDmhIU7nQK8OWHZTqcEL94ST7bTKcCbnU7T7HSaZqfT9Didbvo83On0XInhTqcAb94Ss51OCd68JTY7nSbb6RTmPNvplODNCWt2Ok2z02l6nE433QbudHquB3CnU4A3Jyzb6RTg2U6nBG/eErOdTmHOs51OCd6csGynU4I3b4nNTqfpcTrdFDO40+m528CdTgHenLBsp1OCN5/Dsp1OCd6csGynU4I3Jyzb6ZTgzeewZqfT9DidbooZ3On03G3gTqcAb05YttMpwZvPYdlOpwRvTli40+kZnu10SvDmc1i20ynBm7fEHqfTTTGDO52euw3c6RTgzQnLdjolePM5LNvplODNCQt3OgV4c8KynU4J3rwlZjudErx5S+xxOt20SrjT6bGYLbjTKcCLz2EX2+mU4MXnsOtCJ2yCFyfsYjudErw4YRfb6ZTgxVviZXY6LY/T6WsxW3Cn03O3gTudArw5YdlOpwQvPoddbKdTgjcnLNzp9AzPdjolePGWeLGdTglebJxYcKfTcz2AO50CvDlh2U6nBC8+h11sp1OANzudltnptMxOp+VxOt3BsxM2wJu3xGynUyhmbKdT6DZsp1OCNycs2+mU4M3nsGynU4I3J6zZ6bQ8Tqc7ePM5LNzpFODNW2K20ynAs51OCd78DOtxOt30ebjT6bkSw51OAd58Dst2OiV485aY7XRK8OaEhTudArw5YdlOpwRvfoZlO50SvNhLvOBOp+duA3c6BXhzwrKdTgGe7XRK8OYtMdzp9Dzn4U6nAG9OWLbTKcGbt8Rsp1OCN2+JPU6nm1YJdzo9FzO40ynAm89h2U6nBI9O2ARv3hLDnU7Pc57tdErw5oRlO50CPNvplODNW2Kz02mZnU7L43S6qcRwp9Nzq4Q7nQK8+RyW7XRK8OIt8WY7nRK8OGE32+mU4MUJuy9Nwt7Bi7fE2+x02man0zY7nbbH6fS1Em+40+mxVW640ynAi7fEm+10SvDohE3w4i3xZjudwpxnO50SvDlhzU6nbXY6bbPTaZudTtvjdLqDRydsqMRmp9NmO50SvHhLvM1Op212Om220ynBmxPW7HTaZqfTNjudttnptD1Opzt4zTPsTTEzO5022+kU4M1Op212Om2z02mznU4J3pywZqfTNjudttnptM1Op+1xOt10G7jT6bkewJ1OAd6csGynU4JHJ2yCN5/Dsp1OYc6znU4J3pywZqfTNjudttnptD1Op5tiBnc6PXcbuNMpwJsTlu10SvDmc1iz02mznU5hzrOdTgnenLBmp9M2O5222em0zU6nbXY6bY/T6aYSw51Oz60S7nR6hmc7nUK3YTudErx5S2x2Om220ynMebbTKcGbE9bsdNpmp9P2OJ1uug3c6fRcD+BOpwBvTli20ynBoxM2wZu3xHCn0/OcZzudErw5YdlOp2f4w3Y6JXjxlvh4nE5fi9mBO50eu8250Amb4MUJe9hOpwQvPoc9bKdTgjcnLNzpFODNCct2OiV48TnsYTudErz40+sO3On03G3gTqcAb05YttMpwLOdTglefA57zE6nY3Y6HY/T6Q5efA574E6nAC/eEh+20ykUM7bTKXQbttMpwZsTlu10SvDic9jDdjoleHPCmp1Ox+N0uoMXn8MeuNPpGZ7tdErw5i0x2+kUWiXb6RSKGdzpFODN57Bsp1OCN5/Dsp1OCd6csHCnU4A3Jyzb6ZTgzVtittMpwZufYT1Op5tWCXc6PRczuNMpwJvPYdlOpwRv3hKznU4J3pywcKdTgDcnLNvplODNW2K20ynBi+/DHrjT6bnbwJ1OAd6csGynU4JHJ2yCN2+JzU6n43E63cGbExbudHqGZzudErx5S8x2OiV4zTPsTauEO52eixnc6RTgzeewbKdTgjefw7KdTgEe7nR6nvNwp1OANycs2+mU4NkJG+DNW2Kz0+mYnU7H7HQ6YqfTvjxOpy8PIy9475b4Bc9O2ADv3RK/4NEJm+C9W+IXvPcZ9gXvTdgXvDdhX/DmhBU7nV7w3mfYF7z3ts4L3ntb5wWPTtgEb05YttMpwXu3xC9475b4BW9OWLbTKcGbE1bsdHrBe7fEL3h2wgZ4rzXxBe+1Jr7gvbd1XvDmhGU7nQI82+mU4L23dV7w5oRlO50SvDlhxU6nF7z3HPYFb94Se5xON8UM7nR67jZwp1OANycs2+mU4M3nsGynU4I3Jyzb6ZTgzQnLdjolePOWWOx0esFrtsQ3xQzudHruNnCnU4A3Jyzb6ZTgzeewbKdTgjcnLNvpFODZTqcEbz6HZTudErx5Syx2Or3gzeewcKfTczGDO50CvPkclu10CvBsp1OCN2+J2U6nMOfZTqcEb05YttMpwZu3xGKn0wvefA4Ldzo9dxu40ynAmxOW7XRK8OZzWLbTKcGbE5btdErw5oRlO50SvHlL7HE63XQbuNPpuR7AnU4B3pywbKdTgjefw7KdTgnenLBip9MLXpywxeN0uoMXn8MWuNMpwHu9xC94dMI+d5vCdjoleHHCFrbTKcGLz2EL2+kU4M1Op2J2OhWP0+kOXnwOW+BOpwAv3hIXttMpFDO20yl0G7bTKcGLz2HLx51O59df4x+foP6Vp8B4KoynwXg6jGfAeCaM59Mxcc7PL/6hq3weVvOcn+xlfEXfXvSjRf+4kuiN6MWLXr3ozYvevejDiz696N40bd40bd407d407d407d407d40/bh26I3o3jTt3jTt3jTt3jTt3jQd3jQd3jQd3jQd3jT9uGLojejeNB3eNB3eNB3eNB3eNJ3eNJ3eNJ3eNJ3eNP24TuiN6N40nd40nd40nd40nd40Xd40Xd40Xd40Xd40/bg66I3o3jRd3jRd3jRd3jRd3jTd3jTd3jTd3jTd3jT9uCbojejeNN3eNN3eNN3eNN3eND3eND3eND3eND3eNP24EuiN6N40Pd40Pd40Pd40Pdo0rZc2TeulTdN6adO0Xto0rZc2TeulTdN6adO0Xto0rZc2TevlTdPiTdPiTdPiTdPiTdOPq37eiO5N0+JN0+JN0+JN0+JN0+pN0+pN0+pN0+pN08+riN6H7k3T6k1Trwupel1I1etCql4XUvW6kKrXhVS9LqTqdSFVrwupel1I1etCql4XUvW6kKrXhVS9LqTqdSFVrwupel1I1etCql4XUvW6kKrXhVS9LqTqdSFVrwupel1I1etCql4XUvW6kKrXhVS9LqTqdSFVrwupel1I1etCql4XUvW6kKrXhVS9LqTqdSFVrwupel1I1etCql4XUv28C2mVv9H3V54K42kwng7jGTCeCeNZMJ4N4zksns+LeAIPbD5/XJlTa/0ZX69w+MrTYDwdxjNgPBPGs2A8G8ZzWDwfV7skngLjgc3nA5vPBzafD2w+H9h8PrD5fGDz+bDmc7tY87ldrPncLtZ8bhdrPreLNZ/bxZrP7WLN53ax5nO7WPO5XbD5XGDzucDmc4HN5wKbzwU2nwtsPhfYfC6w+Vxg87nA5nOFzecKm88VNp8rbD5X2HyusPlcYfO5wuZzhc3nCpvPDTafG2w+N9h8brD53GDzucHmc4PN5wabzw02nxtsPnfYfO6w+dxh87nD5nOHzecOm88dNp87bD5//HJw3esnz2uZ+pXnsHg+fo038RQYz6fn8yg//81rrOtfeb5+8evv/vjri1//NL/CNzN8N8MPMnzZ/Rf8dX2Fn2b4ZYbfZvhj+YXtX96jbh+/gPtW+GKG1yTsHbwmYe/gNQl7B49O2ASPTtgEj07YBI9O2ARvTthlTthlTthlTthlTtiP3w5+K7w5YZc5YZc5YZc5YZc5Ybc5Ybc5Ybc5Ybc5YT9+v/ut8OaE3eaE3eaE3eaE3eaEPeaEPeaEPeaEPeaE/fgN/bfCmxP2mBP2mBP2mBP2iBO2X+KE7Zc4YfslTth+iRO2X+KE7Zc4YfslTth+iRO2X+KE7Zc5YYs5YYs5YYs5YYs5YT9uyXgrvDlhizlhizlhizlhizlhqzlhqzlhqzlhqzlhP+45eSu8JmG/XjXqVXxbp1fxbZ1exbd1ekUnbIBv5oRt5oRt4vuwvbETds+f8O2qX+HZCRvgxfdhezMnbDMnbDMnbDM/w3ZzwnZzwnbzM2w3P8N+3DX0VnjzM2xnb4mfu01nb4kDvDlhu/kZdqATNsGjEzbBmxPW43S6gzcnLNvplOA157A39YDtdAoJy3Y6JXhzwrKdTgnenLBsp1OCNyes2enUzU6nbnY6dbPTqXucTjfdBu50eq4HcKdTgDcnLNvplODRCZvg0Qmb4M0Ja3Y6dbPTqZudTt3sdOpmp1P3OJ1uihnc6fTcbeBOpwBvTli20ynBm990YjudErw5Yc1Op252OnWz06l7nE439QDudHpOWLjTKcCbE5btdErw5oRlO50SvDhhh9npNMxOp2F2Og2z02lc7IQN8OJ3iQfc6fTYbQbc6RTgxQk72E6nAM92OiV48TnsMDudhtnpNMxOp2F2Og2z02mYnU7D7HQaHqfTTauEO52eixnc6RTgxW86DbbTKcGjEzbBi7fEg+10CnOe7XRK8OaEZTudArzH6XRTD+BOp+eEhTudArw5YdlOpwRvTliz02mwnU5pzpsT1ux0Gman0zA7nYbZ6TQ8TqebYgZ3Oj13G7jTKcCbE5btdErw5nNYs9NpsJ1OYc6znU4J3pywZqfTMDudhtnpNMxOp2F2Og2z02mYnU7D7HQaZqfTMDudhtnpNMxOp2F2Og2z02mYnU7D43S6gze/6WR2Og220ynBmxPW7HQaZqfTYDudErw5Yc1Op2F2Og2z02mYnU7D43S6gzdvieFOp+dWyXY6hWLGdjolePM5rNnpNNhOpwRv3hKbnU7D7HQaHqfTHbx5Swx3OgV485aY7XQKxYztdArdhu10SvDihJ1sp1OCF5/DTrbTKcGLE3Ze4oSdHqfTHbx4SzzhTqcAL/5sncl2Oj3Xg8l2OiV4c8KynU4JXnwOO9lOpwRvTliz02manU7T7HSaHqfTDTzc6RTgxZ+tM9lOp9Bt2E6nBG9OWLPTabKdTglefA47zU6naXY6TY/T6Q5efA474U6nAG/eErOdTgne/AzLdjoleM0z7E2fhzudnisx3On0DM92OoVixnY6JXjzlpjtdErw5oSFO50CvDlh2U6nBG9+hmU7nUK3gTudnusB3OkU4M0Jy3Y6JXh0wiZ485bY43S6mfNwp1OANycs2+kU4NlOpwRv3hKznU6hmMGdTs/dBu50CvDmhGU7nRK8+RyW7XRK8OaEhTudArw5YdlOpwRvPodlO50SvPgT2Cfc6fTcbeBOpwBvTli20ynAs51OCd58Dmt2Ok2P0+kO3pywcKdTgDdvidlOpwRv3hKznU6hVcKdTs/FDO50CvDmc1i20ynBoxM2wZu3xB6n082chzudArw5YdlOp2f4xXY6JXjxlnixnU4JXuwlXhc6YZ+L2YI7nQK8+Bx2sZ1OCV68JV5sp1OAhzudnuc82+mU4M0Jy3Y6JXh2wgZ48ZZ4mZ1Oy+N0ummVcKfTczGDO52e4dlOp1AP2E6nBC/eEi+20ynBmxOW7XRK8OaEZTudErx4S7w8TqebbgN3Oj3XA7jTKcCbE5btdErw6IRN8OJz2GV2Oi2P0+kO3pywcKfTMzzb6ZTgzVtittMpwZvPYeFOp+diBnc6BXjzOSzb6ZTgzeewbKdTgIc7nZ7nPNzpFODNCct2OiV4dsIGePOW2Ox0Wman0zI7nZbH6XTT5+FOp+dKDHc6BXjzlpjtdErw6IRN8OYtMdvpFOY82+mU4M0Ja3Y6LbPTaXmcTjfdBu50eq4HcKdTgDcnLNvplODNW2K20ynBmxOW7XQK8GynU4I3b4nNTqdldjotj9PpppjBnU7P3QbudArw5oRlO50SvPkclu10SvDmhGU7nRK8OWHZTqcEbz6HNTudlsfpdFPM4E6n524Ddzo9wm+20+k5YTfb6ZTgxeewm+10SvDihN1wp1OAFyfsZjudErx4S7zZTqcA73E6fS1mG+50eu42cKdTgDcnLNvplODF57Cb7XRK8OaEhTudArw5YdlOpwQv3hJvttMpwYu3xNvjdLpplXCn03MxgzudArz4HHaznU4JXnwOu9lOpwRvTli20ynBmxOW7XRK8OYtsdnptD1Op5tiBnc6PXcbuNPpGZ7tdAoJy3Y6JXjzOSzb6ZTgzQkLdzoFeHPCsp1OCd68JWY7nUK3gTudnusB3OkU4M0Jy3Y6JXh0wiZ48zms2em0zU6nbXY6bY/T6QYe7nQK8OYtMdvpFIoZ2+kUug3b6ZTgzQnLdjolePM5LNvplODNCWt2Om2P0+kO3nwOC3c6BXh2wgZ485aY7XRK8OZnWI/T6abPw51Oz5UY7nQK8OZzWLbTKcGbt8Rsp1OCNycs3OkU4M0Jy3Y6JXjzMyzb6ZTgxV7iDXc6PXcbuNMpwJsTlu10SvDmLTHb6ZTgzQkLdzo9wh+20ynBi7fEh+10SvDiLfG50Amb4DXPsF9b5YE7nR6L2YE7nQK8+Bz2sJ1OAZ7tdErw4i3xgTudnuc82+mU4M0Jy3Y6JXjxlviYnU7H7HQ6ZqfT8Tidbiox3On03CrhTqcALz6HPWynU4IXb4kP2+mU4M0Jy3Y6JXhzwrKdTgnevCU2O52O2el0zE6n43E63VRiuNPpuVXCnU4B3rwlZjudArzZ6XTMTqfDdjqFOc92OiV4c8KanU7H7HQ6ZqfTMTudjsfpdAMPdzo9V2Kz0+mwnU4J3rwlNjudjtnpdNhOpwRvTliz0+mYnU7H7HQ6ZqfT8Tid7uA1z7A3xczsdDpsp1OCNyes2el0zE6nw3Y6BXiz0+mYnU7H7HQ6ZqfTMTudjsfpdNNt4E6n53oAdzoFeHPCsp1OAZ7tdErw5nNYttMpzHm20ynBmxPW7HQ6ZqfTMTudjsfpdFPM4E6n524DdzoFeHPCsp1OCd58Dmt2Oh220ynMebbTKcGbE9bsdDpip9O5xE6nF7x3S/yC9z7DvuC957AveHTCPrbKF7z3HPYF7z2HfcF7z2Ff8N4t8QveuyU+F9vpFOY82+mU4M0JK3Y6veDZCRvgveewL3jvOewL3nsO+4I3Jyzb6RTg2U6nBO/dEr/gzQnLdjoleHPCsp1OCd67JX7Be7fEL3jvOewL3nsOey640ynAmxOW7XRK8N5z2Bc8OmETvDlh4U6nAG9OWLbTKcGbz2HZTqcE7/30uhe81zjxgvd+et0L3pywbKdTgjefw7KdTgnenLBip9O5PE6nO3jzOSzc6RTgzVtittMpFDO20yl0G7bTKcGbE5btdErw5nNYttMpwZsTVux0esGbExbudArw5i0x2+mU4M1bYrbTKbRKttMpFDO40ynAm89h2U6nBG8+h2U7nRK8OWHhTqcAb05YttMpwZu3xGynU4I3P8N6nE43rRLudHouZnCnU4A3n8OynU4J3rwlZjudErw5YeFOpwBvTli20ynBm7fEbKdTgjffh4U7nZ67DdzpFODNCct2Oj3DF7bTKcGLt8TF7HQqHqfTHbw4YQvc6RTgxVviwnY6JXjxlriwnU7PrbLAnU6PxazAnU4BXnwOW9hOpwSPTtgEL94SF7jT6XnOw51OAd6csGynU4BnO50SvHhLXMxOp2J2OhWz06mYnU7F43S6eRiBO52e+zzc6RTgzVtittMpwZu3xGanU2E7ncKcZzudErw5Yc1Op2J2OhWP0+mm28CdTs/1AO50CvDmhGU7nRK8eUtsdjoVttMpzHm20ynBmxPW7HQqZqdTMTudisfpdFPM4E6n524DdzoFeHPCsp1OCV58W6eYnU6F7XRKc96csGynU4I3n8OanU7F7HQqHqfTTTGDO52euw3c6RTgzQnLdjolePM5LNvplODNCct2OiV4c8KynU4J3rwlNjudisfpdFPM4E6n524Ddzo9w7OdTiFh2U6nBG8+h2U7nRK8OWHZTqcEb05YttMpwZu3xGanUzE7nYrH6XTTKuFOp+diBnc6BXh0woZ6wHY6JXjzOSzb6ZTgzQnLdjo9w1e20ynBi7fE1ex0qmanU726t5hVuNPpsdtUuNMpwIsTtrKdTglefA5b2U6nBG9OWLbTKcGbE5btdErw4i1x9TidbroN3On0XA/gTqcAb05YttMpwYvPYSvb6ZTgzQlrdjpVs9OpepxOd/Dic9gKdzoFeLGXuLKdTqHbsJ1OCd6csGynU4JHJ2yCF5/DVrPTqZqdTtXjdLqDN5/Dwp1OAd68JWY7nUIxYzudQrdhO50SvPkc9uNOp/Prr/E6o3zlWTCeDeM5LJ6P+5EST4HxVBjPp2PinJ9fvK/Sn4fVPOcnexlf0bsXfXjRpxd9edG3F/1o0T+uInojevGiVy+6N00/riB6I7o3Tac3Tac3Tac3Tac3TZc3TZc3TZc3TZc3TT+uG3ojujdNlzdNlzdNlzdNlzdNtzdNtzdNtzdNtzdNP64WeiO6N023N023N023N023N02PN02PN02PN02PN00/rhF6I7o3TY83TY83TY83TY82TdulTdN2adO0Xdo0bZc2TdulTdN2adO0Xdo0bZc2TdulTdN2edO0eNO0eNO0eNO0eNP043qgN6J707R407R407R407R407R607R607R607R60/TjKqA3onvTtHrTtHrTtHrTtHrTtHnTtHnTtHnTtHnT9OPanzeie9O0edO0edO0edO0edO0e9O0e9O0e9O0e9P044qfN6J707R707R707R707R703R403R403R409TrQmpeF1LzupCa14XUvC6k5nUhNa8LqXldSM3rQmpeF1LzupCa14XUvC6k5nUhNa8LqXldSM3rQmpeF1LzupCa14XUvC6k5nUhNa8LqXldSM3rQmpeF1LzupCa14XUvC6k5nUhNa8LqXldSM3rQmpeF1LzupCa14XUvC6k5nUhNa8LqXldSM3rQmpeF1LzupCa14XUPu9CWuVv9P2VZ8N4Doqnf15FFHgKjKfCeBqMp8N4BoxnwnhY87l/XJlTa/0ZX3XVrzyHxfNxuU3iKTCeCuNpMJ4O4xkwngnjWTAe2HwusPlcYfO5wuZzhc3nCpvPFTafK2w+V9h8rrD5XGHzucLmc4PN5wabzw02nxtsPjfYfG6w+dxg87nB5nODzecGm88dNp87bD532HzusPncYfO5w+Zzh83nDpvPHTafO2w+D9h8HrD5PGDzecDm84DN5wGbzwM2nwdsPg/YfB6w+Txh83nC5vOEzecJm88TNp8nbD5P2HyesPk8YfN5wubzgs3nBZvPCzafF2w+f/xycN3rJ08r5SvPgPFMGM+C8Xx6Po/y89+8xrr+lefrF7/+7o+/vvj1T/Mr/BHD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X7BJvS/YpN4XbFLvCzap9wWb1PuCTep9wSb1vmCTel+wSb0v2qQutEldaJO60CZ1oU3qQpvUhTapC21SF9qkLrRJXWiTutImdaVN6kqb1JU2qSttUlfapK60SV1pk7rSJnWlTepGm9SNNqkbbVI32qRutEndaJO60SZ1o03qRpvUjTapO21Sd9qk7rRJ3WmTutMmdadN6k6b1J02qTttUnfapB60ST1ok/rjF5DrXj+BWik3QI0G1GlAgwb06Uk9ys9/8xrr+legr1/8+gUYf33x65/mDf1S0281/SHTl91/0V/XV/qPX+59L31R01c1fbP81vZ9Q9/V9ENNr8naW3pN1t7Sa7L2lh6dtYl+obM20qOzNtKjszbSq7P24xd/30uvztqlztqlztqlztqlztqtztqtztqtztqtztqP38d+L706a7c6a7c6a7c6a7c6a486a486a486a486az9+o/699OqsPeqsPeqsPeqsPeasPZc5a89lztpzmbP2XOasPZc5a89lztpzmbP2XOasPZc5a8+lztqiztqiztqiztqiztqPWy3eS6/O2qLO2qLO2qLO2qLO2qrO2qrO2qrO2qrO2o97Sd5Lr87aqs7aqs7aqs7aqsnamxtLp5nv/JxmvvNzmvnOz2norI306qxt6qxt5vu1p7Gzds+f9O2qN/TsrE305vu1p6uztquztquztqufaz/uBnovvTpru/q5tqufa7v6ubarn2sHe4cces5g75ATvTprh/q59uN2p/fSo7M20quz1uONuqVXZy3bG5Xo2d6o1BTY3qiUtWxvVKRXZy3bGxXp1VnL9kZFenXWqr1RR+2NOmpv1FF7o47HG3XXc+DeqNAU4N6oRK/OWrY3KtKjszbSo7M20quzVu2NOmpv1FF7o47aG3XU3qjj8UbdtTS4Nyr0HLg3KtGrs5btjUr0bG9UpFe/G6X2Rh21N+qovVFH7Y06Hm/UXVOAe6NC1sK9UYlenLXtYnujIr04a1/04nejXvTirH3Ri7P2RS/O2he9+N2oF734vPZFLz6vfdGL30NuF9wb9dhzXvTid6Ne9OqsZXujIj06ayO9+Lz2Ra/OWrM36kWvzlqzN+oVAeLz2he9+Lz2RS/eIb/oNc+1dx0T7o0KLQ3ujUr04nejXvTid6Ne9OLz2he9eofM9kalec/2RkV6ddayvVGRnp21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XXndu/K6d+N178br3o3XvRuve7fOQ+J178br3o3XvRuvezde9+687t153bvzunfnde/ecd2787p353Xvzuvende9O697D173HrzuPXjde/C69+g8JF73HrzuPXjde/C69+B178nr3pPXvSeve09e954d170nr3tPXveevO49ed178rr34nXvxevei9e9F697r85D4nXvxevei9e9F697L1733rzuvXnde/O69+Z178/ftYzde/O69+Z1783r3pvXvTevex9e9z687s27a1l5dy0r765l5d21rLy7lpV317Ly7lpW3l3Lxrtr2Xh3LRvvrmXj3bVsF657N95dy8a7a9l4dy0b765l4921bJ+/a9l+ffXrn++GwOfvWmakykNqPKTOQxo8pI9P737VX0ivw7d/Rfr65fOcv754lXFDv9T0W01/zPSfvxf6Vvqipq9q+qam72r6oaZXZ21VZ21VZ21VZ21TZ21TZ21TZ21TZ+3nbxy/lV6dtU2dtU2dtU2dtU2dtV2dtV2dtV2dtV2dtZ+/H/5WenXWdnXWdnXWdnXWdnXWDnXWDnXWDnXWDnXWfv42/1vp1Vk71Fk71Fk71Fk71Fk71Vk71Vk71Vk71Vn7effCW+nVWTvVWTvVWTvVWTvVWbvUWbvUWbvUWbvUWft5U8Zb6dVZu9RZu9RZu9RZu9RZu9VZu9VZu9VZu9VZ+3mvyVvp1Vm71Vm71Vm71Vm71Vl71Fl71Fl71Fl71Fn7eQvNW+nVWXvUWXvUWXvUWXvMWdsvc9b2y5y1/TJnbb/MWdsvc9b2y5y1/TJnbb/MWdsvc9b2S521RZ21RZ21RZ21RZ21nzc8vZVenbVqb1RXe6O62hvV1d6orvZGdbU3qqu9UV3tjepqb1RXe6O62hvV1d6orvZGdbU3qqu9UV3tjepqb1RXe6O62hvV1d6orvZGdbU3qqu9UV3tjepqb1RXe6O62hvV1d6orvZGdbU3qqu9UV3tjepqb1RXe6O62hvV1d6orvZGdbU3qqu9UV3tjepqb1RXe6O62hvV1d6o/nlvVNvtb/p23SAVHlLlITUeUuchDR7S5CEtHtLmIX1+0I/5N9JYX5F+g4koIn3+8eeUX0hj7BukykNqPKTOQxo8pMlDWjykzUM6OKTf4LaJSLzpvXnTe/Om9+ZN782b3ps3vTdvem/e9N686X140/vwpvfhTe/Dm96HN70Pb3of3vQ+vOl9eNP74Kb3uHDTe1y46T0u3PQeF256jws3vceFm97jwk3vceGm97hw03tcvOldeNO78KZ34U3vwpvehTe9C296F970LrzpXXjTu/Cmd+VN78qb3pU3vStvelfe9K686V1507vypnflTe/Km96NN70bb3o33vRuvOndeNO78ab35+9cz/b3G8az3yEtHtLmIR0c0ufvMc+1fiGtq98gfXx6r9H/Rlr1Bqny/uAaD6nzkAYPafJ+4xbvN443vTtven/+ZmxGKjykivuN+/zF1PgbN3jTe/Cm9+B178Hr3p+/wZl/4w7uN27ypvfkTe/J696T170/f9cy/sZ9/q5l/o3jTe/Jm96T170nr3sv3uZk8TYnize9F296f/6uZUbide/F25ws3uZk8ab34k3vzevem9e9N29zsnmbk82b3ps3vTeve29e9968zcnmbU4Ob3of3vQ+vO59eN3783ct42/c4W1ODm96H970PrzufXDde164zcm8cJuTeeGm97xw03teuO49L1z3nhduczIv3OZkXrjpPS/e9C647j0LrnvPgtuczILbnMzCm96FN70LrnvPguves+A2J7PgNiez8qZ35U3vyuvelde9P3/XMv7GVdzmZFbe9K686V153bvyunfjbU4ab3PSeNO78ab35+9aZiRe9268zUnjbU54dy0n767l7Lzu3Xndu/M2J523OeHdtZy8u5az87p353XvztucdN7mhHfXcvLuWs7B696D171/w13L9Bs3eJsT3l3LybtrOQevew9e9568zcnkbU54dy0n767l/A13LSMSr3tP3uZk8jYnvLuWk3fXci5e91687r14m5PF25zw7lpO3l3LuXjde/G69+JtThZvc8K7azl5dy3n5nXvzevev+GuZfqN27zNCe+u5eTdtZyb1703r3sf3ubk8DYnvLuWk3fXcv6Gu5YRide9D29zcnibE95dy8m7a7kuXPdeF657rwu3OVkXbnPywuT9weGm97pw3XtduO69LtzmZF24zcni3bVcvLuWq+C69yq47r1+w13L9BtXcJuTxbtruXh3LVfBde9VeN274jYnq+I2J4t313Lx7lqu33DXMiLxunfFbU5WxW1OFu+u5eLdtVyN170br3s33uak8TYnvLuWi3fXcvE+13LxPtdyNd7mpPE2J7y7lot313LxPtdy8T7Xcv2Gu5bpN67zNie8u5aLd9dy8T7XcvE+13IN3uZk8DYnvLuWi3fXcvE+13LxPtdyDd7mZPA2J7y7lot313LxPtdy8T7Xck3e5mTyNie8u5aLd9dy8T7XcvE+13JN3uZk8jYnvLuWi3fXcvE+13LxPtdy/Ya7luk3bvE2J7y7lot313LxPtdy8T7Xcm3e5mTzNie8u5aLd9dy8T7XcvE+13Jt3uZk8zYnvLuWi3fXcvE+13LxPtdyHd7m5PA2J7y7lot313LxPtdy8T7Xch3e5uTgNiebd9dy8+5abt7nWm7e51ruq9N+4/aF25xs3l3LzbtruXmfa7l5n2u5C25zsgtuc7J5dy03767l5n2u5eZ9ruUuuM3JLrjNyebdtdy8u5ab97mWm/e5lrviNie74jYnm3fXcvPuWm7e51pu3uda7orbnOzK25zw7lpu3l3Lzftcy837XMv9G+5apt+4xtuc8O5abt5dy837XMvN+1zL3Xmbk87bnPDuWm7eXcvN+1zLzftcy915m5PO25zw7lpu3l3Lzftcy837XMs9eJuTwduc8O5abt5dy837XMvN+1zLPXibk8HbnPDuWm7eXcvN+1zLzftcy/0b7lqm37jJ25zw7lpu3l3Lzftcy837XMu9eJuTxducfP6u5evQ/RfSa+N2g9R4SB+f3q//5C+kc13/ivT1y+e5yl9fPU9Zv7643H3x6wj257/6dc5Y//WL//pmx3f6Zud3+mbXd/pm93f6Zs83+mY/fw/3d36z5Tt9s/U7fbPtO32z/dPf7Bl/PyCc3b6Wus/fd85Ik4e0eEibh3RwSJ+/75yRCg/p04lTruvXlqBcbT0P4fKaq+Pnl9c+T5rZ568vXmXcfLPtO32z/Tt9s+M7fbPzO32z6zt9s/s7fbPn+3yz5+P393/rN1u+0zf7jRrUub5RgzpX/07f7DdqUOf6Rg3qXN+oQZ3rGzWoc32nBlW+U4Mq36lBle/UoMp3alAfd5X81m/2OzWo8p0aVPlODap8pwZVvlODqt+pQdXv1KDqd2pQ9Ts1qI/7gn7rN/udGlT9Tg2qfqcGVb9Tg6rfqUG179Sg2ndqUO07Naj2nRrUx51dv/Wb/U4Nqn2nBtW+U4Nq36lBte/UoPp3alD9OzWo/p0aVP9ODerj3rzf+s1+pwbVv1OD6t+pQfXv1KD6d2pQ4zs1qPGdGtT4Tg1qfKcG9XF35W/9Zr9TgxrfqUGN79SgxndqUOM7Naj5nRrU/E4Nan6nBjW/U4P6uD/2t36z36lBze/UoOZ3alDzOzWo+Z0a1PpODWp9pwa1vlODWt+pQX3c4fxbv9nv1KDWd2pQ6zs1qPWdGtT6Tg1qf6cGtb9Tg9rfqUHt79SgPu5w/q3f7HdqUPs7Naj9nRrU/k4Nan+nBnW+U4M636lBfScn+flOTvLznZzk5zs5yc93cpKf7+QkP9/JSX6+kZN8XN/ISf76Zr9Pg3p9s9+nQb2+2e/ToF7fbP9O3+z3aVCvb/b7NKjXN/t9GtTrm/0+Der1zX6nBvWNnOSvb/Y7Nahv5CR/fbPfqUF9Iyf565v9Tg3qGznJX9/sd2pQ38hJ/vpmv1OD+kZO8tc3+50a1Ddykr++2e/UoL6Rk/z1zX6nBvWNnOSvb/Y7Nahv5CR/fbPfqUF9Iyf565v9Tg3qGznJX9/sd2pQ38hJ/vpmv1OD4jvJ6/z7m13r5jvA16L4HeC7TvwO8AUmfQd8z3f8DvBVI34H+P4QvwN8KYjfAT7p43dAj++xrl/fwbzG85eP3n5+9eh9/vricvfF65RfYX/+BaT8+tnQ0/53/mzoPeJ3/mzoDeV3/mzo3ec3/mzw7u/f+bOh97Xf+bOhN8Hf+bOhd8zf+bPpf342//iz+dOL//ln86cX//PP5k8v/uefzZ9e/M8/mz+9+B9/Nnij++/82fzpxf/8s/nTi//5Z/OnF//zz6b/+dn848/mTy/+55/Nn178zz+bP734n382f3rxP/9s/vTif/zZ4D39v/Nn86cX//PP5k8v/uefzZ9e/M8/m/7nZ/OPP5s/vfiffzZ/evE//2z+9OJ//tn86cX//LP504v/8WeD//SF3/mz+dOL//ln86cX//PP5k8v/uefTf/zs/nHn82fXvzPP5s/vfiffzZ/evE//2z+9OJ//tn86cX/+LPBf6bG7/zZ/OnF//yz+dOL//ln84ZevPrP77bvWsPP5jq/bnSV+ve/uZR599Vr159fvf/lB/Pjq//i73L+gebf7W/+vu74p5x/yfm3nP+w+fevybxP/cpf3vEpFb+Vv8j5q5yfnb+Zn52/mR+ev3P/zd/u+OH5G/nZ+Zv6W7nY+Zv52fn7r/zl7u9PYedv5ofnb+hvpcDzN/LD8zfyw/M38sPzN/WHAs/fyA9//o388OffyC9//q3y598Kz9/Unys8fyO/e/9c3mGb/6387PyN/bmy8zfzu/fPpbr3z6XC8zfxN3j+Rn75/rnJ989Nvn9+h6v8t/LLn3+b/Pm3wfM39ecGz9/I79k/3/bn7tk/3/Oz8zf2587O38wv3z+/wyD+W/nd71+V7n7/qnT5/rnL989dvn8e8v3zkD//Dvnz74Dnb+rP73Ag/1Z+z/75tj8Pz/75nt/z/tVtfx6e96/u+eX75ynfP0/5+1dT/v7VlO+f3+Fa/a388v3zlO+fp/z5d8qffyc8f1N/XvD8jfye/fNtf16e/fM9v+f9q9v+/A6n42/ll++fl3z/vOTvXy35+1dLvn/e8v3zlu+ft3z/vOXPv+9wx/1Wfvn93y2//7vl93+3/P7vlt//PfL7v0e+fz7y/TPcf5X54fkb+eX7Z7r/KvLL9890/1Xkdz//Vrn/qtL9V6E/V7r/KvK77//Wi52/md99/7fC/VeZ371/rnD/VeZ3v39V4f6rzO/eP1e6/yryu/fPle6/ivzu598q919Vuv8q9We6/yryu+//Vrj/KvO77/9WuP8q87v3zxXuv8r87vevKtx/lfnd++dK919Ffvn+me6/ivzy51+5/6rS/VepP9P9V5Hfff+3wv1Xmd99/7fC/VeZX75/hvuvMr/7/asK919lfvn+me6/ivzy/TPdfxX55c+/cv9VpfuvUn+m+68iv/v+b4X7rzK/+/5vhfuvMr98/wz3X2V++ftXcP9V5pfvn+n+q8gv3z/T/VeRX/78K/dfVbr/KvVnuv8q8rvv/1a4/yrzu+//Vrj/KvPL989w/1Xml79/BfdfZX75/pnuv4r88v0z3X8V+eXPv3L/VaX7r1J/pvuvIr/8/i/cf5X55fd/4f6rzC/fP8P9V5lf/v4V3H+V+eX7Z7r/KvLL9890/1Xklz//yv1Xle6/Sv2Z7r+K/O77vw3uv8r87vu/De6/yvzu/XO74Pkb+d3vXzW4/yrzu/fPje6/ivzu/XOj+68iv/v5t8n9V43uvwr9udH9V5Hfff+3wf1Xmd99/7fB/VeZ371/bnD/VeZ3v3/V4P6rzO/ePze6/yryu/fPje6/ivzy51+5/6rR/VepP9P9V5Hfff+3wf1Xmd99/7fB/VeZX75/hvuvMr/7/asG919lfvn+me6/ivzy/TPdfxX55c+/cv9Vo/uvUn+m+68iv/v+b4P7rzK/+/5vg/uvMr98/wz3X2V++ftXcP9V5pfvn+n+q8gv3z/T/VeRX/78K/dfNbr/KvVnuv8q8rvv/za4/yrzu+//Nrj/KvPL989w/1Xml79/BfdfZX75/pnuv4r88v0z3X8V+eXPv3L/VaP7r1J/pvuvIj87f0/79dVnXjf8cP9V5mfn7zn9r6+uV+13/Oz8zfzs/M387PzN/Oz8zfzs/M387PzN/Oz8zfzw/E38cP9V5pfnL9x/lfnl+Qv3X2V+ef7C/VeZX56/cP9V5nfnb4f7rzK/O3873H+V+d352y93/na4/yrzu/O3w/1Xmd+dvx3uv4r8cP9V5pfnL9x/lfnR+VuvX+cX9Rq3/Oj8/b/A/4b8PfXnIWc/qzzz1/rrjYxa+99fXNq4+27/D/beLUuuY2eTnFJsd/ht/hPrzVWHpLR+Qki1ENwM2PemB3aecCt4hyEry/waZ/047rT9lxOsX8/b9fP/wun89cSv8/3EE3fihTvxxp340E6cUf76sBNfuBM33Ik77sSGOzHOuRrOuRrOuRrOuRrOuTrOuTrOuTrOuTrOuTKqdX/Oidvr9To/fs11n/lvJ/7Fz2+vn//P4lrvf/27/Nd3QqUc7S2ESjndWwiVcsC3ECrljG8hVMox30HISjnpWwiVcti3ECrlvG8hVMqR30LIRCggJKeOCMmpI0Jy6oiQnDoiJKcOCA05dURITh0RklNHhOBOff924wehcexvhH7178/Pz9NffQY/f6zvP3389bPs7/BN8J+DD98EnoUPXzKehQ/fX56FD1+NnoUP37oehT/hC92z8OG74rPw4Wvos/C14T4I3wT/OfjacB+Erw33QfjacB+Erw33QfjacJ+Dv7Th/hv4/frx8+//Hu0/wmdvuHO9xvefP5e9AvgRTPbGOvfPSZ577f8Ik72BJsM0wcyDyd4Qk2GyN75kmOwNLhkmeyNLhsnesHJhbvbGlAwTvgHlwtQGlAhTG1AiTBPMPJjagBJhagNKhKkNKBGmNqBEmNqA8mAebUCJMLUBJcLUBpQIUxtQIkwTzDyY2oASYWoDSoSpDSgRpjagRJjagNJgjpc2oESY2oASYWoDSoSpDSgRpglmHkz2BrSv8ePn7+v8/S+H/0eIvdbs+/+LH4TaX/9fCfz/Gjf2WvOVcWPvKsnjxt5VvjBuF3sByR23i72AfGXc2FtF8rixt4qvjJtp3PLGTatCNG5aFRLHTatCNG5aFRLHTatCMG61Hvx+eNxqvSX+lnHTqpA4bloVonEzjVveuGlViMZNq0LiuGlViMZNq0LiuGlVCMat1jv1D49b16oQjZtWhcRx06oQjZtp3PLGTatCNG5aFRLHTatCNG5aFRLHTatCMG6mVSFv3EyrQjRuWhUSx02rQjRupnHLGzetCtG4aVVIHDetCtG4aVVIHDetCsG4Da0KeeM2tCpE46ZVIXHctCpE42Yat7xx06oQjZtWhcRx06oQjZtWhcRx06oQjNvUqpA3blOrQjRuWhUSx02rQjRupnHLGzetCtG4aVVIHDetCtG4aVVIHDetCsG4wR8uzx03+EPkXxk3rQqJ4wZfFWzPHzDHNX41bvabCXXb34/Q10omdDO5fpz4nGF/I/S/Ew/ciSfuxAt34o078aGd+Lc/CP38iS/ciRvuxB13YsOdGOdcG+dcG+dcG+dcG+dcB+dcB+dcB+dcp5Rz/evfi7XX/v5ruqv13n7xe7Hf/ozq5xEq5XRvIVTKAd9CqJQzvoVQKcd8C6FSTvoGQvNVymHfQqiU876FUClHfgshOXVEyEQoICSnjgjJqSNCcuqIkJw6IiSnDghdcuqIkJw6IgR36vHzofJ2/8L1b4R+9e/Pz8/TX3/909Bf/vx//tPQecF1/Vn4JvjPwYcvGc/Ch+8vz8KHr0bPwodvXc/Chy90j8Jv8F3xWfjwNfRZ+NpwH4SvDfdB+Cb4z8HXhvsgfG24D8LXhvsgfG24D8LXhvtv4Pfrx8+//3u0/wa/szfcuV7j+8+fy14B/Agme2Od++ckz732f4TJ3kCTYbI3ymSYJph5MNkbXzJM9gaXDJO9kSXDZG9YyTDZG1MuTINvQLkwtQElwtQGlAhTG1AiTBPMPJjagBJhagNKhKkNKBGmNqBEmNqA8mAObUCJMLUBJcLUBpQIUxtQIkwTzDyY2oASYWoDSoSpDSgRpjagRJjagPJgTm1AiTC1ASXC1AaUCFMbUCJMQ8OMH4Sck73WpD4IOSd7rfnKuLF3leRxY+8qXxk39gKSO26LvYB8YdwWe6tIHjf2VvGVcWOvCsnjZhq3YNy0KiSOm1aFaNy0KiSOm1aFaNy0KuSNW623xN8xbrXeHn963LQqROOmVSFx3EzjFoybVoXEcdOqEI2bVoXEcdOqEI2bVoW8cTtaFYJxO1oVEsdNq0I0bloVEsfNNG7BuGlVSBw3rQrRuGlVSBw3rQrRuGlVSBu39dKq8M/jtl5aFRLHTatCNG5aFRLHzTRuwbhpVUgcN60K0bhpVUgcN60K0bhpVcgbt0urQjBul1aFxHHTqhCNm1aFxHEzjVswbloVEsdNq0I0bloVEsdNq0I0bloV8sataVUIxg3+yH3yuGlViMZNq0LiuJnGLRg3rQqJ46ZVIRo3rQqJ46ZVIRo3rQp54wZ/iPwL4wZ/XTx53OCrgu35A+a4xq/G7XevCna170cwu5IJ3UyuHyc+Z9jfCP3vxIY78cCdeOJOvHAn3rgTH9qJf/urzc+f+MKduOFOjHOu3/6S8PMnxjmX4ZzLcM5lOOcynHMNnHMNnHONUs71r38v1l77+8e5Wu/tF78XG6Uc7S2ETIQCQqUc8C2ESjnjWwiVcsy3ECrlpG8hVMph30FolnLetxAq5chvISSnjgjJqSNCJkIBITl1REhOHRGSU0eE5NQRITl1QGjJqSNCcKcePx8qb+PY3wj96t+fn5+nv/76p6G//PnBn4YuuK4/Cx++CTwL3wT/Ofjw/eVZ+PDV6Fn48K3rWfjwhe5Z+PBd8VH4G76GPgtfG+6D8LXhPghfG+6D8E3wn4OvDfdB+NpwH4SvDfdB+Npw/w38fv34+fd/j/Yf4bM33Lle4/vPn8teAfwA5mFvrHP/nOS51/6PMNkbaDJM9kaZDJO9ISbDNMHMg8ne4JJhsjeyZJjsDSsZJntjSoYJ34AyYe6XNqBEmNqAEmFqA0qEqQ0oEaYJZh5MbUCJMLUBJcLUBpQIUxtQIkxtQHkwL21AiTC1ASXC1AaUCFMbUCJME8w8mNqAEmFqA0qEqQ0oEaY2oESY2oDyYDZtQIkwtQElwtQGlAiTvQHFD0Lu3/7+9B9GKPNByN3Ya81Xxo29qySPG3tX+cq4sReQ5HFjLyBfGLfO3ipyx62zt4qvjBt7VUgeN60K0biZxi1v3LQqROOmVSFx3LQqROOmVSFx3LQqBONW6+3xh8et1rPmbxk3rQqJ46ZVIRo307jljZtWhWjctCokjptWhWjctCokjptWhWDchlaFvHEbWhWicdOqkDhuWhWicTONW964aVWIxk2rQuK4aVWIxk2rQuK4aVUIxm1qVcgbt6lVIRo3rQqJ46ZVIRo307jljZtWhWjctCokjptWhWjctCokjptWhWDcllaFvHFbWhWicdOqkDhuWhWicTONW964aVWIxk2rQuK4aVWIxk2rQuK4aVUIxg3+yH3uuMEfrf/KuGlVSBw3rQrRuJnGLW/ctCpE46ZVIXHctCpE46ZVIXHctCoE4wZ/XTx33OCvi2/b8wfMcY1fjdtvXxXW94/UxmskE7qZXD9OfM6wvxH634k77sSGO/HAnXjiTrxwJ964Ex/Yic/vf1r58RNfuBPTnOu8aM51XoY7Mc25zovmXOdFc67zojnXeeGc68I511XKuf7178Xaa3//Nd3Vem//9/di5yrlaG8hVMrp3kLIRCggVMoZ30KolGO+hVApJ30LoVIO+xZCpZz3HYRaKUd+CyE5dURITh0RklNHhEyEAkJy6oiQnDoiJKeOCMmpI0Jy6oBQhzv1+PlQeRvH/kboV//+/Pw8/fXXPw395c//5z8NPR2u68/Ch28Cz8KHLxnPwjfBfw4+fDV6Fj5863oWPnyhexY+fFd8Fj58DX0UvmnDfRC+NtwH4WvDfRC+NtwH4ZvgPwdfG+6D8LXhPghfG+6/gd+vHz///u/R/iN89oY712t8//lz2SuAH8Fkb6xz/5zkudf+bzAHewNNhsneKJNhsjfEZJjsjS8ZpglmHkz2RpYMk71hJcNkb0zJMOEbUC5MbUB5MKc2oESY2oASYWoDSoSpDSgRpglmHkxtQIkwtQElwtQGlAhTG1AiTG1AeTCXNqBEmNqAEmFqA0qEqQ0oEaYJZh5MbUCJMLUBJcLUBpQIUxtQIkxtQHkwtzagRJjagBJhsjeg+EHIs9lrTeqDkOf3P1X9cePG3lWSx429q3xl3NgLSPK4sReQr4wbe6vIHbfD3iq+MG6HvSokj5tWhWjctCokjptp3IJx06qQOG5aFaJx06qQOG5aFaJx06qQNW7zVetZ8/xxuwlpVUgcN60K0bhpVUgcN9O4BeOmVSFx3LQqROOmVSFx3LQqROOmVSFv3C6tCsG4XVoVEsdNq0I0bloVEsfNNG7BuGlVSBw3rQrRuGlVSBw3rQrRuGlVyBu3plUhGLemVSFx3LQqROOmVSFx3EzjFoybVoXEcdOqEI2bVoXEcdOqEI2bVoW8cetaFYJx61oVEsdNq0I0bloVEsfNNG7BuGlVSBw3rQrRuGlVSBw3rQrRuGlVyBs3+KP1Xxg3+MvyyeOmVSEaN60KieNmGrdg3LQqJI6bVoVo3LQqJI6bVoVo3LQq5I0b/HXxbXv+gDmu8Ytx++1Phg+7fhBar2RCN5Prx4nPGfY3Qv87ccOduONObLgTD9yJJ+7EC3fijTvxoZ34t79//PyJcc41cc41cc7129/kff7EOOeaOOeaOOeaOOeaOOdapZzrX/9erL12+/7zW+/tF78XW6Uc7S2ESjndWwiVcsC3EDIRCgiVcsy3ECrlpG8hVMph30KolPO+hVApR34HoS2njgjJqSNCcuqIkJw6ImQiFBCSU0eE5NQRITl1REhOHRGCO/X4+VB5G8f+RuhX//78/Dz99dc/Df3lzw/+NPTAdf1Z+PBN4Fn48CXjWfjw/eVZ+Cb4z8GHb13PwocvdM/Ch++Kz8KHr6HPwteG+xj866UN90H42nAfhK8N90H42nAfhG+C/xx8bbgPwteG+2/g9+vHz7//e7T/CJ+94c71Gt9//lz2CuBHMNkb69w/J3nutf8jTPYGmgvzYm+UyTDZG2IyTPbGlwyTvcElwzTBzIPJ3rCSYbI3pmSY8A0oF6Y2oESY2oDyYDZtQIkwtQElwtQGlAhTG1AiTBPMPJjagBJhagNKhKkNKBGmNqBEmNqA8mB2bUCJMLUBJcLUBpQIUxtQIkwTzDyY2oASYWoDSoSpDSgRpjagRJjagPJgmjagRJjsDSh+EPIy9lqT+iDkZey15ivjZhq3vHFj7ypfGTf2ApI8buwF5Cvjxt4qkseNvVV8YdwGe1XIHbdaT1W/Zdy0KiSOm1aFaNxM45Y3bloVonHTqpA4bloVonHTqpA4bloVgnGr9Qz6w+NW64X1t4ybVoXEcdOqEI2badzyxk2rQjRuWhUSx02rQjRuWhUSx02rQjBuS6tC3rgtrQrRuGlVSBw3rQrRuJnGLW/ctCpE46ZVIXHctCpE46ZVIXHctCoE47a1KuSN29aqEI2bVoXEcdOqEI2badzyxk2rQjRuWhUSx02rQjRuWhUSx02rQjBuR6tC3rgdrQrRuGlVSBw3rQrRuJnGLW/ctCpE46ZVIXHctCpE46ZVIXHctCr887g1+MvyqePW4C/Ff2XctCokjptWhWjcTOOWN25aFaJx06qQOG5aFaJx06qQOG7wVcH2/AFzXOMX4/bbnwyfr+8fqc0+kgndTK4fJz5n2N8I/e/EF+7EDXfijjux4U48cCeeuBMv3Ik37sSHduKGc66Gc66Gc66Gc67f/nDu8yfGOVfDOVfDOVfDOVcr5Vz/+vdi9y9Z2/ef33pvv/i9WC/laG8hVMrp3kKolAO+hVApZ3wLIROhgFApJ30LoVIO+xZCpZz3LYRKOfJbCMmpA0Imp44IyakjQnLqiJCcOiJkIhQQklNHhOTUESE5dUQI7tTj50PlbRz7G6Ff/fvz8/P011//NPSXPz/401CD6/qj8Ad8E3gWPnzJeBY+fH95Fj58NXoWvgn+c/DhC92z8OG74rPw4Wvos/C14T4IXxvuc/CnNtwH4WvDfRC+NtwH4WvDfRC+Cf5z8LXh/hv4/frx8+//Hu0/wmdvuHO9xvefP5e9AvgRTPbGOvfPSZ577f8Ik72BJsNkb5S5MBd7Q0yGyd74kmGyN7hkmOyNLBmmCWYeTPbGlAwTvgHlwtQGlAhTG1AiTG1AeTC3NqBEmNqAEmFqA0qEqQ0oEaYJZh5MbUCJMLUBJcLUBpQIUxtQIkxtQHkwjzagRJjagBJhagNKhKkNKBGmCWYeTG1AiTC1ASXC1AaUCFMbUCJMbUBpMPuLvQHFD0L2F3utSX0Qsr/Ya81Xxo29qySPm2ncgnFjLyDJ48ZeQL4ybuytInnc2FvFV8aNvSrkjlutp6rfMW61nrZ+ety0KkTjplUhcdxM4xaMm1aFxHHTqhCNm1aFxHHTqhCNm1aFvHGr9cL6O8at1ovsT4+bVoVo3LQqJI6badyCcdOqkDhuWhWicdOqkDhuWhWicdOqkDduXatCMG5dq0LiuGlViMZNq0LiuJnGLRg3rQqJ46ZVIRo3rQqJ46ZVIRo3rQp542ZaFYJxM60KieOmVSEaN60KieNmGrdg3LQqJI6bVoVo3LQqJI6bVoVo3LQq5I3b0KoQjNvQqpA4bloVonHTqpA4bqZxC8ZNq0LiuGlViMZNq0LiuGlViMZNq0LeuMFfiv/CuMGfc08eN60K0bhpVUgcN9O4BeOmVSFx3LQqROOmVSFx3OCrgu35A+a4xq/G7bevCuv6foT1eiUTuplcP058zrC/Efp/J/7973o/fuILd+KGO3HHndhwJx64E0/ciRfuxBt3YpxzbZxzbZxzbZxzbZxz/f7XbR8/Mc65Ns65Ns65dinn+te/F2uv3b7//NZ7+8XvxXYpR3sHoVPK6d5CqJQDvoVQKWd8C6FSjvkWQiZCAaFSDvsWQqWc9y2ESjnyWwjJqSNCcup/JmQvOXVESE4dEZJTR4Tk1BEhE6GAkJw6IiSnjgjBnXr8fKi8jWN/I/Srf39+fp7++uufhv7y5//zn4baC67rz8KHbwKPwr/gS8az8OH7y7Pw4avRs/DhW9ez8E3wn4MP3xWfhQ9fQ5+Frw33QfjacB+Erw33OfhNG+6D8LXhPghfG+6D8LXhPgjfBP9fwO/Xj59///do/xE+e8Od6zW+//y57BXAj2CyN9a5f07y3Gv/R5jsDTQZJnujTIbJ3hBzYXb2xpcMk73BJcNkb2TJMNkbVjJME8w8mPANKBemNqBEmNqAEmFqA0qEqQ0oD6ZpA0qEqQ0oEaY2oESY2oASYZpg5sHUBpQIUxtQIkxtQIkwtQElwtQGlAdzaANKhKkNKBGmNqBEmNqAEmGaYObB1AaUCFMbUCJMbUCJMLUBJcJkb0Dxg5A22WtN6oOQNtlrzVfGjb2rJI8be1f5yriZxi1v3NgLyFfGjb1VJI8be6v4yrixV4XkcdOqEIxbraetHx63Wq9mv2XctCokjptWhWjcTOOWN25aFaJx06qQOG5aFaJx06qQOG5aFYJxq/Ui+8PjVuux97eMm1aFxHHTqhCNm2nc8sZNq0I0bloVEsdNq0I0bloVEsdNq0IwbkerQt64Ha0K0bhpVUgcN60K0biZxi1v3LQqROOmVSFx3LQqROOmVSFx3LQq/PO4jZdWhbRxGy+tCtG4aVVIHDetCtG4mcYtb9y0KkTjplUhcdy0KkTjplUhcdy0KgTjdmlVyBu3S6tCNG5aFRLHTatCNG6mccsbN60K0bhpVUgcN60K0bhpVUgcN60KwbjBn3PPHTf48+xfGTetConjplUhGjfTuOWNm1aFaNy0KiSOG3xVsD1/wLzX9F+N2+9eFVZfPwjNmUzoZnL9OPE5w/5G6H8nPrQT//bHt58/8YU7ccOduONObLgTD9yJJ+7EC3dinHN1nHMZzrkM51yGcy7DOddvf4L2+RPjnMtwzmWlnOtf/16svXb7/vNb7+0XvxezUo72FkKlnO4dhEYpB3wLoVLO+BZCpRzzLYRKOelbCJkIBYRKOe9bCJVy5LcQklNHhOTUESE5dUBoyqkjQnLqiJCcOiIkp44ImQgFhOTUESG4U4+fD5W3cexvhH7178/Pz9Nff/3T0F/+/OBPQydc15+FD98EnoUPXzIehb/g+8uz8OGr0bPw4VvXs/DhC92z8E3wn4MPX0Ofha8N90H42nAfhK8N90H42nCfg7+14T4IXxvug/C14T4IXxvuv4Hfrx8///7v0f4jfEPDn+s1vv/8uewVwI9gsjfWuX9O8txr/0eY7A00GSZ7o0yGyd4Qk2GyN75cmIe9wSXDZG9kyTDZG1YyTPbGlAzTBDMPpjagRJjagBJhagNKhKkNKBGmNqA0mPOlDSgRpjagRJjagBJhagNKhGmCmQdTG1AiTG1AiTC1ASXC1AaUCFMbUB7MSxtQIkxtQIkwtQElwtQGlAjTBDMPpjagRJjagBJhagNKhMnegOIHIefFXmtSH4Scjb3WfGHcGntXSR439q7ylXFjLyDJ42Yat2Dc2FtF8rixt4qvjBt7VUgeN60K0bhpVcgbt1qvZr9j3Gq9sv30uGlViMZNq0LiuJnGLRg3rQqJ46ZVIRo3rQqJ46ZVIRo3rQp541brsfd3jFutx+GfHjetCtG4aVVIHDfTuAXjplUhcdy0KkTjplUhcdy0KkTjplUhb9yGVoVg3IZWhcRx06oQjZtWhcRxM41bMG5aFRLHTatCNG5aFRLHTatCNG5aFfLGbWpVCMZtalVIHDetCtG4aVVIHDfTuAXjplUhcdy0KkTjplUhcdy0KkTjplUhb9yWVoVg3JZWhcRx06oQjZtWhcRxM41bMG5aFRLHTatCNG5aFRLHTatCNG5aFfLGDf48+xfGDf6GevK4aVWIxk2rQuK4mcYtGDetConjBl8VbM8fMMc1fjVuv3tV2K/vP7nt3pIJ3UyuHyc+Z9jfCP3vxBt34kM78W9/Ifv5E1+4EzfciTvuxIY78cCdeOJOjHOug3OuQ3Ou9aI513rRnGu9aM61XjTnWi/DnZjmXOtVyrn+9e/F2mu37z+/9b9+nu+/F1uvUo72FkKlnO4thEo54DsIXaWc8S2ESjnmWwiVctK3ECrlsG8hZCIUECrlyG8hJKeOCMmpI0Jy6oiQnDog1OTUESE5dURITh0RklNHhEyEAkJwpx4/Hypv49jfCP3q35+fn6e//vqnob/8+f/8p6GrwXX9WfjwTeBZ+PAl41n48P3lUfgdvho9Cx++dT0LH77QPQsfvis+C98E/zn42nAfhK8N90H42nAfhK8N90H42nCfg2/acB+Erw33QfjacP8N/H79+Pn3f4/2H+GzN9xv/09Ivv/8b///4AB+BNPYMPfPSZ577f8Ik72BJsNkb5TJMNkbYjJM9saXDJO9weXCHOyNLBkme8NKhsnemJJhwjegXJgmmHkwtQElwtQGlAhTG1AiTG1AiTC1AeXBnNqAEmFqA0qEqQ0oEaY2oESYJph5MLUBJcLUBpQIUxtQIkxtQIkwtQHlwVzagBJhagNKhKkNKBGmNqBEmCaYeTC1ASXC1AaUCJO9AcUPQq7FXmtSH4Rci73WfGHcNntXyR23zd5VvjJu7AUkedzYC8hXxs00bnnjxt4qvjJu7FUhedy0KkTjplUhcdy0KgTjVuuV7YfHrdYD3m8ZN60KieOmVSEaN9O45Y2bVoVo3LQqJI6bVoVo3LQqJI6bVoV/Hrdd63H4Z8dt13p3/i3jplUhcdy0KkTjZhq3vHHTqhCNm1aFxHHTqhCNm1aFxHHTqhCM26VVIW/cLq0K0bhpVUgcN60K0biZxi1v3LQqROOmVSFx3LQqROOmVSFx3LQqBOPWtCrkjVvTqhCNm1aFxHHTqhCNm2nc8sZNq0I0bloVEsdNq0I0bloVEsdNq0Iwbl2rQt64da0K0bhpVUgcN60K0biZxi1v3LQqROOmVSFx3LQqROOmVSFx3LQqBOMGf0M9d9zgb6J/Zdy0KiSOm1aFaNxM45Y3bvBVwfb8AXNc41fj9ttXhfnjCPvsZEI3k+vHic8Z9jdC/zvxwp144058aCf+/c9YP37iC3fihjtxx53YcCceuBPjnGvgnGvgnGvgnGvinGvinGvinGvinOv3P+b6+IlLOde//r1Ye+32/ee3/tff0/34vdgs5WhvIVTK6d5CqJQDvoVQKWd8B6FVyjHfQqiUk76FUCmHfQuhUs77FkImQgEhOXVESE4dEZJTR4Tk1BEhOXVAaMupI0Jy6oiQnDoiJKeOCBmb0Pj5UHkbx/5G6Ff//vz8PP311z8N/eXPD/40dMN1/Vn48E3gWfjwJeNZ+PD95Vn48NXoUfgHvnU9Cx++0D0LH74rPgsfvoY+C98E/zn42nAfhK8N90H42nAfhK8N90H42nAfg39e2nAfhK8N99/A79ePn3//92j/ET57w53rNb7//LnsFcCPYLI31m+RoB8w99r/EaYJZh5M9kaZDJO9ISbDZG98yTDZG1wyTPZGlgvzYm9YyTDZG1MyTPgGlAtTG1AiTBPMPJjagBJhagNKhKkNKBGmNqBEmNqA8mA2bUCJMLUBJcLUBpQIUxtQIkwTzDyY2oASYWoDSoSpDSgRpjagRJjagPJgdm1AiTC1ASXC1AaUCFMbUCJME8w8mNqAEmGyN6D4QcjT2WtN6oOQp7PXmq+MG3tXyR03Y+8qXxg3Yy8gyePGXkC+Mm7srSJ53EzjFowbe1VIHjetCtG4aVVIHDetCtG4aVXIG7daD3i/Y9xqPfj99LhpVYjGTatC4riZxi0YN60KieOmVSEaN60KieOmVSEaN60KeeNW6935d4xbrXfqnx43rQrRuGlVSBw307gF46ZVIXHctCpE46ZVIXHctCpE46ZVIW/cllaFYNyWVoXEcdOqEI2bVoXEcTONWzBuWhUSx02rQjRuWhUSx02rQjRuWhXyxm1rVQjGbWtVSBw3rQrRuGlVSBw307gF46ZVIXHctCpE46ZVIXHctCpE46ZVIW/cjlaFYNyOVoXEcdOqEI2bVoXEcTONWzBuWhUSx02rQjRuWhUSx02rQjRuWhWyxm294G+ih+N2E9KqkDhuWhWicdOqkDhuxoZpe/6AOa7xq3H73avC6d8/UjtzJBO6mVw/TnyvQfY3Qv878cSdeOFOvHEnPrQT//a3pp8/8YU7ccOduONObLgT45zrwjnXhXOuC+dcF865Gs65Gs65Gs65Gs65fvuLq2898b/+vVh77fb957fe2y9+L9ZKOdpbCJVyurcQKuWAbyFUyhnfQqiUY76DUC/lpG8hVMph30KolPO+hVApR34LIROhgJCcOiIkp44IyakjQnLqiJCcOiBkcuqIkJw6IiSnjgjBnXr8fKi8jWN/I/Srf39+fp7++uufhv7y5wd/GvrbH8cU/L/Ah28Cz8KHLxnPwofvL8/Ch69Gz8KHb12Pwh/whe5Z+PBd8Vn48DX0WfjacB+Eb4L/HHxtuA/C14b7IHxtuA/C14b7IHxtuM/Bn9pw/w38fv34+fd/j/Yf4bM33Hnf/e8/fy57BfAjmOyNde6fkzz32v8RJnsDTYZpgpkHk70hJsNkb3zJMNkbXDJM9kaWDJO9YeXCXOyNKRkmfAPKhakNKBGmNqBEmCaYeTC1ASXC1AaUCFMbUCJMbUCJMLUB5cHc2oASYWoDSoSpDSgRpjagRJgmmHkwtQElwtQGlAhTG1AiTG1AiTC1AeXBPNqAEmFqA0qEqQ0oEaY2oESYJph5MNkb0BcehDzstSb3QcjDXmu+Mm7sXSV53Ni7Sjxu14u9gKSO2/ViLyBfGTf2VpE8buyt4ivjZhq3vHHTqhCNm1aFxHHTqhCNm1aFxHHTqhCMW60Hvx8et1pvib9l3LQqJI6bVoVo3EzjljduWhWicdOqkDhuWhWicdOqkDhuWhWCcav1Tv3D49a0KkTjplUhcdy0KkTjZhq3vHHTqhCNm1aFxHHTqhCNm1aFxHHTqhCMW9eqkDduXatCNG5aFRLHTatCNG6mccsbN60K0bhpVUgcN60K0bhpVUgcN60KwbiZVoW8cTOtCtG4aVVIHDetCtG4mcYtb9y0KkTjplUhcdy0KkTjplUhcdy0KgTjNrQq5I3b0KoQjZtWhcRx06oQjZtp3PLGTatCNG5aFRLHTatCNG5aFRLHTatCMG7wh8tzxw3+EPlXxk2rQuK4wVcF2/MHzHGNX42b/V5C/fX6/pP7q7dkQjeT68eJzxn2N0L/O/HAnXjiTrxwJ964Ex/aiX/3g9B/wIkv3Ikb7sQdd2LDnRjnXAvnXAvnXAvnXAvnXBvnXBvnXBvnXLuUc/3r34u1127ff37rf/08P34v9rufUf1AQqWc7i2ESjngWwiVcsa3ECrlmG8hVMpJ30HolHLYtxAq5bxvIVTKkd9CSE4dETIRCgjJqSNCcuqIkJw6IiSnjgjJqf+ZUHvJqSNCcuqIENypx8+Hyts49jdCv/r35+fnuT//DH7+P/9paHvBdf1Z+Cb4z8GHLxnPwofvL8/Ch69Gz8KHb13PwocvdI/Cv+C74rPw4Wvos/C14T4IXxvug/BN8J+Drw33QfjacB+Erw33QfjacB+Erw3338Dv14+ff//3aP8NfmNvuHO9xvefP5e9AvgRTPbGOvfPSZ577f8Ik72BJsNkb5TJME0w82CyN75kmOwNLhkmeyNLhsnesJJhsjemXJgdvgHlwtQGlAhTG1AiTG1AiTBNMPNgagNKhKkNKBGmNqBEmNqAEmFqA8qDadqAEmFqA0qEqQ0oEaY2oESYJph5MLUBJcLUBpQIUxtQIkxtQIkwtQHlwRzagBJhagNKhKkNKBGmNqBEmIaGGT8I2QZ7rUl9ELIN9lrzlXFj7yrJ48beVb4ybuwFJHfcJnsB+cK4TfZWkTxu7K3iK+PGXhWSx800bsG4aVVIHDetCtG4aVVIHDetCtG4aVXIG7dab4m/Y9xqvT3+9LhpVYjGTatC4riZxi0YN60KieOmVSEaN60KieOmVSEaN60KeeO2tSoE47a1KiSOm1aFaNy0KiSOm2ncgnHTqpA4bloVonHTqpA4bloVonHTqpA3bkerQjBuR6tC4rhpVYjGTatC4riZxi0YN60KieOmVSEaN60KieOmVSEaN60KaeN2n03j9o/j1l9aFRLHTatCNG5aFRLHzTRuwbhpVUgcN60K0bhpVUgcN60K0bhpVcgbt0urQjBu8Efuk8dNq0I0bloVEsfNNG7BuGlVSBw3rQrRuGlVSBw3rQrRuGlVyBs3+EPkXxg3+OviyeMGXxVszx8wxzV+NW6/fVVYrx+E/nqCFEI3k+vHic8Z9jdC/zux4U48cCeeuBMv3Ik37sSHduLf/2rz4ye+cCduuBPjnOv3vyT8+IlxztVxztVxztVxztVxzmU45zKcc1kp5/rXvxdrr92+//zW//p7uh+/F7NSjvYWQiZCAaFSDvgWQqWc8S2ESjnmWwiVctK3ECrlsO8gNEo571sIlXLktxCSU0eE5NQRIROhgJCcOiIkp44IyakjQnLqiJCcOiA05dQRIbhTj58Plbdx7G+EfvXvz8/P019//dPQX/784E9DJ1zXn4UP3wSehW+C/xx8+P7yLHz4avQsfPjW9Sx8+EL3LHz4rvgo/AVfQ5+Frw33QfjacB+Erw33Qfgm+M/B14b7IHxtuA/C14b7IHxtuP8Gfr9+/Pz7v0f7j/DZG+5cr/H9589lrwB+AHOzN9a5f07y3Gv/R5jsDTQZJnujTIbJ3hCTYZpg5sFkb3DJMNkbWTJM9oaVDJO9MSXDhG9AqTCPNqBEmNqAEmFqA0qEqQ0oEaYJZh5MbUCJMLUBJcLUBpQIUxtQIkxtQGkw7aUNKBGmNqBEmNqAEmFqA0qEaYKZB1MbUCJMbUCJMLUBJcLUBpQIUxtQHsxLG1AiTG1AiTC1ASXCZG9A8YOQ9vvfn/6zCGU+CGkXe635yrixd5XkcWPvKl8ZN/YCkjxu7AXkC+PW2FtF7rg19lbxlXFjrwrJ46ZVIRo307jljZtWhWjctCokjptWhWjctCokjptWhWDcar09/vC41XrW/C3jplUhcdy0KkTjZhq3vHHTqhCNm1aFxHHTqhCNm1aFxHHTqhCMm2lVyBs306oQjZtWhcRx06oQjZtp3PLGTatCNG5aFRLHTatCNG5aFRLHTatCMG5Dq0LeuA2tCtG4aVVIHDetCtG4mcYtb9y0KkTjplUhcdy0KkTjplUhcdy0KgTjNrUq5I3b1KoQjZtWhcRx06oQjZtp3PLGTatCNG5aFRLHTatCNG5aFRLHTatCMG7wR+5zxw3+aP1Xxk2rQuK4aVWIxs00bnnjplUhGjetConjplUhGjetConjplUhGDf46+K54wZ/XXzbnj9gjmv8atx+96pw9e9H7tecyYRuJtePE58z7G+E/nfijjux4U48cCeeuBMv3Ik37sSHduLf/rTy8ye+cCfGOdfBOddvf+73+RPjnOvgnOvgnOvgnOvQnGu8aM41XqWc61//Xqy9dvv+81vv7f/+Xmy8SjnaWwiVcrq3EDIRCgiVcsa3ECrlmG8hVMpJ30KolMO+hVAp530HoauUI7+FkJw6IiSnjgjJqSNCJkIBITl1REhOHRGSU0eE5NQRITl1QKjBnXr8fKi8jWN/I/Srf39+fp7++uufhv7y5//zn4aOBtf1Z+HDN4Fn4cOXjGfhm+A/Bx++Gj0LH751PQsfvtA9Cx++Kz4LH76GPgq/a8N9EL423Afha8N9EL423Afhm+A/B18b7oPwteE+CF8b7r+B368fP//+79H+I3z2hjvXa3z/+XPZK4AfwWRvrHP/nOS51/5vMI29gSbDZG+UyTDZG2IyTPbGlwzTBDMPJnsjS4bJ3rCSYbI3pmSY8A0oF6Y2oDyYQxtQIkxtQIkwtQElwtQGlAjTBDMPpjagRJjagBJhagNKhKkNKBGmNqA8mFMbUCJMbUCJMLUBJcLUBpQI0wQzD6Y2oESY2oASYWoDSoSpDSgRpjagPJhLG1AiTG1AiTDZG1D8IORY7LUm9UHI8dufqv68cWPvKsnjxt5VvjJu7AUkedzYC8hXxo29VeSO22ZvFV8Yt81eFZLHTatCNG5aFRLHzTRuwbhpVUgcN60K0bhpVUgcN60K0bhpVcgbt1rPmr9j3Go9g/70uGlViMZNq0LiuJnGLRg3rQqJ46ZVIRo3rQqJ46ZVIRo3rQpp4zZfWhX+edzmS6tC4rhpVYjGTatC4riZxi0YN60KieOmVSEaN60KieOmVSEaN60KeeN2aVUIxu3SqpA4bloVonHTqpA4bqZxC8ZNq0LiuGlViMZNq0LiuGlViMZNq0LeuDWtCsG4Na0KieOmVSEaN60KieNmGrdg3LQqJI6bVoVo3LQqJI6bVoVo3LQq5I0b/NH6L4wb/GX55HHTqhCNm1aFxHEzjVswbloVEsdNq0I0bloVEsdNq0I0bloV8sYN/rr4tj1/wBzX+MW4/fYnw9trfCfUuiUTuplcP058zrC/EfrfiRvuxB13YsOdeOBOPHEnXrgTb9yJD+3Ev/394+dPjHOugXOugXOu3/4m7/MnxjnXwDnXwDnXwDnXwDnXLOVc//r3Yu212/ef33pvv/i92CzlaG8hVMrp3kKolAO+hZCJUEColGO+hVApJ30LoVIO+xZCpZz3LYRKOfI7CC05dURITh0RklNHhOTUESEToYCQnDoiJKeOCMmpI0Jy6ogQ3KnHz4fK2zj2N0K/+vfn5+fpr7/+aegvf37wp6EbruvPwodvAs/Chy8Zz8KH7y/PwjfBfw4+fOt6Fj58oXsWPnxXfBY+fA19Fr423OfgH224D8LXhvsgfG24D8LXhvsgfBP85+Brw30QvjbcfwO/Xz9+/v3fo/1H+OwNd64fH+f+b3sF8COY7I31/i3tj0m+f3Wy/yNM9gaaCnO92BtlMkz2hpgMk73xJcNkb3DJME0w82CyN6xkmOyNKRkmfAPKhakNKBGmNqA8mJc2oESY2oASYWoDSoSpDSgRpglmHkxtQIkwtQElwtQGlAhTG1AiTG1AeTCbNqBEmNqAEmFqA0qEqQ0oEaYJZh5MbUCJMLUBJcLUBpQIUxtQIkxtQHkwuzagRJjsDSh+EHJ19lqT+iDk6uy15ivjZhq3vHFj7ypfGTf2ApI8buwF5Cvjxt4qkseNvVV8YdyMvSrkjlutp6rfMm5aFRLHTatCNG6mccsbN60K0bhpVUgcN60K0bhpVUgcN60KwbjVegb94XGr9cL6W8ZNq0LiuGlViMbNNG5546ZVIRo3rQqJ46ZVIRo3rQqJ46ZVIRi3qVUhb9ymVoVo3LQqJI6bVoVo3EzjljduWhWicdOqkDhuWhWicdOqkDhuWhWCcVtaFfLGbWlViMZNq0LiuGlViMbNNG5546ZVIRo3rQqJ46ZVIRo3rQqJ46ZVIRi3rVUhb9y2VoVo3LQqJI6bVoVo3EzjljduWhWicdOqkDhuWhWicdOqkDhuWhWCcYO/LJ87bvCX4r8ybloVEsdNq0I0bqZxyxs3rQrRuGlVSBw3rQrRuGlVSBw3+Kpge/6AOa7xf8dt//4nw3/8n1jvr5ZM6GZy/TjxOcP+Ruh/J75wJ264E3fciQ134oE78cSdeOFOvHEnPrQTXzjnunDOdeGc68I51+9/OPfxE+Oc68I514VzrgvnXFcp5/rXvxdrr92+//zWe/vF78VaKUd7C6FSTvcWQqUc8C2ESjnjWwiZCAWESjnpWwiVcti3ECrlvG8hVMqR30JITh0Q6nLqiJCcOiIkp44IyakjQiZCASE5dURITh0RklNHhOBOPX4+VN7Gsb8R+tW/Pz8/T3/99U9Df/nz//lPQ3eH6/qj8A2+CTwLH75kPAsfvr88Cx++Gj0L3wT/Ofjwhe5Z+PBd8Vn48DX0WfjacB+Erw33OfhDG+6D8LXhPghfG+6D8LXhPgjfBP85+Npw/w38fv34+fd/j/Yf4bM33Ll+ZD/u/7ZXAD+Cyd5Y5/45yXOv/R9hsjfQZJjsjTIX5mRviMkw2RtfMkz2BpcMk72RJcM0wcyDyd6YkmHCN6BcmNqAEmFqA0qEqQ0oD+bSBpQIUxtQIkxtQIkwtQElwjTBzIOpDSgRpjagRJjagBJhagNKhKkNKA/m1gaUCFMbUCJMbUCJMLUBJcI0wcyDqQ0oEaY2oESY2oASYWoDSoSpDSgP5mFvQPGDkPuw15rUByH3Ya81Xxk39q6SPG6mcQvGjb2AJI8bewH5yrixt4rkcWNvFV8ZN/aqkDpup9ZT1W8Yt1Praeunx02rQjRuWhUSx800bsG4aVVIHDetCtG4aVVIHDetCtG4aVXIG7daL6y/Y9xqvcj+9LhpVYjGTatC4riZxi0YN60KieOmVSEaN60KieOmVSEaN60KeePWtCoE49a0KiSOm1aFaNy0KiSOm2ncgnHTqpA4bloVonHTqpA4bloVonHTqpA3bl2rQjBuXatC4rhpVYjGTatC4riZxi0YN60KieOmVSEaN60KieOmVSEaN60KeeNmWhWCcTOtConjplUhGjetConjZhq3YNy0KiSOm1aFaNy0KiSOm1aFaNy0KuSNG/yl+C+MG/w59+Rx06oQjZtWhcRxM41bMG5aFRLHTatCNG5aFRLHDb4q2J4/YI5r/Grcfveq0Ff7QehcyYRuJtePE5/7y+1vhP7fiX/7u97Pn/jCnbjhTtxxJzbciQfuxBN34oU78cadGOdcC+dcC+dcC+dcC+dcv/112+dPjHOuhXOuhXOuVcq5/vXvxdprf/84V+u9/eL3YquUo72D0C7ldG8hVMoB30KolDO+hVApx3wLIROhgFAph30LoVLO+xZCpRz5LYTk1BEhOXVA6MipI0Jy6oiQnDoiJKeOCJkIBYTk1BEhOXVECO7U4+dD5W0c+xuhX/378/Pz9Ndf/zT0lz8/+NPQA9f1Z+HDN4EH4e/XC75kPAsfvr88Cx++Gj0LH751PQvfBP85+PBd8Vn48DX0WfjacB+Erw33QfjacJ+Df2nDfRC+NtwH4WvDfRC+NtwH4Zvg/wv4/frx8+//Hu0/wmdvuHO9xvefP5e9AvgRTPbGOvfPSZ577f8Ik72BJsNkb5TJMNkbYi7Mxt74kmGyN7hkmOyNLBkme8NKhmmCmQcTvgHlwtQGlAhTG1AiTG1AiTC1AeXB7NqAEmFqA0qEqQ0oEaY2oESYJph5MLUBJcLUBpQIUxtQIkxtQIkwtQHlwTRtQIkwtQElwtQGlAhTG1AiTBPMPJjagBJhagNKhKkNKBGmNqBEmOwNKHwQcr8Ge63JfBDyhslea74ybuxdJXnc2LvKV8bNNG5548ZeQL4ybuytInnc2FvFV8aNvSokj5tWhWDcaj1t/fC41Xo1+y3jplUhcdy0KkTjZhq3vHHTqhCNm1aFxHHTqhCNm1aFxHHTqhCMW60X2R8et1qPvb9l3LQqJI6bVoVo3EzjljduWhWicdOqkDhuWhWicdOqkDhuWhWCcdtaFfLGbWtViMZNq0LiuGlViMbNNG5546ZVIRo3rQqJ46ZVIRo3rQqJ46ZVIRi3o1Uhb9yOVoVo3LQqJI6bVoVo3EzjljduWhWicdOqkDhuWhWicdOqkDhuWhX+edyul1aFtHG7XloVonHTqpA4bloVonEzjVveuGlViMZNq0LiuGlViMZNq0LiuGlVCMYN/px77rjBn2f/yrhpVUgcN60K0biZxi1v3LQqROOmVSFx3OCrgu35A+a4xq/G7XevCuPa3wmNv/zkXxNq8/UdUIv5XLZ+4Byvv45O+9XoWP/+sYfZ/Ovw/N9/vM71nfw6ff1i0o44ZnD87Q+FV+V4iWMKxyaOKRy7OKZwNHFM4TjEMYXjFMcUjkscUzhqn8nhqH0mhWPXPpPDUftMDkftMzkctc/kcDRxTOGofSaHo/aZHI7aZ3I4ap/J4ah9JoWjaZ/J4ah9Joej9pkcjtpncjiaOKZw1D6Tw1H7TA5H7TM5HLXP5HDUPpPCcWifyeGofSaHo/aZHI7aZ3I4mjimcNQ+k8NR+0wOR+0zORy1z+Rw1D6TwnFqn8nhqH0mh6P2mRyO2mdyOJo4pnDUPpPDUftMDkftMzkctc/kcNQ+k8JxaZ/J4ah9Joej9pkcjtpncjiaOKZw1D6Tw1H7TA5H7TM5HLXP5HDUPpPCcWufyeGofSaHo/aZHI7aZ3I4WiGOs4/vHOfcv5djpX3mSY6V9pknOVbaZ57kWGmfeZJjpX3mQY6n0j7zJMdK+8yTHCvtM09yrLTPPMnRxDGFo/aZHI7aZ3I4ap/J4ah9Joej9pkMju23P3s/xvWd47yugOPo3zGOtf/2b//36a+P/vTtoz99/+hPbx/96cdHf/r50Z9+ffSn3x/96c8nf/rro79rr4/+rr0++rv2+ujv2t/+onDup//o79rro79rr4/+rr0++rv2+ujv2vbR37Xto79r20d/17aP/q79/e9lpn76j/6ubR/9Xds++ru2ffR3bfvo79r+0d+1/aO/a/sf/V27+vzfP1779atP/0d/14af/o/+rg0//R/9XRt++j/6uzb89H/0d2346f/o79rw0//R37XRp7c/+rs2/PR/9Hdt+Ok/+rvWPvq79ve/M5T66T/6u9Y++rvWPvq71j76u9Y++rt2fPR37fijv2v36/s/3u1Xe+34o79rr8t+/L8Yvtb41ef/o79tv/D5/+jv2y98/j/6G/cLn/+P/s79wuf/o791v/D5/+jv3S98/j/6mzf+/POP/u79wuf/o799v/D5P/z7d3749+/v77Ynf/4P//6dH/79Oz/8+3d++Pfv/PDv3/Xh37/rw79/14d//64P//79/Z3h5M//4d+/68O/f9eHf/+uD//+XR/+/bs//Pt3f/j37/7w79/94d+/v7+Lmfz5P/z7d3/49+/+8O/f/eHfv/vDv3/Ph3//ng///j0f/v17Pvz79/d33JI//4d//54P//49H/79ez78+/d89vdv/7O7VF/4/J/9/dv/7DbVFz7/Z3//9tdnf//2P7tQ9YXP/9nfv/3PrlR94fN/9vdv/7NLVfHn/7NbVV/4/B/+/ftn96q+8Pk//Pv3z25WfeHzf/j375/drfrC5//w798/u131hc//4d+/f3a/6guf/8O/f//shtUXPv+Hf//+2R2rL3z+D//+/bNbVl/4/B/+/ftn96y+8Pk//Pv3z25afeHzf/j375/dtfrC5//w798/u231hc//4d+/f3bf6guf/8O/f//sxtUXPv+Hf//+2Z2rL3z+D//+/bNbV1/4/B/+/ftn966+8Pk//Pv3z25efeHzf/j375/dvfrC5//w798/u331hc//4d+/H96/6h/ev+of3r/qH96/6h/ev+of3r/qH96/6h/ev+of3r/qH96/6h/ev+of3r/qH96/6h/ev+of3r/qH96/6h/ev+of3r/qH96/6h/ev+of3r/qH96/6h/ev+of3r/qH96/6h/ev+of3r/qH96/6h/ev+of3r/qH96/6h/ev+of3r/qH96/6h/ev+of3r/qH96/6h/ev+of3r/qH96/6h/ev+of3r/qH96/6h/ev+of3r/qH96/6h/ev+of3r+yD+9f2Yf3r+zD+1f24f0re3329699eP/KPrx/ZR/ev7IP71/Zh/ev7MP7V/bh/Sv78P6VfXj/yj68f2Uf3r+yD+9f2Yf3r+zD+1f24f0r+/D+lX14/8o+vH9lH96/sg/vX9mH96/sw/tX9uH9K/vw/pV9eP/KPrx/ZR/ev7IP71/Zh/ev7MP7V/bh/Sv78P6VfXj/yj68f2Uf3r+yD+9f2Yf3r+zD+1f24f0r+/D+lX14/8o+vH9lH96/sg/vX9mH96/sw/tX9uH9K/vw/pV9eP/K/vD+VRv7++dv2371+f/s798+v3+Oq+/zq8/vfP/u7//nZvu1//nz72t+//z7WuefP/+y1/d/vO7/y/9//sd7XT9+8rL213/8v0+/PvrT74/+9OcP/vTn1b5/jPOy/c//+GrXef245q2f/3tYL5NV87AX6bCNdNhOOqyRDjtIh/2TpSX9sH+y4/zbw66/HNZevzjsn6xE//r/ZK+fh22/OmwpgwoOu0gGtUgGtUgGtUgGtUgGtUgGtUgGtSoZVHjYSgYV6eIiGdQuZVDRYUkGtUkGtUkGtUkGtUkGtUkGtUkGtUv9Dio6bCWDinTxkAzqlDKo6LAkgzokgzokgzokgzokgzokgzokgzqgv4Mar0oGFejieIEMarxKGVR0WJBBjZeRDgsyqPECGdR4gQxqvEAGNV4kg7pAfwc1rkoGFeniRTKoq5RBRYc10p0lGdRFMqiLZFAXyaAukkE1kkE10N9BjVbJoCJdbCSDaqUMKjosyaAayaAayaAayaAayaA6yaA6yaA66O+gRq9kUJEudpJB9VIGFR2WZFCdZFCdZFCdZFBGMigjGZSRDMpIfwdllQwq0kUjGZSVMqjosCSDMpJBGcmgBsmgBsmgBsmgBsmgRqnfQUWHrWRQkS7+0RnwbIP6o6vh6YclGRSpST5ITfJBapIPUpN8kJrkg9QkH6Qm+SjVJI90sVSTPDIoUpN81GqSB3eW1CQfpCb5IDXJB6lJPkhN8kFqkg9Sk3yUapJHuliqSR4ZFKlJPmo1yYM7S2qSD1KTfJCa5IPUJB+kJvkgNckHqUk+SjXJI10s1SSPDIrUJB+1muTBnSU1yQepST5ITfJBapIPUpN8kJrkg9QkH6Wa5IEuzlJN8sCgJqlJPms1yf/5zk5Sk3y+jHRYkEFNUpN8kprkk9Qkn6Qm+SzVJI90sVSTPDIoUpN81mqSR3fWSIclGRSpST5JTfJJapJPUpN8kprks1STPNLFUk3yyKBITfJZq0ke3VmSQZGa5JPUJJ+kJvkkNcknqUk+SU3yWapJHuliqSZ5ZFCkJvms1SSP7izJoEhN8klqkk9Sk3ySmuST1CSfpCb5LNUkj3SxVJM8MihSk3zWapJHd5ZkUKQm+SQ1ySepST5JTfJJapJPUpN8lmqSR7pYqkkeGRSpST5rNcmjO0syKFKTfJKa5JPUJJ+kJvkkNcknqUk+SzXJI10s1SSPDIrUJJ+1muTRnSUZFKlJPklN8klqkk9Sk3ySmuST1CSfpZrkkS6WapJHBkVqks9aTfLgzpKa5JPUJJ+kJvkkNcknqUk+SU3ySWqSz1JN8kgXSzXJI4MiNclnrSZ5cGdJTfJJapJPUpN8kprkk9Qkn6Qm+SQ1yWepJnmki6Wa5IFBLVKTfNVqkv/znV2kJvkiNcnXy0iHBRnUIjXJF6lJvkhN8lWqSR7o4irVJI8MitQkX7Wa5MGdJTXJF6lJvkhN8kVqki9Sk3yRmuSL1CRfpZrkkS6WapJHBkVqkq9aTfLozhrpsCSDIjXJF6lJvkhN8kVqki9Sk3yVapJHuliqSR4ZFKlJvmo1yaM7SzIoUpN8kZrki9QkX6Qm+SI1yRepSb5KNckjXSzVJI8MitQkX7Wa5NGdJRkUqUm+SE3yRWqSL1KTfJGa5IvUJF+lmuSRLpZqkkcGRWqSr1pN8ujOkgyK1CRfpCb5IjXJF6lJvkhN8kVqkq9STfJIF0s1ySODIjXJV60meXRnSQZFapIvUpN8kZrki9QkX6Qm+SI1yVepJnmki6Wa5JFBkZrkq1aTPLqzJIMiNckXqUm+SE3yRWqSL1KTfJGa5KtUkzzSxVJN8sigSE3yVatJHtxZUpN8kZrki9QkX6Qm+SI1yRepSb5ITfJVqkke6WKpJnlkUKQm+a7VJP/nO7tJTfJNapJvUpN8v4x0WJBBbVKTfJOa5LtUkzzQxV2qSR4ZFKlJvms1yYM7S2qSb1KTfJOa5JvUJN+kJvkmNck3qUm+SzXJI10s1SSPDIrUJN+1muTBnSU1yTepSb5JTfJNapJvUpN8k5rkm9Qk36Wa5JEulmqSRwZFapLvWk3y6M4a6bAkgyI1yTepSb5JTfJNapJvUpN8l2qSR7pYqkkeGRSpSb5rNcmjO0syKFKTfJOa5JvUJN+kJvkmNck3qUm+SzXJI10s1SSPDIrUJN+1muTRnSUZFKlJvklN8k1qkm9Sk3yTmuSb1CTfpZrkkS6WapJHBkVqku9aTfLozpIMitQk36Qm+SY1yTepSb5JTfJNapLvUk3ySBdLNckjgyI1yXetJnl0Z0kGRWqSb1KTfJOa5JvUJN+kJvkmNcl3qSZ5pIulmuSRQZGa5LtWkzy6sySDIjXJN6lJvklN8k1qkm9Sk3yTmuS7VJM80sVSTfLIoEhN8l2rSf7Pd/aQmuSH1CQ/pCb5ITXJ759BOizIoA6pSX5KNckDXTylmuSBQR1Sk/zUapIHd5bUJD+kJvkhNckPqUl+SE3yQ2qSH1KT/JRqkke6WKpJHhkUqUl+ajXJgztLapIfUpP8kJrkh9QkP6Qm+SE1yQ+pSX5KNckjXSzVJI8MitQkP7Wa5MGdJTXJD6lJfkhN8kNqkh9Sk/yQmuSH1CQ/pZrkkS6WapJHBkVqkp9aTfLozhrpsCSDIjXJD6lJfkhN8kNqkh9Sk/yUapJHuliqSR4ZFKlJfmo1yaM7SzIoUpP8kJrkh9QkP6Qm+SE1yQ+pSX5KNckjXSzVJI8MitQkP7Wa5NGdJRkUqUl+SE3yQ2qSH1KT/JCa5IfUJD+lmuSRLpZqkkcGRWqSn1pN8ujOkgyK1CQ/pCb5ITXJD6lJfkhN8kNqkp9STfJIF0s1ySODIjXJT60meXRnSQZFapIfUpP8kJrkh9QkP6Qm+SE1yU+pJnmki6Wa5JFBkZrkp1aTPLqzHIM6L1CT/D4sx6Duw3IM6j4sx6DuwxrpsJy/g7oPy3nV5T4sx6Duw3Ka5PdhSQYFapLfhyUZFKhJfh+WZFCgJvl9WJJBgZrk92E5r7rchyUZFKhJfv80kkGBmuT3TyMZFKhJfv80Ix2WZFCgJvm3n0Y6LOdVl/unkQwK1CS/D0syKFCT/D4syaBATfL7sCSDAjXJ78OSDArUJL8Py3nV5f4RJIMCNcnvH0EyKFCT/P4RRjosyaBATfL7R5AMCtQkv38E6e+gSjXJI10s1SSPDArUJL8PSzIoUJP8PizJoEBN8vuwJIMCNcnvw5IMCtQkvw/LedXlPizJoEBN8vuwRrqzJIMCNcnvw5IMCtQkvw9LMihQk/w+LOnvoEo1ySNdLNUkjwwK1CS/D0syKFCT/D4syaBATfL7sCSDAjXJ78OSDArUJL8Py3nV5T6sgQwK1CS/D0syKFCT/D4syaBATfLzAjXJ78OSDArUJL8PS/o7qFJN8kgXSzXJI4MCNcnvw5IMCtQkvw8LMqiL1CS/SE3yi9Qkv0hN8utlpMNyXnW5DwsyqIvUJL9qNcmjO0syKFKT/CI1yS9Sk/wiNckvUpP8IjXJr1JN8kgXSzXJI4MiNcmvWk3y4M6SmuQXqUl+kZrkF6lJfpGa5BepSX6RmuRXqSZ5pIulmuSRQZGa5FetJnlwZ0lN8ovUJL9ITfKL1CS/SE3yi9Qkv0hN8qtUkzzSxVJN8sigSE3yq1aTPLizpCb5RWqSX6Qm+UVqkl+kJvlFapJfpCb5VapJHuliqSZ5ZFCkJvlVq0ke3FlSk/wiNckvUpP8IjXJL1KT/CI1yS9Sk/wq1SSPdLFUkzwyKFKT/KrVJI/urJEOSzIoUpP8IjXJL1KT/CI1yS9Sk/wq1SSPdLFUkzwyKFKT/KrVJI/uLMmgSE3yi9Qkv0hN8ovUJL9ITfKL1CS/SjXJI10s1SSPDIrUJL9qNcmjO0syKFKT/CI1yS9Sk/wiNckvUpP8IjXJr1JN8kgXSzXJI4MiNcmvWk3y6M6SDIrUJL9ITfJGapI3UpO8kZrkjdQkby/j6GIr1SQPDKqRmuStVpM8urMgg2qkJnkjNckbqUneSE3yRmqSN1KTvJVqkke6WKpJHhkUqUneajXJoztLMihSk7yRmuSN1CRvpCZ5IzXJG6lJ3ko1ySNdLNUkjwyK1CRvtZrkwZ0lNckbqUneSE3yRmqSN1KTvJGa5I3UJG+lmuSRLpZqkkcGRWqSt1pN8uDOkprkjdQkb6QmeSM1yRupSd5ITfJGapK3Uk3ySBdLNckjgyI1yVutJnlwZ0lN8kZqkjdSk7yRmuSN1CRvpCZ5IzXJW6kmeaSLpZrkkUGRmuStVpM8uLOkJnkjNckbqUneSE3yRmqSN1KTvJGa5K1UkzzSxVJN8sigSE3yVqtJHt1ZIx2WZFCkJnkjNckbqUneSE3yRmqSt1JN8kgXSzXJI4MiNclbrSZ5dGdJBkVqkjdSk7yRmuSN1CRvpCZ5IzXJW6kmeaSLpZrkkUGRmuStVpM8urMkgyI1yRupSd5ITfJOapJ3UpO8k5rkvVSTPNDF/jKOQXVSk7zXapJHdxZkUJ3UJO+kJnknNck7qUneSU3yTmqS91JN8kgXSzXJI4MiNcl7rSZ5dGdJBkVqkndSk7yTmuSd1CTvpCZ5JzXJe6kmeaSLpZrkkUGRmuS9VpM8urMkgyI1yTupSd5JTfJOapJ3UpO8k5rkvVSTPNLFUk3yyKBITfJeq0ke3FlSk7yTmuSd1CTvpCZ5JzXJO6lJ3klN8l6qSR7pYqkmeWRQpCZ5r9UkD+4sqUneSU3yTmqSd1KTvJOa5J3UJO+kJnkv1SSPdLFUkzwyKFKTvNdqkgd3ltQk76QmeSc1yTupSd5JTfJOapJ3UpO8l2qSR7pYqkkeGRSpSd5rNcmDO0tqkndSk7yTmuSd1CTvpCZ5JzXJO6lJ3ks1ySNdLNUkjwyK1CTvtZrk0Z010mFJBkVqkndSk7yTmuSd1CTvpCZ5L9Ukj3SxVJM8MihSk7zXapJHd5ZkUKQmeSc1yTupSd5JTXIjNcmN1CS3Uk3yQBetVJM8MCh7GemwIIMyUpPcSE1yIzXJjdQkN1KT3EhNciM1ya1UkzzSxVJN8sigSE1yq9Ukj+4syaBITXIjNcmN1CQ3UpPcSE1yIzXJrVSTPNLFUk3yyKBITXKr1SSP7izJoEhNciM1yY3UJDdSk9xITXIjNcmtVJM80sVSTfLIoEhNcqvVJI/uLMmgSE1yIzXJjdQkN1KT3EhNciM1ya1UkzzSxVJN8sigSE1yq9UkD+4sqUlupCa5kZrkRmqSG6lJbqQmuZGa5FaqSR7pYqkmeWRQpCa51WqSB3eW1CQ3UpPcSE1yIzXJjdQkN1KT3EhNcivVJI90sVSTPDIoUpPcajXJgztLapIbqUlupCa5kZrkRmqSG6lJbqQmuZVqkke6WKpJHhkUqUlutZrkwZ0lNcmN1CQ3UpPcSE1yIzXJjdQkN1KT3Eo1ySNdLNUkjwyK1CS3Wk3y6M4a6bAkgyI1yY3UJDdSk9xITfJBapKPUk3yQBdHqSZ5YFCD1CQfLyPdWZBBDVKTfJCa5IPUJB+kJvkgNckHqUk+SjXJI10s1SSPDIrUJB+1muTRnSUZFKlJPkhN8kFqkg9Sk3yQmuSD1CQfpZrkkS6WapJHBkVqko9aTfLozpIMitQkH6Qm+SA1yQepST5ITfJBapKPUk3ySBdLNckjgyI1yUetJnl0Z0kGRWqSD1KTfJCa5IPUJB+kJvkgNclHqSZ5pIulmuSRQZGa5KNWkzy6sySDIjXJB6lJPkhN8kFqkg9Sk3yQmuSjVJM80sVSTfLIoEhN8lGrSR7cWVKTfJCa5IPUJB+kJvkgNckHqUk+SE3yUapJHuliqSZ5ZFCkJvmo1SQP7iypST5ITfJBapIPUpN8kJrkg9QkH6Qm+SjVJI90sVSTPDIoUpN81GqSB3eW1CQfpCb5IDXJB6lJPkhN8kFqkg9Sk3yUapJHuliqSR4ZFKlJPmo1yYM7S2qSD1KTfJCa5IPUJB+kJvkgNckHqUk+SzXJA12cpZrkgUFNUpN81mqSR3fWSIcFGdQkNcknqUk+SU3ySWqST1KTfJZqkke6WKpJHhkUqUk+azXJoztLMihSk3ySmuST1CSfpCb5JDXJJ6lJPks1ySNdLNUkjwyK1CSftZrk0Z0lGRSpST5JTfJJapJPUpN8kprkk9Qkn6Wa5JEulmqSRwZFapLPWk3y6M6SDIrUJJ+kJvkkNcknqUk+SU3ySWqSz1JN8kgXSzXJI4MiNclnrSZ5dGdJBkVqkk9Sk3ySmuST1CSfpCb5JDXJZ6kmeaSLpZrkkUGRmuSzVpM8urMkgyI1ySepST5JTfJJapJPUpN8kprks1STPNLFUk3yyKBITfJZq0ke3FlSk3ySmuST1CSfpCb5JDXJJ6lJPklN8lmqSR7pYqkmeWRQpCb5rNUkD+4sqUk+SU3ySWqST1KTfJKa5JPUJJ+kJvks1SSPdLFUkzwyKFKTfNZqkgd3ltQkn6Qm+SQ1ySepST5JTfJJapJPUpN8lmqSB7q4SjXJA4NapCb5qtUk/+c7u0hN8vUy0mFBBrVITfJFapIvUpN8kZrkq1STPNLFUk3yyKBITfJVq0ke3VkjHZZkUKQm+SI1yRepSb5ITfJFapKvUk3ySBdLNckjgyI1yVetJnl0Z0kGRWqSL1KTfJGa5IvUJF+kJvkiNclXqSZ5pIulmuSRQZGa5KtWkzy6sySDIjXJF6lJvkhN8kVqki9Sk3yRmuSrVJM80sVSTfLIoEhN8lWrSR7dWZJBkZrki9QkX6Qm+SI1yRepSb5ITfJVqkke6WKpJnlkUKQm+arVJI/uLMmgSE3yRWqSL1KTfJGa5IvUJF+kJvkq1SSPdLFUkzwyKFKTfNVqkkd3lmRQpCb5IjXJF6lJvkhN8kVqki9Sk3yVapJHuliqSR4ZFKlJvmo1yYM7S2qSL1KTfJGa5IvUJF+kJvkiNckXqUm+SjXJI10s1SSPDIrUJF+1muTBnSU1yRepSb5ITfJFapIvUpN8kZrki9QkX6Wa5JEulmqSBwa1SU3yXatJ/s93dpOa5JvUJN8vIx0WZFCb1CTfpCb5JjXJd6kmeaCLu1STPDIoUpN812qSB3eW1CTfpCb5JjXJN6lJvklN8k1qkm9Sk3yXapJHuliqSR4ZFKlJvms1yaM7a6TDkgyK1CTfpCb5JjXJN6lJvklN8l2qSR7pYqkmeWRQpCb5rtUkj+4syaBITfJNapJvUpN8k5rkm9Qk36Qm+S7VJI90sVSTPDIoUpN812qSR3eWZFCkJvkmNck3qUm+SU3yTWqSb1KTfJdqkke6WKpJHhkUqUm+azXJoztLMihSk3yTmuSb1CTfpCb5JjXJN6lJvks1ySNdLNUkjwyK1CTftZrk0Z0lGRSpSb5JTfJNapJvUpN8k5rkm9Qk36Wa5JEulmqSRwZFapLvWk3y6M6SDIrUJN+kJvkmNck3qUm+SU3yTWqS71JN8kgXSzXJI4MiNcl3rSZ5cGdJTfJNapJvUpN8k5rkm9Qk36Qm+SY1yXepJnmki6Wa5JFBkZrkp1aT/J/v7CE1yQ+pSX5ITfL7Z5AOCzKoQ2qSH1KT/JRqkge6eEo1ySODIjXJT60meXBnSU3yQ2qSH1KT/JCa5IfUJD+kJvkhNclPqSZ5pIulmuSRQZGa5KdWkzy4s6Qm+SE1yQ+pSX5ITfJDapIfUpP8kJrkp1STPNLFUk3yyKBITfJTq0ke3VkjHZZkUKQm+SE1yQ+pSX5ITfJDapKfUk3ySBdLNckjgyI1yU+tJnl0Z0kGRWqSH1KT/JCa5IfUJD+kJvkhNclPqSZ5pIulmuSRQZGa5KdWkzy6sySDIjXJD6lJfkhN8kNqkh9Sk/yQmuSnVJM80sVSTfLIoEhN8lOrSR7dWZJBkZrkh9QkP6Qm+SE1yQ+pSX5ITfJTqkke6WKpJnlkUKQm+anVJI/uLMmgSE3yQ2qSH1KT/JCa5IfUJD+kJvkp1SSPdLFUkzwyKFKT/NRqkkd3lmRQpCb5ITXJD6lJfkhN8kNqkh9Sk/yUapJHuliqSR4ZFKlJfmo1yf/pzrbXi9Mk/3ZYjEF9OyzGoL4dFmNQ3w5rpMNiDOrbYTF/B/XtsJhXXb4dFmNQ3w6LaZLfh63VJA/uLKdJ/u2wJIPiNMm/HdZIhyUZFKdJ/u2wmL+D+nZYzKsu3w5LMihOk/zbYUkGxWmSfzssyaA4TfJvhyUZFKdJ/u2wJIPiNMm/HRbzqst92FJN8sigOE3yb4clGRSnSf7tsEY6LMmgOE3yb4clGRSnSf7tsKS/gyrVJI90sVSTPDIoTpP822FJBsVpkn87LMmgOE3yb4clGRSnSf7tsCSD4jTJvx0W86rLt8OSDIrTJP92WCPdWZJBcZrk3w5LMihOk/zbYUkGxWmSfzss6e+gSjXJI10s1SSPDIrTJP92WJJBcZrk3w5LMihOk/zbYUkGxWmSfzssyaA4TfJvh8W86vLtsAYyKE6T/NthSQbFaZJ/OyzJoDhN8vuwnCb5t8OSDIrTJP92WNLfQZVqkke6WKpJHhkUp0n+7bAkg+I0yb8dlmRQnCb5t8OSDIrTJP92WJJBcZrk3w6LedXl22FJBsVpkn87LMmgSE3yi9Qkv0hN8ovUJL9ITfLrZaTDgv4O6irVJA908SrVJA8M6iI1ya9aTfLgzpKa5BepSX6RmuQXqUl+kZrkF6lJfpGa5FepJnmki6Wa5JFBkZrkV60meXBnSU3yi9Qkv0hN8ovUJL9ITfKL1CS/SE3yq1STPNLFUk3yyKBITfKrVpM8uLOkJvlFapJfpCb5RWqSX6Qm+UVqkl+kJvlVqkke6WKpJnlkUKQm+VWrSR7cWVKT/CI1yS9Sk/wiNckvUpP8IjXJL1KT/CrVJI90sVSTPDIoUpP8qtUkj+6skQ5LMihSk/wiNckvUpP8IjXJL1KT/CrVJI90sVSTPDIoUpP8qtUkj+4syaBITfKL1CS/SE3yi9Qkv0hN8ovUJL9KNckjXSzVJI8MitQkv2o1yaM7SzIoUpP8IjXJL1KT/CI1yS9Sk/wiNcmvUk3ySBdLNckjgyI1ya9aTfLozpIMitQkv0hN8ovUJL9ITfKL1CS/SE3yq1STPNLFUk3yyKBITfKrVpM8urMkgyI1yRupSd5ITfJGapI3UpO8vYx0WNCrLq1UkzwwqEZqkrdaTfLozpIMitQkb6QmeSM1yRupSd5ITfJGapK3Uk3ySBdLNckjgyI1yVutJnlwZ0lN8kZqkjdSk7yRmuSN1CRvpCZ5IzXJW6kmeaSLpZrkkUGRmuStVpM8uLOkJnkjNckbqUneSE3yRmqSN1KTvJGa5K1UkzzSxVJN8sigSE3yVqtJHtxZUpO8kZrkjdQkb6QmeSM1yRupSd5ITfJWqkke6WKpJnlkUKQmeavVJA/uLKlJ3khN8kZqkjdSk7yRmuSN1CRvpCZ5K9Ukj3SxVJM8MihSk7zVapJHd9ZIhyUZFKlJ3khN8kZqkjdSk7yRmuStVJM80sVSTfLIoEhN8larSR7dWZJBkZrkjdQkb6QmeSM1yRupSd5ITfJWqkke6WKpJnlkUKQmeavVJI/uLMmgSE3yRmqSN1KTvJGa5I3UJG+kJnkr1SSPdLFUkzwyKFKTvNVqkkd3lmRQpCZ5IzXJO6lJ3klN8k5qkndSk7y/jKOLvVSTPDCoTmqS91pN8ujOggyqk5rkndQk76QmeSc1yTupSd5JTfJeqkke6WKpJnlkUKQmea/VJI/uLMmgSE3yTmqSd1KTvJOa5J3UJO+kJnkv1SSPdLFUkzwyKFKTvNdqkgd3ltQk76QmeSc1yTupSd5JTfJOapJ3UpO8l2qSR7pYqkkeGRSpSd5rNcmDO0tqkndSk7yTmuSd1CTvpCZ5JzXJO6lJ3ks1ySNdLNUkjwyK1CTvtZrkwZ0lNck7qUneSU3yTmqSd1KTvJOa5J3UJO+lmuSRLpZqkkcGRWqS91pN8uDOkprkndQk76QmeSc1yTupSd5JTfJOapL3Uk3ySBdLNckjgyI1yXutJnl0Z410WJJBkZrkndQk76QmeSc1yTupSd5LNckjXSzVJI8MitQk77Wa5NGdJRkUqUneSU3yTmqSd1KTvJOa5J3UJO+lmuSRLpZqkkcGRWqS91pN8ujOkgyK1CTvpCZ5JzXJjdQkN1KT3EhNcivVJA900V7GMSgjNcmtVpM8urMggzJSk9xITXIjNcmN1CQ3UpPcSE1yK9Ukj3SxVJM8MihSk9xqNcmjO0syKFKT3EhNciM1yY3UJDdSk9xITXIr1SSPdLFUkzwyKFKT3Go1yaM7SzIoUpPcSE1yIzXJjdQkN1KT3EhNcivVJI90sVSTPDIoUpPcajXJgztLapIbqUlupCa5kZrkRmqSG6lJbqQmuZVqkke6WKpJHhkUqUlutZrkwZ0lNcmN1CQ3UpPcSE1yIzXJjdQkN1KT3Eo1ySNdLNUkjwyK1CS3Wk3y4M6SmuRGapIbqUlupCa5kZrkRmqSG6lJbqWa5JEulmqSRwZFapJbrSZ5cGdJTXIjNcmN1CQ3UpPcSE1yIzXJjdQkt1JN8kgXSzXJI4MiNcmtVpM8urNGOizJoEhNciM1yY3UJDdSk9xITXIr1SSPdLFUkzwyKFKT3Go1yaM7SzIoUpPcSE1yIzXJjdQkH6Qm+SA1yUepJnmgi6NUkzwwqPEy0mFBBjVITfJBapIPUpN8kJrkg9QkH6Qm+SA1yUepJnmki6Wa5JFBkZrko1aTPLqzJIMiNckHqUk+SE3yQWqSD1KTfJCa5KNUkzzSxVJN8sigSE3yUatJHt1ZkkGRmuSD1CQfpCb5IDXJB6lJPkhN8lGqSR7pYqkmeWRQpCb5qNUkj+4syaBITfJBapIPUpN8kJrkg9QkH6Qm+SjVJI90sVSTPDIoUpN81GqSB3eW1CQfpCb5IDXJB6lJPkhN8kFqkg9Sk3yUapJHuliqSR4ZFKlJPmo1yYM7S2qSD1KTfJCa5IPUJB+kJvkgNckHqUk+SjXJI10s1SSPDIrUJB+1muTBnSU1yQepST5ITfJBapIPUpN8kJrkg9QkH6Wa5JEulmqSRwZFapKPWk3y4M6SmuSD1CQfpCb5IDXJB6lJPkhN8kFqko9STfJIF0s1ySODIjXJR60meXRnjXRYkkGRmuSD1CQfpCb5IDXJJ6lJPks1yQNdnKWa5IFBTVKTfL6MdGdBBjVJTfJJapJPUpN8kprkk9Qkn6Qm+SzVJI90sVSTPDIoUpN81mqSR3eWZFCkJvkkNcknqUk+SU3ySWqST1KTfJZqkke6WKpJHhkUqUk+azXJoztLMihSk3ySmuST1CSfpCb5JDXJJ6lJPks1ySNdLNUkjwyK1CSftZrk0Z0lGRSpST5JTfJJapJPUpN8kprkk9Qkn6Wa5JEulmqSRwZFapLPWk3y6M6SDIrUJJ+kJvkkNcknqUk+SU3ySWqSz1JN8kgXSzXJI4MiNclnrSZ5cGdJTfJJapJPUpN8kprkk9Qkn6Qm+SQ1yWepJnmki6Wa5JFBkZrks1aTPLizpCb5JDXJJ6lJPklN8klqkk9Sk3ySmuSzVJM80sVSTfLIoEhN8lmrSR7cWVKTfJKa5JPUJJ+kJvkkNcknqUk+SU3yWapJHuliqSZ5ZFCkJvms1SQP7iypST5JTfJJapJPUpN8kprkk9Qkn6Qm+SrVJA90cZVqkgcGtUhN8lWrSR7dWSMdFmRQi9QkX6Qm+SI1yRepSb5ITfJVqkke6WKpJnlkUKQm+arVJI/uLMmgSE3yRWqSL1KTfJGa5IvUJF+kJvkq1SSPdLFUkzwyKFKTfNVqkkd3lmRQpCb5IjXJF6lJvkhN8kVqki9Sk3yVapJHuliqSR4ZFKlJvmo1yaM7SzIoUpN8kZrki9QkX6Qm+SI1yRepSb5KNckjXSzVJI8MitQkX7Wa5NGdJRkUqUm+SE3yRWqSL1KTfJGa5IvUJF+lmuSRLpZqkkcGRWqSr1pN8ujOkgyK1CRfpCb5IjXJF6lJvkhN8kVqkq9STfJIF0s1ySODIjXJV60meXBnSU3yRWqSL1KTfJGa5IvUJF+kJvkiNclXqSZ5pIulmuSRQZGa5KtWkzy4s6Qm+SI1yRepSb5ITfJFapIvUpN8kZrkq1STPNLFUk3yyKBITfJVq0ke3FlSk3yRmuSL1CRfpCb5IjXJF6lJvkhN8lWqSR7o4i7VJA8MapOa5LtWk/yf7+wmNcn3y0iHBRnUJjXJN6lJvklN8k1qku9STfJIF0s1ySODIjXJd60meXRnjXRYkkGRmuSb1CTfpCb5JjXJN6lJvks1ySNdLNUkjwyK1CTftZrk0Z0lGRSpSb5JTfJNapJvUpN8k5rkm9Qk36Wa5JEulmqSRwZFapLvWk3y6M6SDIrUJN+kJvkmNck3qUm+SU3yTWqS71JN8kgXSzXJI4MiNcl3rSZ5dGdJBkVqkm9Sk3yTmuSb1CTfpCb5JjXJd6kmeaSLpZrkkUGRmuS7VpM8urMkgyI1yTepSb5JTfJNapJvUpN8k5rku1STPNLFUk3yyKBITfJdq0ke3VmSQZGa5JvUJN+kJvkmNck3qUm+SU3yXapJHuliqSZ5ZFCkJvmu1SQP7iypSb5JTfJNapJvUpN8k5rkm9Qk36Qm+S7VJI90sVSTPDIoUpN812qSB3eW1CTfpCb5JjXJN6lJvklN8k1qkm9Sk3yXapJHuliqSR4Y1CE1yU+tJvk/39lDapIfUpP8/hmkw4IM6pCa5IfUJD+kJvkp1SQPdPGUapJHBkVqkp9aTfLgzpKa5IfUJD+kJvkhNckPqUl+SE3yQ2qSn1JN8kgXSzXJI4MiNclPrSZ5dGeNdFiSQZGa5IfUJD+kJvkhNckPqUl+SjXJI10s1SSPDIrUJD+1muTRnSUZFKlJfkhN8kNqkh9Sk/yQmuSH1CQ/pZrkkS6WapJHBkVqkp9aTfLozpIMitQkP6Qm+SE1yQ+pSX5ITfJDapKfUk3ySBdLNckjgyI1yU+tJnl0Z0kGRWqSH1KT/JCa5IfUJD+kJvkhNclPqSZ5pIulmuSRQZGa5KdWkzy6sySDIjXJD6lJfkhN8kNqkh9Sk/yQmuSnVJM80sVSTfLIoEhN8lOrSR7dWZJBkZrkh9QkP6Qm+SE1yQ+pSX5ITfJTqkke6WKpJnlkUKQm+anVJA/uLKlJfkhN8kNqkh9Sk/yQmuSH1CQ/pCb5KdUkj3SxVJM8MihQk/x61WqS/+OdvQ/LMaj7sByDug/LMaj7sEY6LMeg7sNyDOo+LOfvoO7Dcl51uQ9LMihQk/w+LMmgQE3y+7AkgwI1ye/DkgwK1CS/D0syKFCT/D4s51WX61WqSR4ZFKhJfh+WZFCgJvl9WCMdlmRQoCb5fViSQYGa5PdhOX8Hdb1KNckjXSzVJI8MCtQkvw9LMihQk/w+LMmgQE3y+7AkgwI1ye/DkgwK1CS/D8t51eU+LMmgQE3y+7BGurMkgwI1ye/DkgwK1CS/D0syKFCT/D4s6e+gSjXJI10s1SSPDArUJL8PSzIoUJP8PizJoEBN8vuwJIMCNcnvw5IMCtQkvw/LedXlPqyBDArUJL8PSzIoUJP8PizJoEBN8usFapLfhyUZFKhJfh+W9HdQpZrkkS6WapJHBgVqkt+HJRkUqEl+H5ZkUKAm+X1YkkGBmuT3YUkGBWqS34flvOpyH5ZkUKAm+X1YkkGBmuTXC9Qkvw9LMihQk/w+LMmgQE3y+7Ckv4Mq1SSPdLFUkzwyKFCT/D4syKAuUpP8IjXJL1KT/CI1ya+XkQ4LMqiL1CS/SjXJA128SjXJA4O6SE3yq1aTPLizpCb5RWqSX6Qm+UVqkl+kJvlFapJfpCb5VapJHuliqSZ5ZFCkJvlVq0ke3FlSk/wiNckvUpP8IjXJL1KT/CI1yS9Sk/wq1SSPdLFUkzwyKFKT/KrVJA/uLKlJfpGa5BepSX6RmuQXqUl+kZrkF6lJfpVqkke6WKpJHhkUqUl+1WqSR3fWSIclGRSpSX6RmuQXqUl+kZrkF6lJfpVqkke6WKpJHhkUqUl+1WqSR3eWZFCkJvlFapJfpCb5RWqSX6Qm+UVqkl+lmuSRLpZqkkcGRWqSX7Wa5NGdJRkUqUl+kZrkF6lJfpGa5BepSX6RmuRXqSZ5pIulmuSRQZGa5FetJnl0Z0kGRWqSX6Qm+UVqkl+kJvlFapJfpCb5VapJHuliqSZ5ZFCkJvlVq0ke3VmSQZGa5BepSX6RmuQXqUl+kZrkF6lJfpVqkke6WKpJHhkUqUl+1WqSR3cWZFCN1CRvpCZ5IzXJG6lJ3l5GOizo76BaqSZ5oIutVJM8MKhGapK3Wk3y4M6SmuSN1CRvpCZ5IzXJG6lJ3khN8kZqkrdSTfJIF0s1ySODIjXJW60meXBnSU3yRmqSN1KTvJGa5I3UJG+kJnkjNclbqSZ5pIulmuSRQZGa5K1Wkzy4s6QmeSM1yRupSd5ITfJGapI3UpO8kZrkrVSTPNLFUk3yyKBITfJWq0ke3FlSk7yRmuSN1CRvpCZ5IzXJG6lJ3khN8laqSR7pYqkmeWRQpCZ5q9Ukj+6skQ5LMihSk7yRmuSN1CRvpCZ5IzXJW6kmeaSLpZrkkUGRmuStVpM8urMkgyI1yRupSd5ITfJGapI3UpO8kZrkrVSTPNLFUk3yyKBITfJWq0ke3VmSQZGa5I3UJG+kJnkjNckbqUneSE3yVqpJHuliqSZ5ZFCkJnmr1SSP7izJoEhN8kZqkjdSk7yRmuSN1CRvpCZ5K9Ukj3SxVJM8MihSk7zVapJHd5ZkUKQmeSc1yTupSd5JTfJOapL3l5EOC3rVpZdqkgcG1UlN8l6rSR7dWZJBkZrkndQk76QmeSc1yTupSd5JTfJeqkke6WKpJnlkUKQmea/VJA/uLKlJ3klN8k5qkndSk7yTmuSd1CTvpCZ5L9Ukj3SxVJM8MihSk7zXapIHd5bUJO+kJnknNck7qUneSU3yTmqSd1KTvJdqkke6WKpJHhkUqUneazXJgztLapJ3UpO8k5rkndQk76QmeSc1yTupSd5LNckjXSzVJI8MitQk77Wa5MGdJTXJO6lJ3klN8k5qkndSk7yTmuSd1CTvpZrkkS6WapJHBkVqkvdaTfLozhrpsCSDIjXJO6lJ3klN8k5qkndSk7yXapJHuliqSR4ZFKlJ3ms1yaM7SzIoUpO8k5rkndQk76QmeSc1yTupSd5LNckjXSzVJI8MitQk77Wa5NGdJRkUqUneSU3yTmqSd1KTvJOa5J3UJO+lmuSRLpZqkkcGRWqS91pN8ujOkgyK1CTvpCa5kZrkRmqSG6lJbqQmub2Mo4tWqkkeGJSRmuRWq0ke3VmQQRmpSW6kJrmRmuRGapIbqUlupCa5lWqSR7pYqkkeGRSpSW61muTRnSUZFKlJbqQmuZGa5EZqkhupSW6kJrmVapJHuliqSR4ZFKlJbrWa5MGdJTXJjdQkN1KT3EhNciM1yY3UJDdSk9xKNckjXSzVJI8MitQkt1pN8uDOkprkRmqSG6lJbqQmuZGa5EZqkhupSW6lmuSRLpZqkkcGRWqSW60meXBnSU1yIzXJjdQkN1KT3EhNciM1yY3UJLdSTfJIF0s1ySODIjXJrVaTPLizpCa5kZrkRmqSG6lJbqQmuZGa5EZqklupJnmki6Wa5JFBkZrkVqtJHt1ZIx2WZFCkJrmRmuRGapIbqUlupCa5lWqSR7pYqkkeGRSpSW61muTRnSUZFKlJbqQmuZGa5EZqkhupSW6kJrmVapJHuliqSR4ZFKlJbrWa5NGdJRkUqUlupCa5kZrkg9QkH6Qm+SA1yUepJnmgi+NlHIMapCb5qNUkj+4syKAGqUk+SE3yQWqSD1KTfJCa5IPUJB+lmuSRLpZqkkcGRWqSj1pN8ujOkgyK1CQfpCb5IDXJB6lJPkhN8kFqko9STfJIF0s1ySODIjXJR60meXRnSQZFapIPUpN8kJrkg9QkH6Qm+SA1yUepJnmki6Wa5JFBkZrko1aTPLizpCb5IDXJB6lJPkhN8kFqkg9Sk3yQmuSjVJM80sVSTfLIoEhN8lGrSR7cWVKTfJCa5IPUJB+kJvkgNckHqUk+SE3yUapJHuliqSZ5ZFCkJvmo1SQP7iypST5ITfJBapIPUpN8kJrkg9QkH6Qm+SjVJI90sVSTPDIoUpN81GqSB3eW1CQfpCb5IDXJB6lJPkhN8kFqkg9Sk3yUapJHuliqSR4ZFKlJPmo1yaM7a6TDkgyK1CQfpCb5IDXJB6lJPkhN8lGqSR7pYqkmeWRQpCb5qNUkj+4syaBITfJBapIPUpN8kJrkk9Qkn6Qm+SzVJA90cZZqkgcGNV9GOizIoCapST5JTfJJapJPUpN8kprkk9Qkn6Qm+SzVJI90sVSTPDIoUpN81mqSR3eWZFCkJvkkNcknqUk+SU3ySWqST1KTfJZqkke6WKpJHhkUqUk+azXJoztLMihSk3ySmuST1CSfpCb5JDXJJ6lJPks1ySNdLNUkjwyK1CSftZrk0Z0lGRSpST5JTfJJapJPUpN8kprkk9Qkn6Wa5JEulmqSRwZFapLPWk3y4M6SmuST1CSfpCb5JDXJJ6lJPklN8klqks9STfJIF0s1ySODIjXJZ60meXBnSU3ySWqST1KTfJKa5JPUJJ+kJvkkNclnqSZ5pIulmuSRQZGa5LNWkzy4s6Qm+SQ1ySepST5JTfJJapJPUpN8kprks1STPNLFUk3yyKBITfJZq0ke3FlSk3ySmuST1CSfpCb5JDXJJ6lJPklN8lmqSR7pYqkmeWRQpCb5rNUkj+6skQ5LMihSk3ySmuST1CSfpCb5IjXJV6kmeaCLq1STPDCoRWqSr5eR7izIoBapSb5ITfJFapIvUpN8kZrki9QkX6Wa5JEulmqSRwZFapKvWk3y6M6SDIrUJF+kJvkiNckXqUm+SE3yRWqSr1JN8kgXSzXJI4MiNclXrSZ5dGdJBkVqki9Sk3yRmuSL1CRfpCb5IjXJV6kmeaSLpZrkkUGRmuSrVpM8urMkgyI1yRepSb5ITfJFapIvUpN8kZrkq1STPNLFUk3yyKBITfJVq0ke3VmSQZGa5IvUJF+kJvkiNckXqUm+SE3yVapJHuliqSZ5ZFCkJvmq1SQP7iypSb5ITfJFapIvUpN8kZrki9QkX6Qm+SrVJI90sVSTPDIoUpN81WqSB3eW1CRfpCb5IjXJF6lJvkhN8kVqki9Sk3yVapJHuliqSR4ZFKlJvmo1yYM7S2qSL1KTfJGa5IvUJF+kJvkiNckXqUm+SjXJI10s1SSPDIrUJF+1muTBnSU1yRepSb5ITfJFapIvUpN8kZrki9Qk36Wa5IEu7lJN8sCgNqlJvms1yaM7a6TDggxqk5rkm9Qk36Qm+SY1yTepSb5LNckjXSzVJI8MitQk37Wa5NGdJRkUqUm+SU3yTWqSb1KTfJOa5JvUJN+lmuSRLpZqkkcGRWqS71pN8ujOkgyK1CTfpCb5JjXJN6lJvklN8k1qku9STfJIF0s1ySODIjXJd60meXRnSQZFapJvUpN8k5rkm9Qk36Qm+SY1yXepJnmki6Wa5JFBkZrku1aTPLqzJIMiNck3qUm+SU3yTWqSb1KTfJOa5LtUkzzSxVJN8sigSE3yXatJHt1ZkkGRmuSb1CTfpCb5JjXJN6lJvklN8l2qSR7pYqkmeWRQpCb5rtUkD+4sqUm+SU3yTWqSb1KTfJOa5JvUJN+kJvku1SSPdLFUkzwyKFKTfNdqkgd3ltQk36Qm+SY1yTepSb5JTfJNapJvUpN8l2qSR7pYqkkeGRSpSb5rNcmDO0tqkm9Sk3yTmuSb1CTfpCb5JjXJN6lJvks1yQNdPKWa5IFBHVKT/NRqkv/znT2kJvn9M0iHBRnUITXJD6lJfkhN8kNqkp9STfJIF0s1ySODIjXJT60meXRnjXRYkkGRmuSH1CQ/pCb5ITXJD6lJfko1ySNdLNUkjwyK1CQ/tZrk0Z0lGRSpSX5ITfJDapIfUpP8kJrkh9QkP6Wa5JEulmqSRwZFapKfWk3y6M6SDIrUJD+kJvkhNckPqUl+SE3yQ2qSn1JN8kgXSzXJI4MiNclPrSZ5dGdJBkVqkh9Sk/yQmuSH1CQ/pCb5ITXJT6kmeaSLpZrkkUGRmuSnVpM8urMkgyI1yQ+pSX5ITfJDapIfUpP8kJrkp1STPNLFUk3yyKBITfJTq0ke3VmSQZGa5IfUJD+kJvkhNckPqUl+SE3yU6pJHuliqSZ5ZFCkJvmp1SQP7iypSX5ITfJDapIfUpP8kJrkh9QkP6Qm+SnVJI90sVSTPDIoUpP81GqSB3eW1CQ/pCb5ITXJD6lJfkhN8kNqkh9Sk/yUapJHuliqSf7PBtVeoCb5fViOQd2H5RjUfViOQd2HNdJhOQZ1H5ZjUPdhOQZ1H5bzd1D3YTmvurRXqSZ5ZFCgJvl9WJJBgZrk92GNdFiSQYGa5PdhSQYFapLfh+X8HVR7lWqSR7pYqkkeGRSoSX4flmRQoCb5fViSQYGa5PdhSQYFapLfhyUZFKhJfh+W86rLfViSQYGa5PdhjXRnSQYFapLfhyUZFKhJfh+WZFCgJvl9WNLfQZVqkke6WKpJHhkUqEl+H5ZkUKAm+X1YkkGBmuT3YUkGBWqS34clGRSoSX4flvOqy31YAxkUqEl+H5ZkUKAm+X1YkkGBmuTtBWqS34clGRSoSX4flvR3UKWa5JEulmqSRwYFapLfhyUZFKhJfh+WZFCgJvl9WJJBgZrk92FJBgVqkt+H5bzqch+WZFCgJvl9WJJBgZrk7QVqkt+HJRkUqEl+H5ZkUKAm+X1Y0t9BlWqSR7pYqkkeGRSoSX4flmRQoCb5fViSQYGa5PdhSQYFapLfhyUZFKhJfh+W86rLfViSQZGa5FetJvk/39mL1CS/SE3yi9Qkv15GOizIoC5Sk/wiNcmvUk3yQBevUk3yyKBITfKrVpM8uLOkJvlFapJfpCb5RWqSX6Qm+UVqkl+kJvlVqkke6WKpJnlkUKQm+VWrSR7cWVKT/CI1yS9Sk/wiNckvUpP8IjXJL1KT/CrVJI90sVSTPDIoUpP8qtUkj+6skQ5LMihSk/wiNckvUpP8IjXJL1KT/CrVJI90sVSTPDIoUpP8qtUkj+4syaBITfKL1CS/SE3yi9Qkv0hN8ovUJL9KNckjXSzVJI8MitQkv2o1yaM7SzIoUpP8IjXJL1KT/CI1yS9Sk/wiNcmvUk3ySBdLNckjgyI1ya9aTfLozpIMitQkv0hN8ovUJL9ITfKL1CS/SE3yq1STPNLFUk3yyKBITfKrVpM8urMkgyI1yS9Sk/wiNckvUpP8IjXJL1KT/CrVJI90sVSTPDIoUpP8qtUkj+4syaBITfKL1CS/SE3yi9Qkv0hN8ovUJL9KNckjXSzVJI8MitQkv2o1yf/5zjZSk7yRmuSN1CRvpCZ5exnpsCCDaqQmeSvVJA90sZVqkgcG1UhN8larSR7cWVKTvJGa5I3UJG+kJnkjNckbqUneSE3yVqpJHuliqSZ5ZFCkJnmr1SQP7iypSd5ITfJGapI3UpO8kZrkjdQkb6QmeSvVJI90sVSTPDIoUpO81WqSB3eW1CRvpCZ5IzXJG6lJ3khN8kZqkjdSk7yVapJHuliqSR4ZFKlJ3mo1yaM7a6TDkgyK1CRvpCZ5IzXJG6lJ3khN8laqSR7pYqkmeWRQpCZ5q9Ukj+4syaBITfJGapI3UpO8kZrkjdQkb6QmeSvVJI90sVSTPDIoUpO81WqSR3eWZFCkJnkjNckbqUneSE3yRmqSN1KTvJVqkke6WKpJHhkUqUneajXJoztLMihSk7yRmuSN1CRvpCZ5IzXJG6lJ3ko1ySNdLNUkjwyK1CRvtZrk0Z0lGRSpSd5ITfJGapI3UpO8kZrkjdQkb6Wa5JEulmqSRwZFapK3Wk3y6M6CDKqTmuSd1CTvpCZ5JzXJ+8tIhwX9HVQv1SQPdLGXapIHBtVJTfJeq0ke3FlSk7yTmuSd1CTvpCZ5JzXJO6lJ3klN8l6qSR7pYqkmeWRQpCZ5r9UkD+4sqUneSU3yTmqSd1KTvJOa5J3UJO+kJnkv1SSPdLFUkzwyKFKTvNdqkgd3ltQk76QmeSc1yTupSd5JTfJOapJ3UpO8l2qSR7pYqkkeGRSpSd5rNcmDO0tqkndSk7yTmuSd1CTvpCZ5JzXJO6lJ3ks1ySNdLNUkjwyK1CTvtZrk0Z010mFJBkVqkndSk7yTmuSd1CTvpCZ5L9Ukj3SxVJM8MihSk7zXapJHd5ZkUKQmeSc1yTupSd5JTfJOapJ3UpO8l2qSR7pYqkkeGRSpSd5rNcmjO0syKFKTvJOa5J3UJO+kJnknNck7qUneSzXJI10s1SSPDIrUJO+1muTRnSUZFKlJ3klN8k5qkndSk7yTmuSd1CTvpZrkkS6WapJHBkVqkvdaTfLozpIMitQkN1KT3EhNciM1yY3UJLeXkQ4LetXFSjXJA4MyUpPcajXJoztLMihSk9xITXIjNcmN1CQ3UpPcSE1yK9Ukj3SxVJM8MihSk9xqNcmDO0tqkhupSW6kJrmRmuRGapIbqUlupCa5lWqSR7pYqkkeGRSpSW61muTBnSU1yY3UJDdSk9xITXIjNcmN1CQ3UpPcSjXJI10s1SSPDIrUJLdaTfLgzpKa5EZqkhupSW6kJrmRmuRGapIbqUlupZrkkS6WapJHBkVqklutJnlwZ0lNciM1yY3UJDdSk9xITXIjNcmN1CS3Uk3ySBdLNckjgyI1ya1Wkzy6s0Y6LMmgSE1yIzXJjdQkN1KT3EhNcivVJI90sVSTPDIoUpPcajXJoztLMihSk9xITXIjNcmN1CQ3UpPcSE1yK9Ukj3SxVJM8MihSk9xqNcmjO0syKFKT3EhNciM1yY3UJDdSk9xITXIr1SSPdLFUkzwyKFKT3Go1yaM7SzIoUpPcSE3yQWqSD1KTfJCa5IPUJB8v4+jiKNUkDwxqkJrko1aTPLqzIIMapCb5IDXJB6lJPkhN8kFqkg9Sk3yUapJHuliqSR4ZFKlJPmo1yaM7SzIoUpN8kJrkg9QkH6Qm+SA1yQepST5KNckjXSzVJI8MitQkH7Wa5MGdJTXJB6lJPkhN8kFqkg9Sk3yQmuSD1CQfpZrkkS6WapJHBkVqko9aTfLgzpKa5IPUJB+kJvkgNckHqUk+SE3yQWqSj1JN8kgXSzXJI4MiNclHrSZ5cGdJTfJBapIPUpN8kJrkg9QkH6Qm+SA1yUepJnmki6Wa5JFBkZrko1aTPLizpCb5IDXJB6lJPkhN8kFqkg9Sk3yQmuSjVJM80sVSTfLIoEhN8lGrSR7dWSMdlmRQpCb5IDXJB6lJPkhN8kFqko9STfJIF0s1ySODIjXJR60meXRnSQZFapIPUpN8kJrkg9QkH6Qm+SA1yUepJnmki6Wa5JFBkZrko1aTPLqzJIMiNckHqUk+SE3ySWqST1KTfJKa5LNUkzzQxfkyjkFNUpN81mqSR3cWZFCT1CSfpCb5JDXJJ6lJPklN8klqks9STfJIF0s1ySODIjXJZ60meXRnSQZFapJPUpN8kprkk9Qkn6Qm+SQ1yWepJnmki6Wa5JFBkZrks1aTPLqzJIMiNcknqUk+SU3ySWqST1KTfJKa5LNUkzzSxVJN8sigSE3yWatJHtxZUpN8kprkk9Qkn6Qm+SQ1ySepST5JTfJZqkke6WKpJnlkUKQm+azVJA/uLKlJPklN8klqkk9Sk3ySmuST1CSfpCb5LNUkj3SxVJM8MihSk3zWapIHd5bUJJ+kJvkkNcknqUk+SU3ySWqST1KTfJZqkke6WKpJHhkUqUk+azXJgztLapJPUpN8kprkk9Qkn6Qm+SQ1ySepST5LNckjXSzVJI8MitQkn7Wa5NGdNdJhSQZFapJPUpN8kprkk9Qkn6Qm+SzVJI90sVSTPDIoUpN81mqSR3eWZFCkJvkkNcknqUk+SU3yRWqSL1KTfJVqkge6uEo1yQODWi8jHRZkUIvUJF+kJvkiNckXqUm+SE3yRWqSL1KTfJVqkke6WKpJHhkUqUm+ajXJoztLMihSk3yRmuSL1CRfpCb5IjXJF6lJvko1ySNdLNUkjwyK1CRftZrk0Z0lGRSpSb5ITfJFapIvUpN8kZrki9QkX6Wa5JEulmqSRwZFapKvWk3y6M6SDIrUJF+kJvkiNckXqUm+SE3yRWqSr1JN8kgXSzXJI4MiNclXrSZ5cGdJTfJFapIvUpN8kZrki9QkX6Qm+SI1yVepJnmki6Wa5JFBkZrkq1aTPLizpCb5IjXJF6lJvkhN8kVqki9Sk3yRmuSrVJM80sVSTfLIoEhN8lWrSR7cWVKTfJGa5IvUJF+kJvkiNckXqUm+SE3yVapJHuliqSZ5ZFCkJvmq1SQP7iypSb5ITfJFapIvUpN8kZrki9QkX6Qm+SrVJI90sVSTPDIoUpN81WqSR3fWSIclGRSpSb5ITfJFapIvUpN8k5rku1STPNDFXapJHhjUJjXJ98tIdxZkUJvUJN+kJvkmNck3qUm+SU3yTWqS71JN8kgXSzXJI4MiNcl3rSZ5dGdJBkVqkm9Sk3yTmuSb1CTfpCb5JjXJd6kmeaSLpZrkkUGRmuS7VpM8urMkgyI1yTepSb5JTfJNapJvUpN8k5rku1STPNLFUk3yyKBITfJdq0ke3VmSQZGa5JvUJN+kJvkmNck3qUm+SU3yXapJHuliqSZ5ZFCkJvmu1SSP7izJoEhN8k1qkm9Sk3yTmuSb1CTfpCb5LtUkj3SxVJM8MihSk3zXapIHd5bUJN+kJvkmNck3qUm+SU3yTWqSb1KTfJdqkke6WKpJHhkUqUm+azXJgztLapJvUpN8k5rkm9Qk36Qm+SY1yTepSb5LNckjXSzVJI8MitQk37Wa5MGdJTXJN6lJvklN8k1qkm9Sk3yTmuSb1CTfpZrkkS6WapJHBkVqku9aTfLgzpKa5JvUJN+kJvkmNck3qUm+SU3yTWqSn1JN8kAXT6kmeWBQh9QkP7Wa5NGdNdJhQQZ1SE3yQ2qSH1KT/JCa5IfUJD+lmuSRLpZqkkcGRWqSn1pN8ujOkgyK1CQ/pCb5ITXJD6lJfkhN8kNqkp9STfJIF0s1ySODIjXJT60meXRnSQZFapIfUpP8kJrkh9QkP6Qm+SE1yU+pJnmki6Wa5JFBkZrkp1aTPLqzJIMiNckPqUl+SE3yQ2qSH1KT/JCa5KdUkzzSxVJN8sigSE3yU6tJHt1ZkkGRmuSH1CQ/pCb5ITXJD6lJfkhN8lOqSR7pYqkmeWRQpCb5qdUkj+4syaBITfJDapIfUpP8kJrkh9QkP6Qm+SnVJI90sVSTPDIoUpP81GqSB3eW1CQ/pCb5ITXJD6lJfkhN8kNqkh9Sk/yUapJHuliqSR4ZFKlJfmo1yYM7S2qSH1KT/JCa5IfUJD+kJvkhNckPqUl+SjXJI10s1SSPDIrUJD+1muTBnSU1yQ+pSX5ITfJDapIfUpP8kJrkh9QkP6Wa5P+si/1Vqkn+zwZ1H5bTJL8PyzGo+7Acg7oPa6TDcgzqPizHoO7DcgzqPizHoO7Dcv4Oqr9KNckjXSzVJI8MCtQkvw9LMihQk/w+LMmgQE3y+7AkgwI1ye/DkgwK1CS/D8t51eU+LMmgQE3y+7BGurMkgwI1ye/DkgwK1CS/D0syKFCT/D4s5++g7sNyXnW5D0syKFCT/D4syaBATfL7sCSDAjXJ78OSDArUJL8PSzIoUJP8PiznVZf7sAYyKFCT/D4syaBATfL7sCSDAjXJ+wvUJL8PSzIoUJP8Pizp76BKNckjXSzVJI8MCtQkvw9LMihQk/w+LMmgQE3y+7AkgwI1ye/DkgwK1CS/D8t51eU+LMmgQE3y+7AkgwI1yfsL1CS/D0syKFCT/D4syaBATfL7sKS/gyrVJI90sVSTPDIoUJP8PizJoEBN8vuwJIMCNcnvw5IMCtQkvw9LMihQk/w+LOdVl/uwJIMCNcn7q1aTPLizoCb5fViSQYGa5PdhjXRYkkGBmuT3YUl/B1WqSR7pYqkmeWBQF6lJftVqkv/znb1ITfKL1CS/XkY6LMigLlKT/CI1yS9Sk/wq1SQPdPEq1SSPDIrUJL9qNcmDO0tqkl+kJvlFapJfpCb5RWqSX6Qm+UVqkl+lmuSRLpZqkkcGRWqSX7Wa5NGdNdJhSQZFapJfpCb5RWqSX6Qm+UVqkl+lmuSRLpZqkkcGRWqSX7Wa5NGdJRkUqUl+kZrkF6lJfpGa5BepSX6RmuRXqSZ5pIulmuSRQZGa5FetJnl0Z0kGRWqSX6Qm+UVqkl+kJvlFapJfpCb5VapJHuliqSZ5ZFCkJvlVq0ke3VmSQZGa5BepSX6RmuQXqUl+kZrkF6lJfpVqkke6WKpJHhkUqUl+1WqSR3eWZFCkJvlFapJfpCb5RWqSX6Qm+UVqkl+lmuSRLpZqkkcGRWqSX7Wa5NGdJRkUqUl+kZrkF6lJfpGa5BepSX6RmuRXqSZ5pIulmuSRQZGa5FetJnlwZ0lN8ovUJL9ITfKL1CS/SE3yi9Qkv0hN8qtUkzzSxVJN8sigSE3yVqtJ/s93tpGa5I3UJG+kJnl7GemwIINqpCZ5IzXJW6kmeaCLrVSTPDIoUpO81WqSB3eW1CRvpCZ5IzXJG6lJ3khN8kZqkjdSk7yVapJHuliqSR4ZFKlJ3mo1yYM7S2qSN1KTvJGa5I3UJG+kJnkjNckbqUneSjXJI10s1SSPDIrUJG+1muTRnTXSYUkGRWqSN1KTvJGa5I3UJG+kJnkr1SSPdLFUkzwyKFKTvNVqkkd3lmRQpCZ5IzXJG6lJ3khN8kZqkjdSk7yVapJHuliqSR4ZFKlJ3mo1yaM7SzIoUpO8kZrkjdQkb6QmeSM1yRupSd5KNckjXSzVJI8MitQkb7Wa5NGdJRkUqUneSE3yRmqSN1KTvJGa5I3UJG+lmuSRLpZqkkcGRWqSt1pN8ujOkgyK1CRvpCZ5IzXJG6lJ3khN8kZqkrdSTfJIF0s1ySODIjXJW60meXRnSQZFapI3UpO8kZrkjdQkb6QmeSM1yVupJnmki6Wa5JFBkZrkrVaT/J/vbCc1yTupSd5JTfJOapL3l5EOCzKoTmqS91JN8kAXe6kmeWBQndQk77Wa5MGdJTXJO6lJ3klN8k5qkndSk7yTmuSd1CTvpZrkkS6WapJHBkVqkvdaTfLgzpKa5J3UJO+kJnknNck7qUneSU3yTmqS91JN8kgXSzXJI4MiNcl7rSZ5cGdJTfJOapJ3UpO8k5rkndQk76QmeSc1yXupJnmki6Wa5JFBkZrkvVaTPLqzRjosyaBITfJOapJ3UpO8k5rkndQk76Wa5JEulmqSRwZFapL3Wk3y6M6SDIrUJO+kJnknNck7qUneSU3yTmqS91JN8kgXSzXJI4MiNcl7rSZ5dGdJBkVqkndSk7yTmuSd1CTvpCZ5JzXJe6kmeaSLpZrkkUGRmuS9VpM8urMkgyI1yTupSd5JTfJOapJ3UpO8k5rkvVSTPNLFUk3yyKBITfJeq0ke3VmSQZGa5J3UJO+kJnknNck7qUneSU3yXqpJHuliqSZ5ZFCkJnmv1SSP7izIoIzUJDdSk9xITXIjNcntZaTDgv4Oyko1yQNdtFJN8sCgjNQkt1pN8uDOkprkRmqSG6lJbqQmuZGa5EZqkhupSW6lmuSRLpZqkkcGRWqSW60meXBnSU1yIzXJjdQkN1KT3EhNciM1yY3UJLdSTfJIF0s1ySODIjXJrVaTPLizpCa5kZrkRmqSG6lJbqQmuZGa5EZqklupJnmki6Wa5JFBkZrkVqtJHtxZUpPcSE1yIzXJjdQkN1KT3EhNciM1ya1UkzzSxVJN8sigSE1yq9Ukj+6skQ5LMihSk9xITXIjNcmN1CQ3UpPcSjXJI10s1SSPDIrUJLdaTfLozpIMitQkN1KT3EhNciM1yY3UJDdSk9xKNckjXSzVJI8MitQkt1pN8ujOkgyK1CQ3UpPcSE1yIzXJjdQkN1KT3Eo1ySNdLNUkjwyK1CS3Wk3y6M6SDIrUJDdSk9xITXIjNcmN1CQ3UpPcSjXJI10s1SSPDIrUJLdaTfLozpIMitQkH6Qm+SA1yQepST5ITfLxMtJhQa+6jFJN8sCgBqlJPmo1yaM7SzIoUpN8kJrkg9QkH6Qm+SA1yQepST5KNckjXSzVJI8MitQkH7Wa5MGdJTXJB6lJPkhN8kFqkg9Sk3yQmuSD1CQfpZrkkS6WapJHBkVqko9aTfLgzpKa5IPUJB+kJvkgNckHqUk+SE3yQWqSj1JN8kgXSzXJI4MiNclHrSZ5cGdJTfJBapIPUpN8kJrkg9QkH6Qm+SA1yUepJnmki6Wa5JFBkZrko1aTPLizpCb5IDXJB6lJPkhN8kFqkg9Sk3yQmuSjVJM80sVSTfLIoEhN8lGrSR7dWSMdlmRQpCb5IDXJB6lJPkhN8kFqko9STfJIF0s1ySODIjXJR60meXRnSQZFapIPUpN8kJrkg9QkH6Qm+SA1yUepJnmki6Wa5JFBkZrko1aTPLqzJIMiNckHqUk+SE3yQWqSD1KTfJCa5KNUkzzSxVJN8sigSE3yUatJHt1ZkkGRmuSD1CSfpCb5JDXJJ6lJPklN8vkyji7OUk3ywKAmqUk+azXJozsLMqhJapJPUpN8kprkk9Qkn6Qm+SQ1yWepJnmki6Wa5JFBkZrks1aTPLqzJIMiNcknqUk+SU3ySWqST1KTfJKa5LNUkzzSxVJN8sigSE3yWatJHtxZUpN8kprkk9Qkn6Qm+SQ1ySepST5JTfJZqkke6WKpJnlkUKQm+azVJA/uLKlJPklN8klqkk9Sk3ySmuST1CSfpCb5LNUkj3SxVJM8MihSk3zWapIHd5bUJJ+kJvkkNcknqUk+SU3ySWqST1KTfJZqkke6WKpJHhkUqUk+azXJgztLapJPUpN8kprkk9Qkn6Qm+SQ1ySepST5LNckjXSzVJI8MitQkn7Wa5NGdNdJhSQZFapJPUpN8kprkk9Qkn6Qm+SzVJI90sVSTPDIoUpN81mqSR3eWZFCkJvkkNcknqUk+SU3ySWqST1KTfJZqkke6WKpJHhkUqUk+azXJoztLMihSk3ySmuST1CRfpCb5IjXJF6lJvko1yQNdXC/jGNQiNclXrSZ5dGdBBrVITfJFapIvUpN8kZrki9QkX6Qm+SrVJI90sVSTPDIoUpN81WqSR3eWZFCkJvkiNckXqUm+SE3yRWqSL1KTfJVqkke6WKpJHhkUqUm+ajXJoztLMihSk3yRmuSL1CRfpCb5IjXJF6lJvko1ySNdLNUkjwyK1CRftZrkwZ0lNckXqUm+SE3yRWqSL1KTfJGa5IvUJF+lmuSRLpZqkkcGRWqSr1pN8uDOkprki9QkX6Qm+SI1yRepSb5ITfJFapKvUk3ySBdLNckjgyI1yVetJnlwZ0lN8kVqki9Sk3yRmuSL1CRfpCb5IjXJV6kmeaSLpZrkkUGRmuSrVpM8uLOkJvkiNckXqUm+SE3yRWqSL1KTfJGa5KtUkzzSxVJN8sigSE3yVatJHt1ZIx2WZFCkJvkiNckXqUm+SE3yRWqSr1JN8kgXSzXJI4MiNclXrSZ5dGdJBkVqki9Sk3yRmuSL1CTfpCb5JjXJd6kmeaCLu1STPDCo/TLSYUEGtUlN8k1qkm9Sk3yTmuSb1CTfpCb5JjXJd6kmeaSLpZrkkUGRmuS7VpM8urMkgyI1yTepSb5JTfJNapJvUpN8k5rku1STPNLFUk3yyKBITfJdq0ke3VmSQZGa5JvUJN+kJvkmNck3qUm+SU3yXapJHuliqSZ5ZFCkJvmu1SSP7izJoEhN8k1qkm9Sk3yTmuSb1CTfpCb5LtUkj3SxVJM8MihSk3zXapIHd5bUJN+kJvkmNck3qUm+SU3yTWqSb1KTfJdqkke6WKpJHhkUqUm+azXJgztLapJvUpN8k5rkm9Qk36Qm+SY1yTepSb5LNckjXSzVJI8MitQk37Wa5MGdJTXJN6lJvklN8k1qkm9Sk3yTmuSb1CTfpZrkkS6WapJHBkVqku9aTfLgzpKa5JvUJN+kJvkmNck3qUm+SU3yTWqS71JN8kgXSzXJI4MiNcl3rSZ5dGeNdFiSQZGa5JvUJN+kJvkmNckPqUl+SjXJA108pZrkgUEdUpP8/hmkOwsyqENqkh9Sk/yQmuSH1CQ/pCb5ITXJT6kmeaSLpZrkkUGRmuSnVpM8urMkgyI1yQ+pSX5ITfJDapIfUpP8kJrkp1STPNLFUk3yyKBITfJTq0ke3VmSQZGa5IfUJD+kJvkhNckPqUl+SE3yU6pJHuliqSZ5ZFCkJvmp1SSP7izJoEhN8kNqkh9Sk/yQmuSH1CQ/pCb5KdUkj3SxVJM8MihSk/zUapJHd5ZkUKQm+SE1yQ+pSX5ITfJDapIfUpP8lGqSR7pYqkkeGRSpSX5qNcmDO0tqkh9Sk/yQmuSH1CQ/pCb5ITXJD6lJfko1ySNdLNUkjwyK1CQ/tZrkwZ0lNckPqUl+SE3yQ2qSH1KT/JCa5IfUJD+lmuSRLpZqkkcGRWqSn1pN8uDOkprkh9QkP6Qm+SE1yQ+pSX5ITfJDapKfUk3ySBdLNckjgyI1yU+tJnlwZ0lN8kNqkh9Sk/yQmuSH1CQ/pCb5ATXJ7/9lzqsu9/8yx6Du/2VOk/z+X+YY1P2/bKTDcgzq/l/mGNT9v8wxqPt/mWNQ9/8yyaBATfL7sJxXXe7DkgwK1CS/D2ukO0syKFCT/D4syaBATfL7sCSDAjXJ78Ny/g7qPiznVZf7sCSDAjXJ78OSDArUJL8PSzIoUJP8PizJoEBN8vuwJIMCNcnvw3JedbkPayCDAjXJ78OSDArUJL8PSzIoUJPcXqAm+X1YkkGBmuT3YUl/B1WqSR7pYqkmeWRQoCb5fViSQYGa5PdhSQYFapLfhyUZFKhJfh+WZFCgJvl9WM6rLvdhSQYFapLfhyUZFKhJbi9Qk/w+LMmgQE3y+7AkgwI1ye/Dkv4OqlSTPNLFUk3yyKBATfL7sCSDAjXJ78OSDArUJL8PSzIoUJP8PizJoEBN8vuwnFdd7sOSDArUJLdXrSZ5cGdBTfL7sCSDAjXJ78Ma6bAkgwI1ye/Dkv4OqlSTPNLFUk3yyKBATfL7sCSDAjXJ78OSDArUJL8PSzIoUJP8PizJoEBN8vuwnFdd7CrVJA8M6iI1ya9aTfJ/vrMXqUl+vYx0WJBBXaQm+UVqkl+kJvlFapJfpZrkkS6WapJHBkVqkl+1muTRnTXSYUkGRWqSX6Qm+UVqkl+kJvlFapJfpZrkkS6WapJHBkVqkl+1muTRnSUZFKlJfpGa5BepSX6RmuQXqUl+kZrkV6kmeaSLpZrkkUGRmuRXrSZ5dGdJBkVqkl+kJvlFapJfpCb5RWqSX6Qm+VWqSR7pYqkmeWRQpCb5VatJHt1ZkkGRmuQXqUl+kZrkF6lJfpGa5BepSX6VapJHuliqSR4ZFKlJftVqkkd3lmRQpCb5RWqSX6Qm+UVqkl+kJvlFapJfpZrkkS6WapJHBkVqkl+1muTRnSUZFKlJfpGa5BepSX6RmuQXqUl+kZrkV6kmeaSLpZrkkUGRmuRXrSZ5cGdJTfKL1CS/SE3yi9Qkv0hN8ovUJL9ITfKrVJM80sVSTfLIoEhN8qtWkzy4s6Qm+UVqkl+kJvlFapJfpCb5RWqSX6Qm+VWqSR7pYqkmeWBQjdQkb7Wa5P98ZxupSd5ITfL2MtJhQQbVSE3yRmqSN1KTvJVqkge62Eo1ySODIjXJW60meXBnSU3yRmqSN1KTvJGa5I3UJG+kJnkjNclbqSZ5pIulmuSRQZGa5K1Wkzy6s0Y6LMmgSE3yRmqSN1KTvJGa5I3UJG+lmuSRLpZqkkcGRWqSt1pN8ujOkgyK1CRvpCZ5IzXJG6lJ3khN8kZqkrdSTfJIF0s1ySODIjXJW60meXRnSQZFapI3UpO8kZrkjdQkb6QmeSM1yVupJnmki6Wa5JFBkZrkrVaTPLqzJIMiNckbqUneSE3yRmqSN1KTvJGa5K1UkzzSxVJN8sigSE3yVqtJHt1ZkkGRmuSN1CRvpCZ5IzXJG6lJ3khN8laqSR7pYqkmeWRQpCZ5q9Ukj+4syaBITfJGapI3UpO8kZrkjdQkb6QmeSvVJI90sVSTPDIoUpO81WqSB3eW1CRvpCZ5IzXJG6lJ3khN8kZqkjdSk7yVapJHuliqSR4ZFKlJ3ms1yf/5znZSk7yTmuSd1CTvLyMdFmRQndQk76QmeS/VJA90sZdqkkcGRWqS91pN8uDOkprkndQk76QmeSc1yTupSd5JTfJOapL3Uk3ySBdLNckjgyI1yXutJnlwZ0lN8k5qkndSk7yTmuSd1CTvpCZ5JzXJe6kmeaSLpZrkkUGRmuS9VpM8urNGOizJoEhN8k5qkndSk7yTmuSd1CTvpZrkkS6WapJHBkVqkvdaTfLozpIMitQk76QmeSc1yTupSd5JTfJOapL3Uk3ySBdLNckjgyI1yXutJnl0Z0kGRWqSd1KTvJOa5J3UJO+kJnknNcl7qSZ5pIulmuSRQZGa5L1Wkzy6sySDIjXJO6lJ3klN8k5qkndSk7yTmuS9VJM80sVSTfLIoEhN8l6rSR7dWZJBkZrkndQk76QmeSc1yTupSd5JTfJeqkke6WKpJnlkUKQmea/VJI/uLMmgSE3yTmqSd1KTvJOa5J3UJO+kJnkv1SSPdLFUkzwyKFKTvNdqkv/znTVSk9xITXIjNcmN1CS3l5EOCzIoIzXJrVSTPNBFK9UkDwzKSE1yq9UkD+4sqUlupCa5kZrkRmqSG6lJbqQmuZGa5FaqSR7pYqkmeWRQpCa51WqSB3eW1CQ3UpPcSE1yIzXJjdQkN1KT3EhNcivVJI90sVSTPDIoUpPcajXJgztLapIbqUlupCa5kZrkRmqSG6lJbqQmuZVqkke6WKpJHhkUqUlutZrk0Z010mFJBkVqkhupSW6kJrmRmuRGapJbqSZ5pIulmuSRQZGa5FarSR7dWZJBkZrkRmqSG6lJbqQmuZGa5EZqklupJnmki6Wa5JFBkZrkVqtJHt1ZkkGRmuRGapIbqUlupCa5kZrkRmqSW6kmeaSLpZrkkUGRmuRWq0ke3VmSQZGa5EZqkhupSW6kJrmRmuRGapJbqSZ5pIulmuSRQZGa5FarSR7dWZJBkZrkRmqSG6lJbqQmuZGa5EZqklupJnmki6Wa5JFBkZrkVqtJHt1ZkEENUpN8kJrkg9QkH6Qm+XgZ6bCgv4MapZrkgS6OUk3ywKAGqUk+ajXJgztLapIPUpN8kJrkg9QkH6Qm+SA1yQepST5KNckjXSzVJI8MitQkH7Wa5MGdJTXJB6lJPkhN8kFqkg9Sk3yQmuSD1CQfpZrkkS6WapJHBkVqko9aTfLgzpKa5IPUJB+kJvkgNckHqUk+SE3yQWqSj1JN8kgXSzXJI4MiNclHrSZ5cGdJTfJBapIPUpN8kJrkg9QkH6Qm+SA1yUepJnmki6Wa5JFBkZrko1aTPLqzRjosyaBITfJBapIPUpN8kJrkg9QkH6Wa5JEulmqSRwZFapKPWk3y6M6SDIrUJB+kJvkgNckHqUk+SE3yQWqSj1JN8kgXSzXJI4MiNclHrSZ5dGdJBkVqkg9Sk3yQmuSD1CQfpCb5IDXJR6kmeaSLpZrkkUGRmuSjVpM8urMkgyI1yQepST5ITfJBapIPUpN8kJrko1STPNLFUk3yyKBITfJRq0ke3VmSQZGa5JPUJJ+kJvkkNcknqUk+X0Y6LOhVl1mqSR4Y1CQ1yWetJnl0Z0kGRWqST1KTfJKa5JPUJJ+kJvkkNclnqSZ5pIulmuSRQZGa5LNWkzy4s6Qm+SQ1ySepST5JTfJJapJPUpN8kprks1STPNLFUk3yyKBITfJZq0ke3FlSk3ySmuST1CSfpCb5JDXJJ6lJPklN8lmqSR7pYqkmeWRQpCb5rNUkD+4sqUk+SU3ySWqST1KTfJKa5JPUJJ+kJvks1SSPdLFUkzwyKFKTfNZqkgd3ltQkn6Qm+SQ1ySepST5JTfJJapJPUpN8lmqSR7pYqkkeGRSpST5rNcmjO2ukw5IMitQkn6Qm+SQ1ySepST5JTfJZqkke6WKpJnlkUKQm+azVJI/uLMmgSE3ySWqST1KTfJKa5JPUJJ+kJvks1SSPdLFUkzwyKFKTfNZqkkd3lmRQpCb5JDXJJ6lJPklN8klqkk9Sk3yWapJHuliqSR4ZFKlJPms1yaM7SzIoUpN8kprki9QkX6Qm+SI1yRepSb5extHFVapJHhjUIjXJV60meXRnQQa1SE3yRWqSL1KTfJGa5IvUJF+kJvkq1SSPdLFUkzwyKFKTfNVqkkd3lmRQpCb5IjXJF6lJvkhN8kVqki9Sk3yVapJHuliqSR4ZFKlJvmo1yYM7S2qSL1KTfJGa5IvUJF+kJvkiNckXqUm+SjXJI10s1SSPDIrUJF+1muTBnSU1yRepSb5ITfJFapIvUpN8kZrki9QkX6Wa5JEulmqSRwZFapKvWk3y4M6SmuSL1CRfpCb5IjXJF6lJvkhN8kVqkq9STfJIF0s1ySODIjXJV60meXBnSU3yRWqSL1KTfJGa5IvUJF+kJvkiNclXqSZ5pIulmuSRQZGa5KtWkzy6s0Y6LMmgSE3yRWqSL1KTfJGa5IvUJF+lmuSRLpZqkkcGRWqSr1pN8ujOkgyK1CRfpCb5IjXJF6lJvkhN8kVqkq9STfJIF0s1ySODIjXJV60meXRnSQZFapIvUpN8kZrkm9Qk36Qm+SY1yXepJnmgi/tlHIPapCb5rtUkj+4syKA2qUm+SU3yTWqSb1KTfJOa5JvUJN+lmuSRLpZqkkcGRWqS71pN8ujOkgyK1CTfpCb5JjXJN6lJvklN8k1qku9STfJIF0s1ySODIjXJd60meXRnSQZFapJvUpN8k5rkm9Qk36Qm+SY1yXepJnmki6Wa5JFBkZrku1aTPLizpCb5JjXJN6lJvklN8k1qkm9Sk3yTmuS7VJM80sVSTfLIoEhN8l2rSR7cWVKTfJOa5JvUJN+kJvkmNck3qUm+SU3yXapJHuliqSZ5ZFCkJvmu1SQP7iypSb5JTfJNapJvUpN8k5rkm9Qk36Qm+S7VJI90sVSTPDIoUpN812qSB3eW1CTfpCb5JjXJN6lJvklN8k1qkm9Sk3yXapJHuliqSR4ZFKlJvms1yaM7a6TDkgyK1CTfpCb5JjXJN6lJvklN8l2qSR7pYqkmeWRQpCb5rtUkj+4syaBITfJNapJvUpN8k5rkh9QkP6Qm+SnVJA908ZRqkgcGdf8M0mFBBnVITfJDapIfUpP8kJrkh9QkP6Qm+SE1yU+pJnmki6Wa5JFBkZrkp1aTPLqzJIMiNckPqUl+SE3yQ2qSH1KT/JCa5KdUkzzSxVJN8sigSE3yU6tJHt1ZkkGRmuSH1CQ/pCb5ITXJD6lJfkhN8lOqSR7pYqkmeWRQpCb5qdUkj+4syaBITfJDapIfUpP8kJrkh9QkP6Qm+SnVJI90sVSTPDIoUpP81GqSB3eW1CQ/pCb5ITXJD6lJfkhN8kNqkh9Sk/yUapJHuliqSR4ZFKlJfmo1yYM7S2qSH1KT/JCa5IfUJD+kJvkhNckPqUl+SjXJI10s1SSPDIrUJD+1muTBnSU1yQ+pSX5ITfJDapIfUpP8kJrkh9QkP6Wa5JEulmqSRwZFapKfWk3y4M6SmuSH1CQ/pCb5ITXJD6lJfkhN8kNqkp9STfJIF0s1ySODIjXJT60meXRnjXRYkkGRmuSH1CQ/pCb5ATXJxwvUJL8Py3nV5T4sx6Duw3Ka5PdhjXRnOQZ1H5ZjUPdhOQZ1H5ZjUPdhSQYFapLfh+X8HdR9WM6rLvdhSQYFapLfhyUZFKhJfh+WZFCgJvl9WJJBgZrk92FJBgVqkt+H5bzqch/WQAYFapLfhyUZFKhJfh+WZFCgJvl4gZrk92FJBgVqkt+H5fwd1H1YA+liqSZ5ZFCgJvl9WJJBgZrk92FJBgVqkt+HJRkUqEl+H5ZkUKAm+X1Yzqsu92FJBgVqkt+HJRkUqEk+XqAm+X1YkkGBmuT3YUkGBWqS34cl/R1UqSZ5pIulmuSRQYGa5PdhSQYFapLfhyUZFKhJfh+WZFCgJvl9WJJBgZrk92E5r7rchyUZFKhJPl61muTBnQU1ye/DkgwK1CS/D2ukw5IMCtQkvw9L+juoUk3ySBdLNckjgwI1ye/DkgwK1CS/D0syKFCT/D4syaBATfL7sCSDAjXJ78NyXnUZr1JN8sigQE3y+7AkgwI1ye/DGumwJIMCNcnvw5IMCtQkvw8L+juoq1STPNDFq1STPDCoi9Qkv2o1yaM7a6TDggzqIjXJL1KT/CI1yS9Sk/wiNcmvUk3ySBdLNckjgyI1ya9aTfLozpIMitQkv0hN8ovUJL9ITfKL1CS/SE3yq1STPNLFUk3yyKBITfKrVpM8urMkgyI1yS9Sk/wiNckvUpP8IjXJL1KT/CrVJI90sVSTPDIoUpP8qtUkj+4syaBITfKL1CS/SE3yi9Qkv0hN8ovUJL9KNckjXSzVJI8MitQkv2o1yaM7SzIoUpP8IjXJL1KT/CI1yS9Sk/wiNcmvUk3ySBdLNckjgyI1ya9aTfLozpIMitQkv0hN8ovUJL9ITfKL1CS/SE3yq1STPNLFUk3yyKBITfKrVpM8uLOkJvlFapJfpCb5RWqSX6Qm+UVqkl+kJvlVqkke6WKpJnlkUKQm+VWrSR7cWVKT/CI1yS9Sk/wiNckvUpP8IjXJL1KT/CrVJI90sVSTPDIoUpP8qtUkD+4sqUl+kZrkF6lJfpGa5BepSX6RmuQXqUl+lWqSB7rYSjXJA4NqpCZ5q9Uk/+c720hN8vYy0mFBBtVITfJGapI3UpO8kZrkrVSTPNLFUk3yyKBITfJWq0ke3VkjHZZkUKQmeSM1yRupSd5ITfJGapK3Uk3ySBdLNckjgyI1yVutJnl0Z0kGRWqSN1KTvJGa5I3UJG+kJnkjNclbqSZ5pIulmuSRQZGa5K1Wkzy6sySDIjXJG6lJ3khN8kZqkjdSk7yRmuStVJM80sVSTfLIoEhN8larSR7dWZJBkZrkjdQkb6QmeSM1yRupSd5ITfJWqkke6WKpJnlkUKQmeavVJI/uLMmgSE3yRmqSN1KTvJGa5I3UJG+kJnkr1SSPdLFUkzwyKFKTvNVqkkd3lmRQpCZ5IzXJG6lJ3khN8kZqkjdSk7yVapJHuliqSR4ZFKlJ3mo1yYM7S2qSN1KTvJGa5I3UJG+kJnkjNckbqUneSjXJI10s1SSPDIrUJG+1muTBnSU1yRupSd5ITfJGapI3UpO8kZrkjdQkb6Wa5JEulmqSBwbVSU3yXqtJ/s93tpOa5J3UJO8vIx0WZFCd1CTvpCZ5JzXJe6kmeaCLvVSTPDIoUpO812qSB3eW1CTvpCZ5JzXJO6lJ3klN8k5qkndSk7yXapJHuliqSR4ZFKlJ3ms1yaM7a6TDkgyK1CTvpCZ5JzXJO6lJ3klN8l6qSR7pYqkmeWRQpCZ5r9Ukj+4syaBITfJOapJ3UpO8k5rkndQk76QmeS/VJI90sVSTPDIoUpO812qSR3eWZFCkJnknNck7qUneSU3yTmqSd1KTvJdqkke6WKpJHhkUqUneazXJoztLMihSk7yTmuSd1CTvpCZ5JzXJO6lJ3ks1ySNdLNUkjwyK1CTvtZrk0Z0lGRSpSd5JTfJOapJ3UpO8k5rkndQk76Wa5JEulmqSRwZFapL3Wk3y6M6SDIrUJO+kJnknNck7qUneSU3yTmqS91JN8kgXSzXJI4MiNcl7rSZ5cGdJTfJOapJ3UpO8k5rkndQk76QmeSc1yXupJnmki6Wa5JFBkZrkVqtJ/s931khNciM1yY3UJLeXkQ4LMigjNcmN1CS3Uk3yQBetVJM8MihSk9xqNcmDO0tqkhupSW6kJrmRmuRGapIbqUlupCa5lWqSR7pYqkkeGRSpSW61muTBnSU1yY3UJDdSk9xITXIjNcmN1CQ3UpPcSjXJI10s1SSPDIrUJLdaTfLozhrpsCSDIjXJjdQkN1KT3EhNciM1ya1UkzzSxVJN8sigSE1yq9Ukj+4syaBITXIjNcmN1CQ3UpPcSE1yIzXJrVSTPNLFUk3yyKBITXKr1SSP7izJoEhNciM1yY3UJDdSk9xITXIjNcmtVJM80sVSTfLIoEhNcqvVJI/uLMmgSE1yIzXJjdQkN1KT3EhNciM1ya1UkzzSxVJN8sigSE1yq9Ukj+4syaBITXIjNcmN1CQ3UpPcSE1yIzXJrVSTPNLFUk3yyKBITXKr1SSP7izJoEhNciM1yY3UJDdSk9xITXIjNcmtVJM80sVKTfK+54/DWvvV/8kWMqj4sIUMql/752H/Psa/+Ofj+vnPx9Wvn//8/6EZlQrm2WgK2Vk2mkIul42mkPn9SzR99h9o+voFGhMaD00hq8xGU8hBs9FUMtZkNJX8NhkN14YjNJVq9NlouDYcouHacIhGNuyiMaHx0MiGXTSyYReNbNhFIxt20ciGPTSVXhbIRiMbdtHIhl00smEXjQmNh0Y27KKRDbtoZMMuGtmwi0Y27KGp9EpENhrZsItGNuyikQ27aExoPDSyYReNbNhFIxt20ciGXTSyYQ9NpRc/stHIhl00smEXjWzYRWNC46GRDbtoZMMuGtmwi0Y27KKRDXtoKr3eko1GNuyikQ27aGTDLhoTGg+NbNhFIxt20ciGXTSyYReNbNhDU+klnmw0smEXjWzYRSMbdtGY0HhoZMMuGtmwi0Y27KKRDbtoZMMemkqvKmWjkQ27aGTDLhrZsIvGhMZDIxt20ciGXTSyYReNbNhFIxv20FR6ISsbjWzYRSMbdtHIhl00JjQeGtmwi0Y27KKRDbtoZMMuGtmwh6bSa2fZaGTDLhrZsItGNuyiMaHx0MiGXTSyYReNbNhFIxt20ciGHTQT/BZdiEY27KKRDbtoZMMuGhMaD41s2EUjG3bRyIZdNLJhF41s2EOjt+h8NLJhF41s2EUjG3bRmNB4aGTDLhrZsItGNuyikQ27aGTDHhq9ReejkQ27aGTDLhrZsIvGhMZDIxt20ciGXTSyYReNbNhFIxv20OgtOh+NbNhFIxt20ciGXTQmNB4a2bCLRjbsopENu2hkwy4a2bCHRm/R+Whkwy4a2bCLRjbsojGh8dDIhl00smEXjWzYRSMbdtHIhj00eovORyMbdtHIhl00smEXjQmNh0Y27KKRDbtoZMMuGtmwi0Y27KHRW3Q+Gtmwi0Y27KKRDbtoTGg8NLJhF41s2EUjG3bRyIZdNLJhD43eovPRyIZdNLJhF41s2EVjQuOhkQ27aGTDLhrZsItGNuyikQ17aPQWnY9GNuyikQ27aGTDLhoTGg+NbNhFIxt20ciGXTSyYReNbNhDo7fofDSyYReNbNhFIxt20ZjQeGhkwy4a2bCLRjbsopENu2hkww6apbfofDSyYReNbNhFIxt20ZjQeGhkwy4a2bCLRjbsopENu2hkwx4avUXno5ENu2hkwy4a2bCLxoTGQyMbdtHIhl00smEXjWzYRSMb9tDoLTofjWzYRSMbdtHIhl00JjQeGtmwi0Y27KKRDbtoZMMuGtmwh0Zv0floZMMuGtmwi0Y27KIxofHQyIZdNLJhF41s2EUjG3bRyIY9NHqLzkcjG3bRyIZdNLJhF40JjYdGNuyikQ27aGTDLhrZsItGNuyh0Vt0PhrZsItGNuyikQ27aExoPDSyYReNbNhFIxt20ciGXTSyYQ+N3qLz0ciGXTSyYReNbNhFY0LjoZENu2hkwy4a2bCLRjbsopENe2j0Fp2PRjbsopENu2hkwy4aExoPjWzYRSMbdtHIhl00smEXjWzYQ6O36Hw0smEXjWzYRSMbdtGY0HhoZMMuGtmwi0Y27KKRDbtoZMMeGr1F56ORDbtoZMMuGtmwi8aExkMjG3bRyIZdNLJhF41s2EUjG3bQbL1F56ORDbtoZMMuGtmwi8aExkMjG3bRyIZdNLJhF41s2EUjG/bQ6C06H41s2EUjG3bRyIZdNCY0HhrZsItGNuyikQ27aGTDLhrZsIdGb9H5aGTDLhrZsItGNuyiMaHx0MiGXTSyYReNbNhFIxt20ciGPTR6i85HIxt20ciGXTSyYReNCY2HRjbsopENu2hkwy4a2bCLRjbsodFbdD4a2bCLRjbsopENu2hMaDw0smEXjWzYRSMbdtHIhl00smEPjd6i89HIhl00smEXjWzYRWNC46GRDbtoZMMuGtmwi0Y27KKRDXto9Badj0Y27KKRDbtoZMMuGhMaD41s2EUjG3bRyIZdNLJhF41s2EOjt+h8NLJhF41s2EUjG3bRmNB4aGTDLhrZsItGNuyikQ27aGTDHhq9ReejkQ27aGTDLhrZsIvGhMZDIxt20ciGXTSyYReNbNhFIxv20OgtOh+NbNhFIxt20ciGXTQmNB4a2bCLRjbsopENu2hkwy4a2bCD5ugtOh+NbNhFIxt20ciGXTQmNB4a2bCLRjbsopENu2hkwy4a2bCHRm/R+Whkwy4a2bCLRjbsojGh8dDIhl00smEXjWzYRSMbdtHIhj00eovORyMbdtHIhl00smEXjQmNh0Y27KKRDbtoZMMuGtmwi0Y27KHRW3Q+Gtmwi0Y27KKRDbtoTGg8NLJhF41s2EUjG3bRyIZdNLJhD43eovPRyIZdNLJhF41s2EVjQuOhkQ27aGTDLhrZsItGNuyikQ17aPQWnY9GNuyikQ27aGTDLhoTGg+NbNhFIxt20ciGXTSyYReNbNhDo7fofDSyYReNbNhFIxt20ZjQeGhkwy4a2bCLRjbsopENu2hkwx4avUXno5ENu2hkwy4a2bCLxoTGQyMbdtHIhl00smEXjWzYRSMb9tDoLTofjWzYRSMbdtHIhl00JjQeGtmwi0Y27KKRDbtoZMMuGtmwh0Zv0floZMMuGtmwi0Y27KIxofHQyIZdNLJhF41s2EUjG3bRyIZ/jWa+9Badj0Y27KKRDbtoZMMuGhMaD41s2EUjG3bRyIZdNLJhF41s2EOjt+h8NLJhF41s2EUjG3bRmNB4aGTDLhrZsItGNuyikQ27aGTDHhq9ReejkQ27aGTDLhrZsIvGhMZDIxt20ciGXTSyYReNbNhFIxv20OgtOh+NbNhFIxt20ciGXTQmNB4a2bCLRjbsopENu2hkwy4a2bCHRm/R+Whkwy4a2bCLRjbsojGh8dDIhl00smEXjWzYRSMbdtHIhj00eovORyMbdtHIhl00smEXjQmNh0Y27KKRDbtoZMMuGtmwi0Y27KHRW3Q+Gtmwi0Y27KKRDbtoTGg8NLJhF41s2EUjG3bRyIZdNLJhD43eovPRyIZdNLJhF41s2EVjQuOhkQ27aGTDLhrZsItGNuyikQ17aPQWnY9GNuyikQ27aGTDLhoTGg+NbNhFIxt20ciGXTSyYReNbNhDo7fofDSyYReNbNhFIxt20ZjQeGhkwy4a2bCLRjbsopENu2hkww6aS2/R+Whkwy4a2bCLRjbsojGh8dDIhl00smEXjWzYRSMbdtHIhj00eovORyMbdtHIhl00smEXjQmNh0Y27KKRDbtoZMMuGtmwi0Y27KHRW3Q+Gtmwi0Y27KKRDbtoTGg8NLJhF41s2EUjG3bRyIZdNLJhD43eovPRyIZdNLJhF41s2EVjQuOhkQ27aGTDLhrZsItGNuyikQ17aPQWnY9GNuyikQ27aGTDLhoTGg+NbNhFIxt20ciGXTSyYReNbNhDo7fofDSyYReNbNhFIxt20ZjQeGhkwy4a2bCLRjbsopENu2hkwx4avUXno5ENu2hkwy4a2bCLxoTGQyMbdtHIhl00smEXjWzYRSMb9tDoLTofjWzYRSMbdtHIhl00JjQeGtmwi0Y27KKRDbtoZMMuGtmwh0Zv0floZMMuGtmwi0Y27KIxofHQyIZdNLJhF41s2EUjG3bRyIY9NHqLzkcjG3bRyIZdNLJhF40JjYdGNuyikQ27aGTDLhrZsItGNuygaXqLzkcjG3bRyIZdNLJhF40JjYdGNuyikQ27aGTDLhrZsItGNuyh0Vt0PhrZsItGNuyikQ27aExoPDSyYReNbNhFIxt20ciGXTSyYQ+N3qLz0ciGXTSyYReNbNhFY0LjoZENu2hkwy4a2bCLRjbsopENe2j0Fp2PRjbsopENu2hkwy4aExoPjWzYRSMbdtHIhl00smEXjWzYQ6O36Hw0smEXjWzYRSMbdtGY0HhoZMMuGtmwi0Y27KKRDbtoZMMeGr1F56ORDbtoZMMuGtmwi8aExkMjG3bRyIZdNLJhF41s2EUjG/bQ6C06H41s2EUjG3bRyIZdNCY0HhrZsItGNuyikQ27aGTDLhrZsIdGb9H5aGTDLhrZsItGNuyiMaHx0MiGXTSyYReNbNhFIxt20ciGPTR6i85HIxt20ciGXTSyYReNCY2HRjbsopENu2hkwy4a2bCLRjbsodFbdD4a2bCLRjbsopENu2hMaDw0smEXjWzYRSMbdtHIhl00smEHTddbdD4a2bCLRjbsopENu2hMaDw0smEXjWzYRSMbdtHIhl00smEPjd6i89HIhl00smEXjWzYRWNC46GRDbtoZMMuGtmwi0Y27KKRDXto9Badj0Y27KKRDbtoZMMuGhMaD41s2EUjG3bRyIZdNLJhF41s2EOjt+h8NLJhF41s2EUjG3bRmNB4aGTDLhrZsItGNuyikQ27aGTDHhq9ReejkQ27aGTDLhrZsIvGhMZDIxt20ciGXTSyYReNbNhFIxv20OgtOh+NbNhFIxt20ciGXTQmNB4a2bCLRjbsopENu2hkwy4a2bCHRm/R+Whkwy4a2bCLRjbsojGh8dDIhl00smEXjWzYRSMbdtHIhj00eovORyMbdtHIhl00smEXjQmNh0Y27KKRDbtoZMMuGtmwi0Y27KHRW3Q+Gtmwi0Y27KKRDbtoTGg8NLJhF41s2EUjG3bRyIZdNLJhD43eovPRyIZdNLJhF41s2EVjQuOhkQ27aGTDLhrZsItGNuyikQ07aExv0floZMMuGtmwi0Y27KIxofHQyIZdNLJhF41s2EUjG3bRyIY9NHqLzkcjG3bRyIZdNLJhF40JjYdGNuyikQ27aGTDLhrZsItGNuyh0Vt0PhrZsItGNuyikQ27aExoPDSyYReNbNhFIxt20ciGXTSyYQ+N3qLz0ciGXTSyYReNbNhFY0LjoZENu2hkwy4a2bCLRjbsopENe2j0Fp2PRjbsopENu2hkwy4aExoPjWzYRSMbdtHIhl00smEXjWzYQ6O36Hw0smEXjWzYRSMbdtGY0HhoZMMuGtmwi0Y27KKRDbtoZMMeGr1F56ORDbtoZMMuGtmwi8aExkMjG3bRyIZdNLJhF41s2EUjG/bQ6C06H41s2EUjG3bRyIZdNCY0HhrZsItGNuyikQ27aGTDLhrZsIdGb9H5aGTDLhrZsItGNuyiMaHx0MiGXTSyYReNbNhFIxt20ciGPTR6i85HIxt20ciGXTSyYReNCY2HRjbsopENu2hkwy4a2bCLRjbsoBl6i85HIxt20ciGXTSyYReNCY2HRjbsopENu2hkwy4a2bCLRjbsodFbdD4a2bCLRjbsopENu2hMaDw0smEXjWzYRSMbdtHIhl00smEPjd6i89HIhl00smEXjWzYRWNC46GRDbtoZMMuGtmwi0Y27KKRDXto9Badj0Y27KKRDbtoZMMuGhMaD41s2EUjG3bRyIZdNLJhF41s2EOjt+h8NLJhF41s2EUjG3bRmNB4aGTDLhrZsItGNuyikQ27aGTDHhq9ReejkQ27aGTDLhrZsIvGhMZDIxt20ciGXTSyYReNbNhFIxv20OgtOh+NbNhFIxt20ciGXTQmNB4a2bCLRjbsopENu2hkwy4a2bCHRm/R+Whkwy4a2bCLRjbsojGh8dDIhl00smEXjWzYRSMbdtHIhj00eovORyMbdtHIhl00smEXjQmNh0Y27KKRDbtoZMMuGtmwi0Y27KHRW3Q+Gtmwi0Y27KKRDbtoTGg8NLJhF41s2EUjG3bRyIZdNLJhB83UW3Q+Gtmwi0Y27KKRDbtoTGg8NLJhF41s2EUjG3bRyIZdNLJhD43eovPRyIZdNLJhF41s2EVjQuOhkQ27aGTDLhrZsItGNuyikQ17aPQWnY9GNuyikQ27aGTDLhoTGg+NbNhFIxt20ciGXTSyYReNbNhDo7fofDSyYReNbNhFIxt20ZjQeGhkwy4a2bCLRjbsopENu2hkwx4avUXno5ENu2hkwy4a2bCLxoTGQyMbdtHIhl00smEXjWzYRSMb9tDoLTofjWzYRSMbdtHIhl00JjQeGtmwi0Y27KKRDbtoZMMuGtmwh0Zv0floZMMuGtmwi0Y27KIxofHQyIZdNLJhF41s2EUjG3bRyIY9NHqLzkcjG3bRyIZdNLJhF40JjYdGNuyikQ27aGTDLhrZsItGNuyh0Vt0PhrZsItGNuyikQ27aExoPDSyYReNbNhFIxt20ciGXTSyYQ+N3qLz0ciGXTSyYReNbNhFY0LjoZENu2hkwy4a2bCLRjbsopENO2iW3qLz0ciGXTSyYReNbNhFY0LjoZENu2hkwy4a2bCLRjbsopENe2j0Fp2PRjbsopENu2hkwy4aExoPjWzYRSMbdtHIhl00smEXjWzYQ6O36Hw0smEXjWzYRSMbdtGY0HhoZMMuGtmwi0Y27KKRDbtoZMMeGr1F56ORDbtoZMMuGtmwi8aExkMjG3bRyIZdNLJhF41s2EUjG/bQ6C06H41s2EUjG3bRyIZdNCY0HhrZsItGNuyikQ27aGTDLhrZsIdGb9H5aGTDLhrZsItGNuyiMaHx0MiGXTSyYReNbNhFIxt20ciGPTR6i85HIxt20ciGXTSyYReNCY2HRjbsopENu2hkwy4a2bCLRjbsodFbdD4a2bCLRjbsopENu2hMaDw0smEXjWzYRSMbdtHIhl00smEPjd6i89HIhl00smEXjWzYRWNC46GRDbtoZMMuGtmwi0Y27KKRDXto9Badj0Y27KKRDbtoZMMuGhMaD41s2EUjG3bRyIZdNLJhF41s2EGz9Radj0Y27KKRDbtoZMMuGhMaD41s2EUjG3bRyIZdNLJhF41s2EOjt+h8NLJhF41s2EUjG3bRmNB4aGTDLhrZsItGNuyikQ27aGTDHhq9ReejkQ27aGTDLhrZsIvGhMZDIxt20ciGXTSyYReNbNhFIxv20OgtOh+NbNhFIxt20ciGXTQmNB4a2bCLRjbsopENu2hkwy4a2bCHRm/R+Whkwy4a2bCLRjbsojGh8dDIhl00smEXjWzYRSMbdtHIhj00eovORyMbdtHIhl00smEXjQmNh0Y27KKRDbtoZMMuGtmwi0Y27KHRW3Q+Gtmwi0Y27KKRDbtoTGg8NLJhF41s2EUjG3bRyIZdNLJhD43eovPRyIZdNLJhF41s2EVjQuOhkQ27aGTDLhrZsItGNuyikQ17aPQWnY9GNuyikQ27aGTDLhoTGg+NbNhFIxt20ciGXTSyYReNbNhDo7fofDSyYReNbNhFIxt20ZjQeGhkwy4a2bCLRjbsopENu2hkww6ao7fofDSyYReNbNhFIxt20ZjQeGhkwy4a2bCLRjbsopENu2hkwx4avUXno5ENu2hkwy4a2bCLxoTGQyMbdtHIhl00smEXjWzYRSMb9tDoLTofjWzYRSMbdtHIhl00JjQeGtmwi0Y27KKRDbtoZMMuGtmwh0Zv0floZMMuGtmwi0Y27KIxofHQyIZdNLJhF41s2EUjG3bRyIY9NHqLzkcjG3bRyIZdNLJhF40JjYdGNuyikQ27aGTDLhrZsItGNuyh0Vt0PhrZsItGNuyikQ27aExoPDSyYReNbNhFIxt20ciGXTSyYQ+N3qLz0ciGXTSyYReNbNhFY0LjoZENu2hkwy4a2bCLRjbsopENe2j0Fp2PRjbsopENu2hkwy4aExoPjWzYRSMbdtHIhl00smEXjWzYQ6O36Hw0smEXjWzYRSMbdtGY0HhoZMMuGtmwi0Y27KKRDbtoZMMeGr1F56ORDbtoZMMuGtmwi8aExkMjG3bRyIZdNLJhF41s2EUjG/41mvXSW3Q+Gtmwi0Y27KKRDbtoTGg8NLJhF41s2EUjG3bRyIZdNLJhD43eovPRyIZdNLJhF41s2EVjQuOhkQ27aGTDLhrZsItGNuyikQ17aPQWnY9GNuyikQ27aGTDLhoTGg+NbNhFIxt20ciGXTSyYReNbNhDo7fofDSyYReNbNhFIxt20ZjQeGhkwy4a2bCLRjbsopENu2hkwx4avUXno5ENu2hkwy4a2bCLxoTGQyMbdtHIhl00smEXjWzYRSMb9tDoLTofjWzYRSMbdtHIhl00JjQeGtmwi0Y27KKRDbtoZMMuGtmwh0Zv0floZMMuGtmwi0Y27KIxofHQyIZdNLJhF41s2EUjG3bRyIY9NHqLzkcjG3bRyIZdNLJhF40JjYdGNuyikQ27aGTDLhrZsItGNuyh0Vt0PhrZsItGNuyikQ27aExoPDSyYReNbNhFIxt20ciGXTSyYQ+N3qLz0ciGXTSyYReNbNhFY0LjoZENu2hkwy4a2bCLRjbsopENO2guvUXno5ENu2hkwy4a2bCLxoTGQyMbdtHIhl00smEXjWzYRSMb9tDoLTofjWzYRSMbdtHIhl00JjQeGtmwi0Y27KKRDbtoZMMuGtmwh0Zv0floZMMuGtmwi0Y27KIxofHQyIZdNLJhF41s2EUjG3bRyIY9NHqLzkcjG3bRyIZdNLJhF40JjYdGNuyikQ27aGTDLhrZsItGNuyh0Vt0PhrZsItGNuyikQ27aExoPDSyYReNbNhFIxt20ciGXTSyYQ+N3qLz0ciGXTSyYReNbNhFY0LjoZENu2hkwy4a2bCLRjbsopENe2j0Fp2PRjb8/7H3r1mOI0nSBbiXWQEeagZg9r+wYZ0vnOE1TXUgmVKuQtjtX3X6MCOIa2KgXg17pGiohlM0VMMpmgBNhoZqOEVDNZyioRpO0VANp2iohjM03EWXo6EaTtFQDadoqIZTNAGaDA3VcIqGajhFQzWcoqEaTtFQDWdouIsuR0M1nKKhGk7RUA2naAI0GRqq4RQN1XCKhmo4RUM1nKKhGs7QcBddjoZqOEVDNZyioRpO0QRoMjRUwykaquEUDdVwioZqOEVDNZygWbiLLkdDNZyioRpO0VANp2gCNBkaquEUDdVwioZqOEVDNZyioRrO0HAXXY6GajhFQzWcoqEaTtEEaDI0VMMpGqrhFA3VcIqGajhFQzWcoeEuuhwN1XCKhmo4RUM1nKIJ0GRoqIZTNFTDKRqq4RQN1XCKhmo4Q8NddDkaquEUDdVwioZqOEUToMnQUA2naKiGUzRUwykaquEUDdVwhoa76HI0VMMpGqrhFA3VcIomQJOhoRpO0VANp2iohlM0VMMpGqrhDA130eVoqIZTNFTDKRqq4RRNgCZDQzWcoqEaTtFQDadoqIZTNFTDGRruosvRUA2naKiGUzRUwymaAE2Ghmo4RUM1nKKhGk7RUA2naKiGMzTcRZejoRpO0VANp2iohlM0AZoMDdVwioZqOEVDNZyioRpO0VANZ2i4iy5HQzWcoqEaTtFQDadoAjQZGqrhFA3VcIqGajhFQzWcoqEaztBwF12Ohmo4RUM1nKKhGk7RBGgyNFTDKRqq4RQN1XCKhmo4RUM1nKBZuYsuR0M1nKKhGk7RUA2naAI0GRqq4RQN1XCKhmo4RUM1nKKhGs7QcBddjoZqOEVDNZyioRpO0QRoMjRUwykaquEUDdVwioZqOEVDNZyh4S66HA3VcIqGajhFQzWcognQZGiohlM0VMMpGqrhFA3VcIqGajhDw110ORqq4RQN1XCKhmo4RROgydBQDadoqIZTNFTDKRqq4RQN1XCGhrvocjRUwykaquEUDdVwiiZAk6GhGk7RUA2naKiGUzRUwykaquEMDXfR5WiohlM0VMMpGqrhFE2AJkNDNZyioRpO0VANp2iohlM0VMMZGu6iy9FQDadoqIZTNFTDKZoATYaGajhFQzWcoqEaTtFQDadoqIYzNNxFl6OhGk7RUA3/fzI0VMMpmgBNhoZqOEVDNZyioRpO0VANp2iohjM03EWXo6EaTtFQDadoqIZTNAGaDA3VcIqGajhFQzWcoqEaTtFQDWdouIsuR0M1nKKhGk7RUA2naAI0GRqq4RQN1XCKhmo4RUM1nKKhGk7QBHfR5WiohlM0VMMpGqrhFE2AJkNDNZyioRpO0VANp2iohlM0VMMZGu6iy9FQDadoqIZTNFTDKZoATYaGajhFQzWcoqEaTtFQDadoqIYzNNxFl6OhGk7RUA2naKiGUzQBmgwN1XCKhmo4RUM1nKKhGk7RUA1naLiLLkdDNZyioRpO0VANp2gCNBkaquEUDdVwioZqOEVDNZyioRrO0HAXXY6GajhFQzWcoqEaTtEEaDI0VMMpGqrhFA3VcIqGajhFQzWcoeEuuhwN1XCKhmo4RUM1nKIJ0GRoqIZTNFTDKRqq4RQN1XCKhmo4Q8NddDkaquEUDdVwioZqOEUToMnQUA2naKiGUzRUwykaquEUDdVwhoa76HI0VMMpGqrhFA3VcIomQJOhoRpO0VANp2iohlM0VMMpGqrhDA130eVoqIZTNFTDKRqq4RRNgCZDQzWcoqEaTtFQDadoqIZTNFTDGRruosvRUA2naKiGUzRUwymaAE2Ghmo4RUM1nKKhGk7RUA2naKiGEzSNu+hyNFTDKRqq4RQN1XCKJkCToaEaTtFQDadoqIZTNFTDKRqq4QwNd9HlaKiGUzRUwykaquEUTYAmQ0M1nKKhGk7RUA2naKiGUzRUwxka7qLL0VANp2iohlM0VMMpmgBNhoZqOEVDNZyioRpO0VANp2iohjM03EWXo6EaTtFQDadoqIZTNAGaDA3VcIqGajhFQzWcoqEaTtFQDWdouIsuR0M1nKKhGk7RUA2naAI0GRqq4RQN1XCKhmo4RUM1nKKhGs7QcBddjoZqOEVDNZyioRpO0QRoMjRUwykaquEUDdVwioZqOEVDNZyh4S66HA3VcIqGajhFQzWcognQZGiohlM0VMMpGqrhFA3VcIqGajhDw110ORqq4RQN1XCKhmo4RROgydBQDadoqIZTNFTDKRqq4RQN1XCGhrvocjRUwykaquEUDdVwiiZAk6GhGk7RUA2naKiGUzRUwykaquEMDXfR5WiohlM0VMMpGqrhFE2AJkNDNZyioRpO0VANp2iohlM0VMMJms5ddDkaquEUDdVwioZqOEUToMnQUA2naKiGUzRUwykaquEUDdVwhoa76HI0VMMpGqrhFA3VcIomQJOhoRpO0VANp2iohlM0VMMpGqrhDA130eVoqIZTNFTDKRqq4RRNgCZDQzWcoqEaTtFQDadoqIZTNFTDGRruosvRUA2naKiGUzRUwymaAE2Ghmo4RUM1nKKhGk7RUA2naKiGMzTcRZejoRpO0VANp2iohlM0AZoMDdVwioZqOEVDNZyioRpO0VANZ2i4iy5HQzWcoqEaTtFQDadoAjQZGqrhFA3VcIqGajhFQzWcoqEaztBwF12Ohmo4RUM1nKKhGk7RBGgyNFTDKRqq4RQN1XCKhmo4RUM1nKHhLrocDdVwioZqOEVDNZyiCdBkaKiGUzRUwykaquEUDdVwioZqOEPDXXQ5GqrhFA3VcIqGajhFE6DJ0FANp2iohlM0VMMpGqrhFA3VcIaGu+hyNFTDKRqq4RQN1XCKJkCToaEaTtFQDadoqIZTNFTDKRqq4QTNxl10ORqq4RQN1XCKhmo4RROgydBQDadoqIZTNFTDKRqq4RQN1XCGhrvocjRUwykaquEUDdVwiiZAk6GhGk7RUA2naKiGUzRUwykaquEMDXfR5WiohlM0VMMpGqrhFE2AJkNDNZyioRpO0VANp2iohlM0VMMZGu6iy9FQDadoqIZTNFTDKZoATYaGajhFQzWcoqEaTtFQDadoqIYzNNxFl6OhGk7RUA2naKiGUzQBmgwN1XCKhmo4RUM1nKKhGk7RUA1naLiLLkdDNZyioRpO0VANp2gCNBkaquEUDdVwioZqOEVDNZyioRrO0HAXXY6GajhFQzWcoqEaTtEEaDI0VMMpGqrhFA3VcIqGajhFQzWcoeEuuhwN1XCKhmo4RUM1nKIJ0GRoqIZTNFTDKRqq4RQN1XCKhmo4Q8NddDkaquEUDdVwioZqOEUToMnQUA2naKiGUzRUwykaquEUDdVwhoa76HI0VMMpGqrhFA3VcIomQJOhoRpO0VANp2iohlM0VMMpGqrhBM3OXXQ5GqrhFA3VcIqGajhFE6DJ0FANp2iohlM0VMMpGqrhFA3VcIaGu+hyNFTDKRqq4RQN1XCKJkCToaEaTtFQDadoqIZTNFTDKRqq4QwNd9HlaKiGUzRUwykaquEUTYAmQ0M1nKKhGk7RUA2naKiGUzRUwxka7qLL0VANp2iohlM0VMMpmgBNhoZqOEVDNZyioRpO0VANp2iohjM03EWXo6EaTtFQDadoqIZTNAGaDA3VcIqGajhFQzWcoqEaTtFQDWdouIsuR0M1nKKhGk7RUA2naAI0GRqq4RQN1XCKhmo4RUM1nKKhGs7QcBddjoZqOEVDNZyioRpO0QRoMjRUwykaquEUDdVwioZqOEVDNZyh4S66HA3VcIqGajhFQzWcognQZGiohlM0VMMpGqrhFA3VcIqGajhDw110ORqq4RQN1XCKhmo4RROgydBQDadoqIZTNFTDKRqq4RQN1XCGhrvocjRUwykaquEUDdVwiiZAk6GhGk7RUA2naKiGUzRUwykaquEEzcFddDkaquEUDdVwioZqOEUToMnQUA2naKiGUzRUwykaquEUDdVwhoa76HI0VMMpGqrhFA3VcIomQJOhoRpO0VANp2iohlM0VMMpGqrhDA130eVoqIZTNFTDKRqq4RRNgCZDQzWcoqEaTtFQDadoqIZTNFTDGRruosvRUA2naKiGUzRUwymaAE2Ghmo4RUM1nKKhGk7RUA2naKiGMzTcRZejoRpO0VANp2iohlM0AZoMDdVwioZqOEVDNZyioRpO0VANZ2i4iy5HQzWcoqEaTtFQDadoAjQZGqrhFA3VcIqGajhFQzWcoqEaztBwF12Ohmo4RUM1nKKhGk7RBGgyNFTDKRqq4RQN1XCKhmo4RUM1nKHhLrocDdVwioZqOEVDNZyiCdBkaKiGUzRUwykaquEUDdVwioZqOEPDXXQ5GqrhFA3VcIqGajhFE6DJ0FANp2iohlM0VMMpGqrhFA3VcIaGu+hyNFTDKRqq4RQN1XCKJkCToaEaTtFQDadoqIZTNFTDKRqq4ddo9om76HI0VMMpGqrhFA3VcIomQJOhoRpO0VANp2iohlM0VMMpGqrhDA130eVoqIZTNFTDKRqq4RRNgCZDQzWcoqEaTtFQDadoqIZTNFTDGRruosvRUA2naKiGUzRUwymaAE2Ghmo4RUM1nKKhGk7RUA2naKiGMzTcRZejoRpO0VANp2iohlM0AZoMDdVwioZqOEVDNZyioRpO0VANZ2i4iy5HQzWcoqEaTtFQDadoAjQZGqrhFA3VcIqGajhFQzWcoqEaztBwF12Ohmo4RUM1nKKhGk7RBGgyNFTDKRqq4RQN1XCKhmo4RUM1nKHhLrocDdVwioZqOEVzo2q4teWJpk/zzx9f5vj6IssyL88Pb/Nr7NPx/LPXdTv5+PTEN8/z3zHapi/qAXU99b21r0/v2/KC+o1qeCPqxzPrx7y/oH4jPfigrN/IPD4o6zeSmg/K+o186XOyfqeLED8n63e6Y/GDsn4jgfygrOOmFVkPqBdkHTetyDpuWpF13LQi67hpRdZx04Ks3+la0s/J+p1uPP2grOOmFVnHTSuyHlAvyDpuWpF13LQi67hpRdZx04qs46YFWb/TJcGfk/U73T/8QVnHTSuyjptWZD2gXpB13LQi67hpRdZx04qs46YVWcdNfz/r852u7P6YrM93ug38g7KOm1ZkHTetyHpAvSDruGlF1nHTiqzjphVZx00rso6bFmR9xk0Lsj7jphVZx00rso6bVmQ9oF6Qddy0Iuu4aUXWcdOKrOOmFVnHTQuyvuCmBVlfcNOKrOOmFVnHTSuyHlAvyDpuWpF13LQi67hpRdZx04qs46YFWV9x04Ksr7hpRdZx04qs46YVWQ+oF2QdN63IOm5akXXctCLruGlF1nHTgqwHblqQ9cBNK7KOm1ZkHTetyHpAvSDruGlF1nHTiqzjphVZx00rso6bFmS94aYFWW+4aUXWcdOKrOOmFVkPqBdkHTetyDpuWpF13LQi67hpRdZx04Ksd9y0IOsdN63IOm5akXXctCLrAfWCrOOmFVnHTSuyjptWZB03rcg6blqQ9Q03Lcj6hptWZB03rcg6blqR9YB6QdZx04qs46YVWcdNK7KOm1ZkHTctyPqOmxZkfcdNK7KOm1ZkHTetyHpAvSDruGlF1nHTiqzjphVZx00rso6bFmT9wE0Lsn7gphVZx00rso6bVmQ9oF6Qddy0Iuu4aUXWcdOKrOOmFVnHTX8/68uEm/5+1pcJN63IOm5akXXctCLrAfWCrOOmFVnHTSuyjptWZB03rcg6blqQ9Rk3Lcj6jJtWZB03rcg6blqR9YB6QdZx04qs46YVWcdNK7KOm1ZkHTctyPqCmxZkfcFNK7KOm1ZkHTetyHpAvSDruGlF1nHTiqzjphVZx00rso6bFmR9xU0Lsr7iphVZx00rso6bVmQ9oF6Qddy0Iuu4aUXWcdOKrOOmFVnHTQuyHrhpQdYDN63IOm5akXXctCLrAfWCrOOmFVnHTSuyjptWZB03rcg6blqQ9YabFmS94aYVWcdNK7KOm1ZkPaBekHXctCLruGlF1nHTiqzjphVZx00Lst5x04Ksd9y0Iuu4aUXWcdOKrAfUC7KOm1ZkHTetyDpuWpF13LQi67hpQdY33LQg6xtuWpF13LQi67hpRdYD6gVZx00rso6bVmQdN63IOm5akXXctCDrO25akPUdN63IOm5akXXctCLrAfWCrOOmFVnHTSuyjptWZB03rcg6blqQ9QM3Lcj6gZtWZB03rcg6blqR9YB6QdZx04qs46YVWcdNK7KOm1ZkHTf9/ayvE276+1lfJ9y0Iuu4aUXWcdOKrAfUC7KOm1ZkHTetyDpuWpF13LQi67hpQdZn3LQg6zNuWpF13LQi67hpRdYD6gVZx00rso6bVmQdN63IOm5akXXctCDrC25akPUFN63IOm5akXXctCLrAfWCrOOmFVnHTSuyjptWZB03rcg6blqQ9RU3Lcj6iptWZB03rcg6blqR9YB6QdZx04qs46YVWcdNK7KOm1ZkHTctyHrgpgVZD9y0Iuu4aUXWcdOKrAfUC7KOm1ZkHTetyDpuWpF13LQi67hpQdYbblqQ9YabVmQdN63IOm5akfWAekHWcdOKrOOmFVnHTSuyjptWZB03Lch6x00Lst5x04qs46YVWcdNK7IeUC/IOm5akXXctCLruGlF1nHTiqzjpgVZ33DTgqxvuGlF1nHTiqzjphVZD6gXZB03rcg6blqRddy0Iuu4aUXWcdOCrO+4aUHWd9y0Iuu4aUXWcdOKrAfUC7KOm1ZkHTetyDpuWpF13LQi67hpQdYP3LQg6wduWpF13LQi67hpRdYD6gVZx00rso6bVmQdN63IOm5akXXc9Pez/mAA9V/Peky4aUXWcdOKrOOmFVkPqBdkHTetyDpuWpF13LQi67hpRdZx04Ksz7hpQdZn3LQi67hpRdZx04qsB9QLso6bVmQdN63IOm5akXXctCLruGlB1hfctCDrC25akXXctCLruGlF1gPqBVnHTSuyjptWZB03rcg6blqRddy0IOsrblqQ9RU3rcg6blqRddy0IusB9YKs46YVWcdNK7KOm1ZkHTetyDpuWpD1wE0Lsh64aUXWcdOKrOOmFVkPqBdkHTetyDpuWpF13LQi67hpRdZx04KsN9y0IOsNN63IOm5akXXctCLrAfWCrOOmFVnHTSuyjptWZB03rcg6blqQ9Y6bFmS946YVWcdNK7KOm1ZkPaBekHXctCLruGlF1nHTiqzjphVZx00Lsr7hpgVZ33DTiqzjphVZx00rsh5QL8g6blqRddy0Iuu4aUXWcdOKrOOmBVnfcdOCrO+4aUXWcdOKrOOmFVkPqBdkHTetyDpuWpF13LQi67hpRdZx04KsH7hpQdYP3LQi67hpRdZx04qsB9QLso6bVmQdN63IOm5akXXctCLruOnvZ71NuOnvZ71NuGlF1nHTiqzjphVZD6gXZB03rcg6blqRddy0Iuu4aUXWcdOCrM+4aUHWZ9y0Iuu4aUXWcdOKrAfUC7KOm1ZkHTetyDpuWpF13LQi67hpQdYX3LQg6wtuWpF13LQi67hpRdYD6gVZx00rso6bVmQdN63IOm5akXXctCDrK25akPUVN63IOm5akXXctCLrAfWCrOOmFVnHTSuyjptWZB03rcg6blqQ9cBNC7IeuGlF1nHTiqzjphVZD6gXZB03rcg6blqRddy0Iuu4aUXWcdOCrDfctCDrDTetyDpuWpF13LQi6wH1gqzjphVZx00rso6bVmQdN63IOm5akPWOmxZkveOmFVnHTSuyjptWZD2gXpB13LQi67hpRdZx04qs46YVWcdNC7K+4aYFWd9w04qs46YVWcdNK7IeUC/IOm5akXXctCLruGlF1nHTiqzjpgVZ33HTgqzvuGlF1nHTiqzjphVZD6gXZB03rcg6blqRddy0Iuu4aUXWcdOCrB+4aUHWD9y0Iuu4aUXWcdOKrAfUC7KOm1ZkHTetyDpuWpF13LQi67jp72e9T7jp72f98eWgXpB13LQi67hpRdYD6gVZx00rso6bVmQdN63IOm5akXXctCDrM25akPUZN63IOm5akXXctCLrAfWCrOOmFVnHTSuyjptWZB03rcg6blqQ9QU3Lcj6gptWZB03rcg6blqR9YB6QdZx04qs46YVWcdNK7KOm1ZkHTctyPqKmxZkfcVNK7KOm1ZkHTetyHpAvSDruGlF1nHTiqzjphVZx00rso6bFmQ9cNOCrAduWpF13LQi67hpRdYD6gVZx00rso6bVmQdN63IOm5akXXctCDrDTctyHrDTSuyjptWZB03rch6QL0g67hpRdZx04qs46YVWcdNK7KOmxZkveOmBVnvuGlF1nHTiqzjphVZD6gXZB03rcg6blqRddy0Iuu4aUXWcdOCrG+4aUHWN9y0Iuu4aUXWcdOKrAfUC7KOm1ZkHTetyDpuWpF13LQi67hpQdZ33LQg6ztu+v8tyDpuWpF13LQi6wH1gqzjphVZx00rso6bVmQdN63IOm5akPUDNy3I+oGbVmQdN63IOm5akfWAekHWcdOKrOOmFVnHTSuyjptWZB03/f2sbxNu+vtZ3ybctCLruGlF1nHTiqwH1AuyjptWZB03rcg6blqRddy0Iuu4aUHWZ9y0IOszblqRddy0Iuu4aUXWA+oFWcdNK7KOm1ZkHTetyDpuWpF13LQg6wtuWpD1BTetyDpuWpF13LQi6wH1gqzjphVZx00rso6bVmQdN63IOm5akPUVNy3I+oqbVmQdN63IOm5akfWAekHWcdOKrOOmFVnHTSuyjptWZB03Lch64KYFWQ/ctCLruGlF1nHTiqwH1AuyjptWZB03rcg6blqRddy0Iuu4aUHWG25akPWGm1ZkHTetyDpuWpH1gHpB1nHTiqzjphVZx00rso6bVmQdNy3IesdNC7LecdOKrOOmFVnHTSuyHlAvyDpuWpF13LQi67hpRdZx04qs46YFWd9w04Ksb7hpRdZx04qs46YVWQ+oF2QdN63IOm5akXXctCLruGlF1nHTgqzvuGlB1nfctCLruGlF1nHTiqwH1AuyjptWZB03rcg6blqRddy0Iuu4aUHWD9y0IOsHblqRddy0Iuu4aUXWA+oFWcdNK7KOm1ZkHTetyDpuWpF13PT3s75PuOnvZ32fcNOKrOOmFVnHTSuyHlAvyDpuWpF13LQi67hpRdZx04qs46YFWZ9x04Ksz7hpRdZx04qs46YVWQ+oF2QdN63IOm5akXXctCLruGlF1nHTgqwvuGlB1hfctCLruGlF1nHTiqwH1AuyjptWZB03rcg6blqRddy0Iuu4aUHWV9y0IOsrblqRddy0Iuu4aUXWA+oFWcdNK7KOm1ZkHTetyDpuWpF13LQg64GbFmQ9cNOKrOOmFVnHTSuyHlAvyDpuWpF13LQi67hpRdZx04qs46YFWW+4aUHWG25akXXctCLruGlF1gPqBVnHTSuyjptWZB03rcg6blqRddy0IOsdNy3IesdNK7KOm1ZkHTetyHpAvSDruGlF1nHTiqzjphVZx00rso6bFmR9w00Lsr7hphVZx00rso6bVmQ9oF6Qddy0Iuu4aUXWcdOKrOOmFVnHTQuyvuOmBVnfcdOKrOOmFVnHTSuyHlAvyDpuWpF13LQi67hpRdZx04qs46YFWT9w04KsH7hpRdZx04qs46YVWQ+oF2QdN63IOm5akXXctCLruGlF1nHT38/6MeGmv5/1Y8JNK7KOm1ZkHTetyHpAvSDruGlF1nHTiqzjphVZx00rso6bFmR9xk0Lsj7jphVZx00rso6bVmQ9oF6Qddy0Iuu4aUXWcdOKrOOmFVnHTQuyvuCmBVlfcNOKrOOmFVnHTSuyHlAvyDpuWpF13LQi67hpRdZx04qs46YFWV9x04Ksr7hpRdZx04qs46YVWQ+oF2QdN63IOm5akXXctCLruGlF1nHTgqwHblqQ9cBNK7KOm1ZkHTetyHpAvSDruGlF1nHTiqzjphVZx00rso6bFmS94aYFWW+4aUXWcdOKrOOmFVkPqBdkHTetyDpuWpF13LQi67hpRdZx04Ksd9y0IOsdN63IOm5akXXctCLrAfWCrOOmFVnHTSuyjptWZB03rcg6blqQ9Q03Lcj6hptWZB03rcg6blqR9YB6QdZx04qs46YVWcdNK7KOm1ZkHTctyPqOmxZkfcdNK7KOm1ZkHTetyHpAvSDruGlF1nHTiqzjphVZx00rso6bFmT9wE0Lsn7gphVZx00rso6bVmQ9oF6Qddy0Iuu4aUXWcdOKrOOmFVnHTX8968c04aa/nvUHddy0Iuu4aUXWcdOKrAfUC7KOm1ZkHTetyDpuWpF13LQi67hpQdZn3LQg6zNuWpF13LQi67hpRdYD6gVZx00rso6bVmQdN63IOm5akXXctCDrC25akPUFN63IOm5akXXctCLrAfWCrOOmFVnHTSuyjptWZB03rcg6blqQ9RU3Lcj6iptWZB03rcg6blqR9YB6QdZx04qs46YVWcdNK7KOm1ZkHTctyHrgpgVZD9y0Iuu4aUXWcdOKrAfUC7KOm1ZkHTetyDpuWpF13LQi67hpQdYbblqQ9YabVmQdN63IOm5akfWAekHWcdOKrOOmFVnHTSuyjptWZB03Lch6x00Lst5x04qs46YVWcdNK7IeUC/IOm5akXXctCLruGlF1nHTiqzjpgVZ33DTgqxvuGlF1nHTiqzjphVZD6gXZB03rcg6blqRddy0Iuu4aUXWcdOCrO+4aUHWd9y0Iuu4aUXWcdOKrAfUC7KOm1ZkHTetyDpuWpF13LQi67hpQdYP3LQg6wduWpF13LQi67hpRdYD6gVZx00rso6bVmQdN63IOm5akXXc9PezPk+46e9nfZ5w04qs46YVWcdNK7IeUC/IOm5akXXctCLruGlF1nHTiqzjpgVZn3HTgqzPuGlF1nHTiqzjphVZD6gXZB03rcg6blqRddy0Iuu4aUXWcdOCrC+4aUHWF9y0Iuu4aUXWcdOKrAfUC7KOm1ZkHTetyDpuWpF13LQi67hpQdZX3LQg6ytuWpF13LQi67hpRdYD6gVZx00rso6bVmQdN63IOm5akXXctCDrgZsWZD1w04qs46YVWcdNK7IeUC/IOm5akXXctCLruGlF1nHTiqzjpgVZb7hpQdYbblqRddy0Iuu4aUXWA+oFWcdNK7KOm1ZkHTetyDpuWpF13LQg6x03Lch6x00rso6bVmQdN63IekC9IOu4aUXWcdOKrOOmFVnHTSuyjpsWZH3DTQuyvuGmFVnHTSuyjptWZD2gXpB13LQi67hpRdZx04qs46YVWcdNC7K+46YFWd9x04qs46YVWcdNK7IeUC/IOm5akXXctCLruGlF1nHTiqzjpgVZP3DTgqwfuGlF1nHTiqzjphVZD6gXZB03rcg6blqRddy0Iuu4aUXWcdPfz/oy4aa/n/Vlwk0rso6bVmQdN63IekC9IOu4aUXWcdOKrOOmFVnHTSuyjpsWZH3GTQuyPuOmFVnHTSuyjptWZD2gXpB13LQi67hpRdZx04qs46YVWcdNC7K+4KYFWV9w04qs46YVWcdNK7IeUC/IOm5akXXctCLruGlF1nHTiqzjpgVZX3HTgqyvuGlF1nHTiqzjphVZD6gXZB03rcg6blqRddy0Iuu4aUXWcdOCrAduWpD1wE0rso6bVmQdN63IekC9IOu4aUXWcdOKrOOmFVnHTSuyjpsWZL3hpgVZb7hpRdZx04qs46YVWQ+oF2QdN63IOm5akXXctCLruGlF1nHTgqx33LQg6x03rcg6blqRddy0IusB9YKs46YVWcdNK7KOm1ZkHTetyDpuWpD1DTctyPqGm1ZkHTetyDpuWpH1gHpB1nHTiqzjphVZx00rso6bVmQdNy3I+o6bFmR9x00rso6bVmQdN63IekC9IOu4aUXWcdOKrOOmFVnHTSuyjpsWZP3ATQuyfuCmFVnHTSuyjptWZD2gXpB13LQi67hpRdZx04qs46YVWcdNfz/r64Sb/n7W1wk3rcg6blqRddy0IusB9YKs46YVWcdNK7KOm1ZkHTetyDpuWpD1GTctyPqMm1ZkHTetyDpuWpH1gHpB1nHTiqzjphVZx00rso6bVmQdNy3I+oKbFmR9wU0rso6bVmQdN63IekC9IOu4aUXWcdOKrOOmFVnHTSuyjpsWZH3FTQuyvuKmFVnHTSuyjptWZD2gXpB13LQi67hpRdZx04qs46YVWcdNC7IeuGlB1gM3rcg6bqqnvszz1/de5vaKOm76P6C+tOP5Zx/rC+oB9QvU+9ye74y+fPuzHx//AxLdFIHEIEUgkUIRSDzvCshtWvevP3ub9vYCJOqmSWTDxkQgESzN1G44kyiRaJAIZABSM7UxG1EiMRsRSMxGNLUxG1EiMRsNyI7ZaKZ2x2xEicRsRCAxG9HUDkBqEonZiEBiNqKpjdmIEonZiEBiNpqpvWE2mkRumI0IJGYjmtqYjSiRAUgNSMxGNLUxG1EiMRsRSMxGNLUxG00id8xGBBKz0UztHbMRJRKzEYEMQGqmNmYjSiRmIwKJ2YimNmYjSiRmowF5YDaaqX1gNqJEYjYikJiNaGoHIDWJxGxEIDEb0dTGbESJxGxEIDEbydR+PBYgFYmMCbMRgcRsRFMbsxElMgCpAYnZiKY2ZiNKJGYjAonZiKY2ZqNJ5IzZiEBiNpqpPWM2okRiNiKQAUjN1MZsRInEbEQgMRvR1MZsRInEbDQgF8xGM7UXzEaUSMxGBBKzEU3tAKQmkZiNCCRmI5ramI0okZiNCCRmo5naK2ajSeSK2YhAYjaiqY3ZiBIZgNSAxGxEUxuzESUSsxGBxGxEUxuz0SQyMBsRSMxGM7UDsxElErMRgQxAaqY2ZiNKJGYjAonZiKY2ZiNKJGajAdkwG83UbpiNKJGYjQgkZiOa2gFITSIxGxFIzEY0tTEbUSIxGxFIzEYztTtmo0lkx2xEIDEb0dTGbESJDEBqQGI2oqmN2VwCuazPRG5Li58/3o9p/vPpfszb88Pz/grfEvGFb+nL9w//GSKcyX6IsDH7IcLz3IdowyDthwg3tR8irNd+iPBp+yEKhsh9iOgB2A8R3QX7IaK7YD9EdBfsh4jugvsQ7XQX7IeI7oL9ENFdsB8iugv2QxQMkfsQ0V2wHyK6C/ZDRHfBfojoLtgPEd0F9yE66C7YDxHdBfshortgP0R0F+yHKBgi9yGiu2A/RHQX7IeI7oL9ENFd0Ox4O+gBSEC2CVOXbB1sEz4tSiTWKwKJm4qmdgBSk0g8TwQSGxNNbZxJlEjMRgQSs9FM7Rmz0SRyxmxEIDEb0dTGbESJDEBqQGI2oqmN2YgSidmIQGI2oqmN2WgSuWA2IpCYjWZqL5iNKJGYjQhkAFIztTEbUSIxGxFIzEY0tTEbUSIxGw3IFbPRTO0VsxElErMRgcRsRFM7AKlJJGYjAonZiKY2ZiNKJGYjAonZaKZ2YDaaRAZmIwKJ2YimNmYjSmQAUgMSsxFNbcxGlEjMRgQSsxFNbcxGk8iG2YhAYjaaqd0wG1EiMRsRyACkZmpjNqJEYjYikJiNaGpjNqJEYjYakB2z0UztjtmIEonZiEBiNqKpHYDUJBKzEYHEbERTG7MRJRKzEYHEbDRTe8NsNIncMBsRSMxGNLUxG1EiA5AakJiNaGpjNqJEYjYikJiNaGpjNppE7piNCCRmo5naO2YjSiRmIwIZgNRMbcxGlEjMRgQSsxFNbcxGlEjMRgPywGw0U/vAbESJxGxEIDEb0dQOQGoSidmIQGI2oqmN2YgSidmIQGI2kqndJ8xGksjH3wdIDUjMRjS1MRtRIgOQGpCYjWhqYzaiRGI2IpCYjWhqYzaaRM6YjQgkZqOZ2jNmI0okZiMCGYDUTG3MRpRIzEYEErMRTW3M5hLIZX0mclta/Pzxfkzzn0/3Y96eH573V/iWiC98S1++f/jPEOFM7kO0YGP2Q4Tn2Q8RBmk/RLip/RAFQ+Q+RPi0/RBh6vZDRA/AfojoLtgPEd0F9yFa6S7YDxHdBfshortgP0R0F+yHKBgi9yGiu2A/RHQX7IeI7oL9ENFdsB8iugvuQxR0F+yHiO6C/RDRXbAfIroL9kMUDJH7ENFdsB8iugv2Q0R3wX6I6C7YDxHdBfchanQXNDveGj0AEUhMXbN1sOHTokQGIDUgcVPR1MYgRYnE80QgsTHR1MaZNInsmI0IJGajmdodsxElErMRgQxAaqY2ZiNKJGYjAonZiKY2ZiNKJGajAblhNpqpvWE2okRiNiKQmI1oagcgNYnEbEQgMRvR1MZsRInEbEQgMRvN1N4xG00id8xGBBKzEU1tzEaUyACkBiRmI5ramI0okZiNCCRmI5ramI0mkQdmIwKJ2Wim9oHZiBKJ2YhABiA1UxuzESUSsxGBxGxEUxuzESUSs5GA3CbMRjK1twmzESUSsxGBxGxEUzsAqUkkZiMCidmIpjZmI0okZiMCidlopvaM2WgSOWM2IpCYjWhqYzaiRAYgNSAxG9HUxmxEicRsRCAxG9HUxmw0iVwwGxFIzEYztRfMRpRIzEYEMgCpmdqYjSiRmI0IJGYjmtqYjSiRmI0G5IrZaKb2itmIEonZiEBiNqKpHYDUJBKzEYHEbERTG7MRJRKzEYHEbDRTOzAbTSIDsxGBxGxEUxuzESUyAKkBidmIpjZmI0okZiMCidmIpjZmo0lkw2xEIDEbzdRumI0okZiNCGQAUjO1MRtRIjEbEUjMRjS1MRtRIjEbDciO2WimdsdsRInEbEQgMRvR1A5AahKJ2YhAYjaiqY3ZiBKJ2YhAYjaaqb1hNpdALuszkdvS4ueP92Oa/3y6H/P2/PC8v8K3RHzhW/ry/cN/hghnsh8ibMx+iPA8+yEKhsh9iHBT+yHCeu2HCJ+2HyJM3X6I6AG4D9FOd8F+iOgu2A8R3QX7IaK7YD9EwRC5DxHdBfshortgP0R0F+yHiO6C/RDRXXAfooPugv0Q0V2wHyK6C/ZDRHfBfoiCIXIfIroL9kNEd8F+iOgu2A8R3QX7IaK7YD5E+0R3wX6I6C7YDxHdBcmOt32iByACGYBUbB3cJ3xalEisVwQSNxVNbQxSlEg8TwNyxsY0U3vGmUSJxGxEIDEb0dQOQGoSidmIQGI2oqmN2YgSidmIQGI2mqm9YDaaRC6YjQgkZiOa2piNKJEBSA1IzEY0tTEbUSIxGxFIzEY0tTEbTSJXzEYEErPRTO0VsxElErMRgQxAaqY2ZiNKJGYjAonZiKY2ZiNKJGajARmYjWZqB2YjSiRmIwKJ2YimdgBSk0jMRgQSsxFNbcxGlEjMRgQSs9FM7YbZaBLZMBsRSMxGNLUxG1EiA5AakJiNaGpjNqJEYjYikJiNaGpjNppEdsxGBBKz0UztjtmIEonZiEAGIDVTG7MRJRKzEYHEbERTG7MRJRKz0YDcMBvN1N4wG1EiMRsRSMxGNLUDkJpEYjYikJiNaGpjNqJEYjYikJiNZmrvmI0mkTtmIwKJ2YimNmYjSmQAUgMSsxFNbcxGlEjMRgQSsxFNbcxGk8gDsxGBxGw0U/vAbESJxGxEIAOQmqmN2YgSidmIQGI2oqmN2YgSidlIQB4TZiOZ2seE2YgSidmIQGI2oqkdgNQkErMRgcRsRFMbsxElErMRgcRsNFN7xmw0iZwxGxFIzEY0tTEbUSIDkBqQmI1oamM2okRiNiKQmI1oamM2mkQumI0IJGajmdoLZnMJ5LI+E7ktLX7+eH/8m+KfT/fHz/nzw/P+Ct8S8YVv6cv3D/8ZIpzJfoiCIXIfIjzPfogwSPshwk3thwjrtR8ifNp9iFZM3X6I6AHYDxHdBfshortgP0TBELkPEd0F+yGiu2A/RHQX7IeI7oL9ENFdcB+ioLtgP0R0F+yHiO6C/RDRXbAfomCI3IeI7oL9ENFdsB8iugv2Q0R3wX6I6C64D1Gju2A/RHQX7IeI7oL9ENFdsB+iYIgkO94aPQARSExds3Ww4dOiRGK9IpC4qWZqdwxSk8iO54lAYmOiqY0ziRIZgNSAxGxEUxuzESUSsxGBxGxEUxuz0SRyw2xEIDEbzdTeMBtRIjEbEcgApGZqYzaiRGI2IpCYjWhqYzaiRGI2GpA7ZqOZ2jtmI0okZiMCidmIpnYAUpNIzEYEErMRTW3MRpRIzEYEErPRTO0Ds9Ek8sBsRCAxG9HUxmxEiQxAakBiNqKpjdmIEonZiEBiNqKpjdkIErlOj/8DpAYkZiOY2v8BidmIEonZiEAGIDVTG7MRJRKzEYHEbERTG7MRJRKz0YCcMRvN1J4xG1EiMRsRSMxGNLUDkJpEYjYikJiNaGpjNqJEYjYikJiNZmovmI0mkQtmIwKJ2YimNmYjSmQAUgMSsxFNbcxGlEjMRgQSsxFNbcxGk8gVsxGBxGw0U3vFbESJxGxEIAOQmqmN2YgSidmIQGI2oqmN2YgSidloQAZmo5nagdmIEonZiEBiNqKpHYDUJBKzEYHEbERTG7MRJRKzEYHEbDRTu2E2mkQ2zEYEErMRTW3MRpTIAKQGJGYjmtqYjSiRmI0IJGYjmtqYjSaRHbMRgcRsNFO7YzaiRGI2IpABSM3UxmxEicRsRCAxG9HUxmxEicRsNCA3zEYztTfMRpRIzEYEErMRTe0A5BWQy/pM5La0+Pnj/ZjmP5/ux7w9Pzzvr/AtEV/4lr58//CfIcKZ7IcIG7MfIjzPfogwSPshwk3dh2jHeu2HCJ+2HyJM3X6I6AHYD1EwRO5DRHfBfojoLtgPEd0F+yGiu2A/RHQX3IfooLtgP0R0F+yHiO6C/RDRXbAfomCI3IeI7oL9ENFdsB8iugv2Q0R3wX6I6C6YD9E80V2wHyK6C/ZDRHfBfojoLtgPUTBE7kNEd8F+iOgu2A8R3QXJpsR5ogcgAompS3Z3zjM+rUnkjPWKQOKmoqmNQYoSGYDUgMTGRFMbZxIlErMRgcRsRFMbs9EkcsFsRCAxG83UXjAbUSIxGxHIAKRmamM2okRiNiKQmI1oamM2okRiNhqQK2ajmdorZiNKJGYjAonZiKZ2AFKTSMxGBBKzEU1tzEaUSMxGBBKz0UztwGw0iQzMRgQSsxFNbcxGlMgApAYkZiOa2piNKJGYjQgkZiOa2piNJpENsxGBxGw0U7thNqJEYjYikAFIzdTGbESJxGxEIDEb0dTGbESJxGw0IDtmo5naHbMRJRKzEYHEbERTOwCpSSRmIwKJ2YimNmYjSiRmIwKJ2Wim9obZaBK5YTYikJiNaGpjNqJEBiA1IDEb0dTGbESJxGxEIDEb0dTGbDSJ3DEbEUjMRjO1d8xGlEjMRgQyAKmZ2piNKJGYjQgkZiOa2piNKJGYjQbkgdlopvaB2YgSidmIQGI2oqkdgNQkErMRgcRsRFMbsxElErMRgcRsJFN7mTAbSSIf/z9AakBiNqKpjdmIEhmA1IDEbERTG7MRJRKzEYHEbERTG7PRJHLGbEQgMRvN1J4xG1EiMRsRyACkZmpjNqJEYjYikJiNaGpjNqJEYjYakAtmo5naC2YjSiRmIwKJ2YimdgBSk0jMRgQSsxFNbczmEshlfSZyW1r8/PF+TPOfT/dj3p4fnvdX+JaIL3xLX75/+M8Q4Uz2Q4SNuQ/RiufZDxEGaT9EuKn9EGG99kMUDJH7EGHq9kNED8B+iOgu2A8R3QX7IaK74D5EQXfBfojoLtgPEd0F+yGiu2A/RMEQuQ8R3QX7IaK7YD9EdBfsh4jugv0Q0V1wH6JGd8F+iOgu2A8R3QX7IaK7YD9EwRC5DxHdBfshortgP0R0F+yHiO6C/RDRXXAfok53QbMpsdMDEIHE1DW7Ozs+LUpkAFIDEjcVTW0MUpRIPE8EEhsTTW2cSZPIDbMRgcRsNFN7w2xEicRsRCADkJqpjdmIEonZiEBiNqKpjdmIEonZaEDumI1mau+YjSiRmI0IJGYjmtoBSE0iMRsRSMxGNLUxG1EiMRsRSMxGM7UPzEaTyAOzEYHEbERTG7MRJTIAqQGJ2YimNmYjSiRmIwKJ2YimNmYjSeQ6YTYikJiNZGo/JjcgNYnEbEQgA5CaqY3ZiBKJ2YhAYjaiqY3ZiBKJ2WhAzpiNZmrPmI0okZiNCCRmI5raAUhNIjEbEUjMRjS1MRtRIjEbEUjMRjO1F8xGk8gFsxGBxGxEUxuzESUyAKkBidmIpjZmI0okZiMCidmIpjZmo0nkitmIQGI2mqm9YjaiRGI2IpABSM3UxmxEicRsRCAxG9HUxmxEicRsNCADs9FM7cBsRInEbEQgMRvR1A5AahKJ2YhAYjaiqY3ZiBKJ2YhAYjaaqd0wG00iG2YjAonZiKY2ZiNKZABSAxKzEU1tzEaUSMxGBBKzEU1tzEaTyI7ZiEBiNpqp3TEbUSIxGxHIAKRmamM2okRiNiKQmI1oamM2okRiNhqQG2ajmdobZiNKJGYjAonZiKZ2AFKTSMxGBBKzEU1tzEaUSMxGBBKz0UztHbO5BHJZn4nclhY/f7wf0/zn0/2Yt+eH5/0VviXiC9/Sl+8f/jNEOJP9EGFj9kOE59kPUTBE7kOEm9oPEdZrP0T4tP0QYer2Q0QPwH2IDroL9kNEd8F+iOgu2A8R3QX7IQqGyH2I6C7YDxHdBfshortgP0R0F+yHiO6C+RA9gDFE7kNEd8F+iOgu2A8R3QX7IQqGyH2I6C7YDxHdBfshortgP0R0F+yHiO6C+xDNdBfsh4jugv0Q0V2wHyK6C5JNiY9nAaQGJKYu2d0ZMz4tSiTWKwKJm4qmNgapSeSC54lAYmOaqb3gTKJEYjYikAFIzdTGbESJxGxEIDEb0dTGbESJxGw0IFfMRjO1V8xGlEjMRgQSsxFN7QCkJpGYjQgkZiOa2piNKJGYjQgkZqOZ2oHZaBIZmI0IJGYjmtqYjSiRAUgNSMxGNLUxG1EiMRsRSMxGNLUxG00iG2YjAonZaKZ2w2xEicRsRCADkJqpjdmIEonZiEBiNqKpjdmIEonZaEB2zEYztTtmI0okZiMCidmIpnYAUpNIzEYEErMRTW3MRpRIzEYEErPRTO0Ns9EkcsNsRCAxG9HUxmxEiQxAakBiNqKpjdmIEonZiEBiNqKpjdloErljNiKQmI1mau+YjSiRmI0IZABSM7UxG1EiMRsRSMxGNLUxG1EiMRsNyAOz0UztA7MRJRKzEYHEbERTOwCpSSRmIwKJ2YimNmYjSiRmIwKJ2UimdpswG0ki24TZiEBiNqKpjdmIEhmA1IDEbERTG7MRJRKzEYHEbERTG7PRJHLGbEQgMRvN1J4xG1EiMRsRyACkZmpjNqJEYjYikJiNaGpjNqJEYjYakAtmo5naC2YjSiRmIwKJ2YimdgBSk0jMRgQSsxFNbcxGlEjMRgQSs9FM7RWz0SRyxWxEIDEb0dTGbC6BXNZnIrelxc8f78c0//l0P+bt+eF5f4VvifjCt/Tl+4f/DFEwRO5DhI3ZDxGeZz9EGKT9EOGm9kOE9boPUeDT9kOEqdsPET0A+yGiu2A/RMEQuQ8R3QX7IaK7YD9EdBfsh4jugv0Q0V1wH6JGd8F+iOgu2A8R3QX7IaK7YD9EwRC5DxHdBfshortgP0R0F+yHiO6C/RDRXXAfok53wX6I6C7YDxHdBfshortgP0TBELkPEd0F+yGiu6DZlNjpAYhAYuqa3Z0dn9YkcsN6RSBxU83U3jBIUSLxPBHIAKRmauNMokRiNiKQmI1oamM2okRiNhqQO2ajmdo7ZiNKJGYjAonZiKZ2AFKTSMxGBBKzEU1tzEaUSMxGBBKz0UztA7PRJPLAbEQgMRvR1MZsRIkMQGpAYjaiqY3ZiBKJ2YhAYjaiqY3ZSBLZJ8xGBBKzkUztPmE2okRiNiKQAUjN1MZsRInEbEQgMRvR1MZsRInEbDQgZ8xGM7VnzEaUSMxGBBKzEU3tAKQmkZiNCCRmI5ramI0okZiNCCRmo5naC2ajSeSC2YhAYjaiqY3ZiBIZgNSAxGxEUxuzESUSsxGBxGxEUxuz0SRyxWxEIDEbzdReMRtRIjEbEcgApGZqYzaiRGI2IpCYjWhqYzaiRGI2GpCB2WimdmA2okRiNiKQmI1oagcgNYnEbEQgMRvR1MZsRInEbEQgMRvN1G6YjSaRDbMRgcRsRFMbsxElMgCpAYnZiKY2ZiNKJGYjAonZiKY2ZqNJZMdsRCAxG83U7piNKJGYjQhkAFIztTEbUSIxGxFIzEY0tTEbUSIxGw3IDbPRTO0NsxElErMRgcRsRFM7AKlJJGYjAonZiKY2ZiNKJGYjAonZaKb2jtloErljNiKQmI1oamM2okQGIDUgMRvR1MZsLoFc1mcit6XFzx/vxzT/+XQ/5u354Xl/hW+J+MK39OX7h/8MEc5kP0TYmP0Q4XnuQ3RgkPZDhJvaDxHWaz9E+LT9EAVD5D5E9ADsh4jugv0Q0V2wHyK6C/ZDRHfBfIi2ie6C/RDRXbAfIroL9kNEd8F+iIIhch8iugv2Q0R3wX6I6C7YDxHdBfshorvgPkQz3QX7IaK7YD9EdBfsh4jugv0QBUPkPkR0F+yHiO6C/RDRXbAfIroL9kNEd0GyKXFb6AGIQGLqkt2d24JPixKJ9YpABiA1UxuDFCUSzxOBxMZEUxtnEiUSs9GAXDEbzdReMRtRIjEbEUjMRjS1A5CaRGI2IpCYjWhqYzaiRGI2IpCYjWZqB2ajSWRgNiKQmI1oamM2okQGIDUgMRvR1MZsRInEbEQgMRvR1MZsNIlsmI0IJGajmdoNsxElErMRgQxAaqY2ZiNKJGYjAonZiKY2ZiNKJGajAdkxG83U7piNKJGYjQgkZiOa2gFITSIxGxFIzEY0tTEbUSIxGxFIzEYztTfMRpPIDbMRgcRsRFMbsxElMgCpAYnZiKY2ZiNKJGYjAonZiKY2ZqNJ5I7ZiEBiNpqpvWM2okRiNiKQAUjN1MZsRInEbEQgMRvR1MZsRInEbDQgD8xGM7UPzEaUSMxGBBKzEU3tAKQmkZiNCCRmI5ramI0okZiNCCRmI5na+4TZSBK5T5iNCCRmI5ramI0okQFIDUjMRjS1MRtRIjEbEUjMRjS1MRtNImfMRgQSs9FM7RmzESUSsxGBDEBqpjZmI0okZiMCidmIpjZmI0okZqMBuWA2mqm9YDaiRGI2IpCYjWhqByA1icRsRCAxG9HUxmxEicRsRCAxG83UXjEbTSJXzEYEErMRTW3MRpTIAKQGJGYjmtqYjSiRmI0IJGYjmtqYzSWQy/pM5La0+Pnj/ZjmP5/ux7w9Pzzvr/AtEV/4lr58//D/G6LAmeyHCBuzHyI8z36IMEj7IQqGyH2IsF77IcKn7YcIU7cfInoA9kNEd8F9iBrdBfshortgP0R0F+yHiO6C/RAFQ+Q+RHQX7IeI7oL9ENFdsB8iugv2Q0R3wX2IOt0F+yGiu2A/RHQX7IeI7oL9EAVD5D5EdBfsh4jugv0Q0V2wHyK6C/ZDRHfBfYg2ugv2Q0R3wX6I6C5oNiVu9ABEIAOQkt2dGz4tSiTWKwKJm4qmNgYpSiSepwG5Y2Oaqb3jTKJEYjYikJiNaGoHIDWJxGxEIDEb0dTGbESJxGxEIDEbzdQ+MBtNIg/MRgQSsxFNbcxGlMgApAYkZiOa2piNKJGYjQgkZiOa2piNJJHHhNmIQGI2kqn9+KqA1CQSsxGBDEBqpjZmI0okZiMCidmIpjZmI0okZqMBOWM2mqk9YzaiRGI2IpCYjWhqByA1icRsRCAxG9HUxmxEicRsRCAxG83UXjAbTSIXzEYEErMRTW3MRpTIAKQGJGYjmtqYjSiRmI0IJGYjmtqYjSaRK2YjAonZaKb2itmIEonZiEAGIDVTG7MRJRKzEYHEbERTG7MRJRKz0YAMzEYztQOzESUSsxGBxGxEUzsAqUkkZiMCidmIpjZmI0okZiMCidlopnbDbDSJbJiNCCRmI5ramI0okQFIDUjMRjS1MRtRIjEbEUjMRjS1MRtNIjtmIwKJ2WimdsdsRInEbEQgA5CaqY3ZiBKJ2YhAYjaiqY3ZiBKJ2WhAbpiNZmpvmI0okZiNCCRmI5raAUhNIjEbEUjMRjS1MRtRIjEbEUjMRjO1d8xGk8gdsxGBxGxEUxuzESUyAKkBidmIpjZmI0okZiMCidmIpjZmo0nkgdmIQGI2mql9YDaXQC7rM5Hb0uLnj/djmv98uh/z9vzwvL/Ct0R84Vv68v3Df4YIZ7IfomCI3IcIz7MfIgzSfohwU/shwnrthwif9h6ieZowdfshogdgP0R0F+yHiO6C/RAFQ+Q+RHQX7IeI7oL9ENFdsB8iugv2Q0R3wX2IZroL9kNEd8F+iOgu2A8R3QX7IQqGyH2I6C7YDxHdBfshortgP0R0F+yHiO6C+xAtdBfsh4jugv0Q0V2wHyK6C/ZDFAyR+xDRXbAfIroLin2jD5D0AEQgMXXFBtwHSHxak8gV6xWBxE01U3vFIEWJxPNEIAOQmqmNM4kSidmIQGI2oqmN2YgSidloQAZmo5nagdmIEonZiEBiNqKpHYDUJBKzEYHEbERTG7MRJRKzEYHEbDRTu2E2mkQ2zEYEErMRTW3MRpTIAKQGJGYjmtqYjSiRmI0IJGYjmtqYjSaRHbMRgcRsNFO7YzaiRGI2IpABSM3UxmxEicRsRCAxG9HUxmxEicRsNCA3zEYztTfMRpRIzEYEErMRTe0ApCaRmI0IJGYjmtqYjSiRmI0IJGajmdo7ZqNJ5I7ZiEBiNqKpjdmIEhmA1IDEbERTG7MRJRKzEYHEbERTG7PRJPLAbEQgMRvN1D4wG1EiMRsRyACkZmpjNqJEYjYikJiNaGpjNqJEYjYSkPOE2Uim9jxhNqJEYjYikJiNaGoHIDWJxGxEIDEb0dTGbESJxGxEIDEbzdSeMRtNImfMRgQSsxFNbcxGlMgApAYkZiOa2piNKJGYjQgkZiOa2piNJpELZiMCidlopvaC2YgSidmIQAYgNVMbsxElErMRgcRsRFMbsxElErPRgFwxG83UXjEbUSIxGxFIzEY0tQOQmkRiNiKQmI1oamM2okRiNiKQmI1magdmo0lkYDYikJiNaGpjNqJEBiA1IDEb0dTGbC6BXNZnIrelxc8f78c0//l0P+bt+eF5f4VvifjCt/Tl+4f/DBHOZD9E2Jj9EOF57kPUMEj7IcJN7YcI67UfInzafoiCIXIfInoA9kNEd8F+iOgu2A8R3QX7IaK74D5Ene6C/RDRXbAfIroL9kNEd8F+iIIhch8iugv2Q0R3wX6I6C7YDxHdBfshorvgPkQb3QX7IaK7YD9EdBfsh4jugv0QBUPkPkR0F+yHiO6C/RDRXbAfIroL9kNEd8F9iHa6C5p9ozs9ABFITF2zAXfHp0WJDEBqQOKmoqmNQYoSieeJQGJjoqmNM2kSeWA2IpCYjWZqH5iNKJGYjQhkAFIztTEbUSIxGxFIzEY0tTEbUSIxGwnIZcJsJFP7AReQmkRiNiKQmI1oagcgNYnEbEQgMRvR1MZsRInEbEQgMRvN1J4xG00iZ8xGBBKzEU1tzEaUyACkBiRmI5ramI0okZiNCCRmI5ramI0mkQtmIwKJ2Wim9oLZiBKJ2YhABiA1UxuzESUSsxGBxGxEUxuzESUSs9GAXDEbzdReMRtRIjEbEUjMRjS1A5CaRGI2IpCYjWhqYzaiRGI2IpCYjWZqB2ajSWRgNiKQmI1oamM2okQGIDUgMRvR1MZsRInEbEQgMRvR1MZsNIlsmI0IJGajmdoNsxElErMRgQxAaqY2ZiNKJGYjAonZiKY2ZiNKJGajAdkxG83U7piNKJGYjQgkZiOa2gFITSIxGxFIzEY0tTEbUSIxGxFIzEYztTfMRpPIDbMRgcRsRFMbsxElMgCpAYnZiKY2ZiNKJGYjAonZiKY2ZqNJ5I7ZiEBiNpqpvWM2okRiNiKQAUjN1MZsRInEbEQgMRvR1MZsRInEbDQgD8xGM7UPzEaUSMxGBBKzEU3tAKQmkZiNCCRmI5ramI0okZiNCCRmI5na64TZXAK5rM9EbkuLnz/ej2n+8+l+zNvzw/P+Ct8S8YVv6cv3D/8ZIpzJfoiwMfshwvPshygYIvchwk3thwjrtR8ifNp+iDB1+yGiB+A+RDPdBfshortgP0R0F+yHiO6C/RAFQ+Q+RHQX7IeI7oL9ENFdsB8iugv2Q0R3wX2IFroL9kNEd8F+iOgu2A8R3QX7IQqGyH2I6C7YDxHdBfshortgP0R0F+yHiO6C+xCtdBfsh4jugv0Q0V2wHyK6C/ZDFAyRYt/outIDEIHE1DUbcFd8WpRIrFcEEjfVTO3AIDWJDDxPBBIbE01tnEmUyACkBiRmI5ramI0okZiNCCRmI5ramI0mkQ2zEYHEbDRTu2E2okRiNiKQAUjN1MZsRInEbEQgMRvR1MZsRInEbDQgO2ajmdodsxElErMRgcRsRFM7AKlJJGYjAonZiKY2ZiNKJGYjAonZaKb2htloErlhNiKQmI1oamM2okQGIDUgMRvR1MZsRInEbEQgMRvR1MZsNIncMRsRSMxGM7V3zEaUSMxGBDIAqZnamI0okZiNCCRmI5ramI0okZiNBuSB2Wim9oHZiBKJ2YhAYjaiqR2A1CQSsxGBxGxEUxuzESUSsxGBxGwkU/vxWIBUJDImzEYEErMRTW3MRpTIAKQGJGYjmtqYjSiRmI0IJGYjmtqYjSaRM2YjAonZaKb2jNmIEonZiEAGIDVTG7MRJRKzEYHEbERTG7MRJRKz0YBcMBvN1F4wG1EiMRsRSMxGNLUDkJpEYjYikJiNaGpjNqJEYjYikJiNZmqvmI0mkStmIwKJ2YimNmYjSmQAUgMSsxFNbcxGlEjMRgQSsxFNbcxGk8jAbEQgMRvN1A7MRpRIzEYEMgCpmdqYjSiRmI0IJGYjmtqYjSiRmI0GZMNsNFO7YTaiRGI2IpCYjWhqByCvgFzWZyK3pcXPH+/HNP/5dD/m7fnheX+Fb4n4wrf05fuH/wwRzmQ/RNiY/RDhefZDhEHaDxFu6j5EHeu1HyJ82n6IMHX7IaIHYD9EwRC5DxHdBfshortgP0R0F+yHiO6C/RDRXXAfoo3ugv0Q0V2wHyK6C/ZDRHfBfoiCIXIfIroL9kNEd8F+iOgu2A8R3QX7IaK74D5EO90F+yGiu2A/RHQX7IeI7oL9EAVD5D5EdBfsh4jugv0Q0V3QbErc6QGIQGLqmt2dBz6tSeSB9YpA4qaiqY1BihIZgNSAxMZEUxtnEiUSsxGBxGxEUxuzkSSyTZiNCCRmI5nabcJsRInEbEQgA5CaqY3ZiBKJ2YhAYjaiqY3ZiBKJ2WhAzpiNZmrPmI0okZiNCCRmI5raAUhNIjEbEUjMRjS1MRtRIjEbEUjMRjO1F8xGk8gFsxGBxGxEUxuzESUyAKkBidmIpjZmI0okZiMCidmIpjZmo0nkitmIQGI2mqm9YjaiRGI2IpABSM3UxmxEicRsRCAxG9HUxmxEicRsNCADs9FM7cBsRInEbEQgMRvR1A5AahKJ2YhAYjaiqY3ZiBKJ2YhAYjaaqd0wG00iG2YjAonZiKY2ZiNKZABSAxKzEU1tzEaUSMxGBBKzEU1tzEaTyI7ZiEBiNpqp3TEbUSIxGxHIAKRmamM2okRiNiKQmI1oamM2okRiNhqQG2ajmdobZiNKJGYjAonZiKZ2AFKTSMxGBBKzEU1tzEaUSMxGBBKz0UztHbPRJHLHbEQgMRvR1MZsRIkMQGpAYjaiqY3ZiBKJ2YhAYjaiqY3ZaBJ5YDYikJiNZmofmI0okZiNCGQAUjO1MRtRIjEbEUjMRjS1MRtRIjEbCcg+YTaSqf34+wCpSSRmIwKJ2YimdgBSk0jMRgQSsxFNbczmEshlfSZyW1r8/PF+TPOfT/dj3p4fnvdX+JaIL3xLX75/+M8Q4Uz2Q4SNuQ/RjOfZDxEGaT9EuKn9EGG99kMUDJH7EGHq9kNED8B+iOgu2A8R3QX7IaK74D5EC90F+yGiu2A/RHQX7IeI7oL9EAVD5D5EdBfsh4jugv0Q0V2wHyK6C/ZDRHfBfYhWugv2Q0R3wX6I6C7YDxHdBfshCobIfYjoLtgPEd0F+yGiu2A/RHQX7IeI7oL7EAXdhStDdGzHc4iOPebvH/8Dkh6ACCSmfgHkMrXnMy5Tn7YXIPFpUSIDkBqQuKloamOQokTieSKQ2JhoauNMmkQ2zEYEErPRTO2G2YgSidmIQAYgNVMbsxElErMRgcRsRFMbsxElErPRgOyYjWZqd8xGlEjMRgQSsxFN7QCkJpGYjQgkZiOa2piNKJGYjQgkZqOZ2htmo0nkhtmIQGI2oqmN2YgSGYDUgMRsRFMbsxElErMRgcRsRFMbs9EkcsdsRCAxG83U3jEbUSIxGxHIAKRmamM2okRiNiKQmI1oamM2okRiNhqQB2ajmdoHZiNKJGYjAonZiKZ2AFKTSMxGBBKzEU1tzEaUSMxGBBKzkUztbcJsJIncJsxGBBKzEU1tzEaUyACkBiRmI5ramI0okZiNCCRmI5ramI0mkTNmIwKJ2Wim9ozZiBKJ2YhABiA1UxuzESUSsxGBxGxEUxuzESUSs9GAXDAbzdReMBtRIjEbEUjMRjS1A5CaRGI2IpCYjWhqYzaiRGI2IpCYjWZqr5iNJpErZiMCidmIpjZmI0pkAFIDErMRTW3MRpRIzEYEErMRTW3MRpPIwGxEIDEbzdQOzEaUSMxGBDIAqZnamI0okZiNCCRmI5ramI0okZiNBmTDbDRTu2E2okRiNiKQmI1oagcgNYnEbEQgMRvR1MZsRInEbEQgMRvN1O6YzSWQ2/IX5KPU+fnjbVv/fLgdf3nM+xdzJOj3meNLl5gfczyZH+v888f7Mc1/Pt2PeftO/QW+Jb7+6H3py4shwsTshygYIvchwh7thwgvtR8ijNd+iHBp+yHC0t2HaMP/7YeIdoH9ENFdsB8iugv2QxQMkfsQ0V2wHyK6C/ZDRHfBfojoLtgPEd0F9yHa6S7YDxHdBfshortgP0R0F+yHKBgi9yGiu2A/RHQX7IeI7oL9ENFdsB8iugvuQ3TQXbAfIroL9kNEd8F+iOgu2A9RMETuQ0R34coQzdH616fn2P7r439A0gMQgcTUL4Js30BuL0Di0yKQWK8E5D7hpiKQGOQlkG16FlZza8fPH5/71p8nbPRtn/5+lS/sWGEJdkyvBHuAvQL7jYxsf/6Qzcvj8ycfn9anGzz+99b/2mq8JL9M69Mllum73cbzh/JGVlYP80ZmVg/zRnZWD/NGhlYOc76RpdXDvJGp1cO8kX/Vw7yRVdXDDGDqYGJAQpgYkBAmBiSEiQEJYWJAOpiLtQFtx9eHj/3sw/M8PbuT8zz3ePW01ooif1prh/hnT7tMz4kyL9/WDX17WusiX/60cdOnbS+f1rpMlj+tdR0rf1rrQlP+tNaV4D972tam59O2vr56WutSTf20641qqQtPe6Na6sLT3qiWuvC0N6qlLjxt3Odp+/40xLl/vwjl79PeqJa68LQ3qqUuPO2NaqkLT3ujWurC096oljp/2rhRLbV/s4JHU+bV096olrrwtPeppf6zDPLZwF2W/za+F58/lmfT7vjWHZ5j+WJzn8pLzyZGZfOfvZJ/Pr48Ggv/xeb/fvrnq/D2uE8BWIrxPpXlEsvz93iJ/vL3+D6V5ZWnvU9l+Xjav1Mktvbqae9TWV542nafyvLK096nsrzytDeqLC887Y1qxQtPG0M97X2KtLb059O2ZX/1e9vuU0tdedr71FJXnvY+tVRb1/35tDG/+reEdp9a6sLT9vvUUi3a8fdpj/VEJaVHE+39PlVaLcf71H+1HO9TWdZyDDhKON6oGi7leKM6u5TjjSr4Uo43coNSjjeyjkqO3rehfxBHfEbDEZ/RcMRnNBwDjhKO+IyGIz6j4YjPaDjiMxqO+IyEo/f9yx/EEZ/RcMRnNBzxGQ3HgKOEIz6j4YjPaDjiMxqO+IyGIz4j4eh94+sHccRnNBzxGQ3HG/lM+7Zqtm3T73IMOEo43shnSjneyGdKOd7IZ0o53shnSjneyGcKOR7et4R+EMcb+Uwpxxv5TClHfEbDMeAo4YjPaDjiMxqO+IyGIz6j4YjPSDh636f5QRzxGQ1HfEbDEZ/RcAw4SjjiMxqO+IyGIz6j4YjPaDjiMxKON7ods5YjPqPhiM9oOOIzGo4BRwlHfEbD8T4+0x9P88WxL3F21/fp7SnHje5Z1bO5j3f8QzbKK1GOG133WonxRvfI9t6fuwp635cTjFtbv6hvLV7cHXbc6NZZPZv72IGezX0qfj2bgE3K5j6VuZ7NjaptOZsbVdtyNjeqtuVsblRC/1M2yzc2L24bOW50J7CezcB18SmbgeviUzYD18WnbAI2KZuB6+JTNgPXxadsBq6LT9kMXBefsqEuTtnc6EZjPZsb1cXqf/W60W3JejY3qosL/ynrRpc2l2KkC512zG50d7SeDV3onA1d6JzNwNX2GZsb3XmtZ8PqjJwNqzNyNqzOyNkEdp/Z/Y3uhZYb7I3uetazGXYttFRLb3R9cylGqu301+9GNzLr2VBt52yotnM2VNs5m4BNyoYudM6GLnTOhi50zoY1H6nd3+gWYLnB3uhmXz2bYdd8SLX0Rpf1lmKk2k5//W50/66eDdV2zoZqO2dDtZ2zYc1HzoYudMrmRvfO6tnQhc7ZsPMwtfsb3fkqN9gb3eOqZzPsmg+plt7oatZSjFTb+a8f1XbOhmo7YbNMN7oVVc+Gajtnw5qPnA1d6JxNwCZlQxc6Z8M5H4ndP9hw2nRisA82wy6bvsCGI6T/vZYu040u4izFSLWd/vrd6G5NPRuq7ZxNwCZlQ7Wds2HNR86GLnTOhi50zoYudMrmRnc/yu3+Rvc5yg32Rnc06tlwqp5CS2907WIpRqrt/NePajtnQ7Wds6HaztlQbadsuPPwBzZ0oXM2dKFzNnShczaB3Wd2f6c7D9UGe6c7D+VsOFVPoaV3uh6xEiPVdvrrN/JNiqdsqLZzNlTbORuq7ZxNwCZlQxc6Z0MXOmdDFzpnw6l6qd3f6SZFtcHe6SZFORtO1VNo6biXLmoxUm2nv353unRRzoZqO2dDtZ2zodrO2bDmI2dDFzplw02KP7ChC52z4VS91O7vdJOi2mDvdJOinA2n6im0dNxLF7UYqbbzXz+q7ZwN1XbKhpsUf2BDtZ2zYc1HzoYudM4mYJOyoQuds+FUvdTu73STotpg73STopwNp+optHTcSxe1GKm201+/O126KGdDtZ2zCdikbKi2czas+cjZ0IXO2dCFztnQhU7ZjHyT4pnd3+kmRbXB3ukmRTkbTtVTaOm4ly5qMVJt579+VNs5G6rtnA3Vds6GajtjM3OT4g9s6ELnbOhC52zoQudsArtP7H6+002KYoOd73STopwNp+oJtHQe99JFLUaq7fTX706XLsrZUG3nbKi2czZU2zmbgE3Khi50zoYudM6GLnTOhlP1Uru/002KaoO9002KcjacqqfQ0nEvXdRipNpOf/3udOminA3Vds6GajtnQ7Wds2HNR86GLnTKhpsUf2BDFzpnw6l6qd3f6SZFtcHe6SZFORtO1VNo6biXLmoxUm3nv35U2zkbqu2UDTcp/sCGajtnw5qPnA1d6JxNwCZlQxc6Z8Opeqnd3+kmRbXB3ukmRTkbTtVTaOm4ly5qMVJtp79+d7p0Uc6GajtnE7BJ2VBt52xY85GzoQuds6ELnbOhC52yGfkmxTO7v9NNimqDvdNNinI2nKqn0NJxL13UYqTazn/9qLZzNlTbORuq7ZwN1XbKhpsUf2BDFzpnQxc6Z0MXOmcT2H1m93e6SVFtsHe6SVHOhlP1FFo67qWLWoxU2+mv350uXZSzodrO2VBt52yotnM2AZuUDV3onA1d6JwNXeicDafqpXZ/p5sU1QZ7p5sU5Ww4VU+hpeNeuqjFSLWd/vrd6dJFORuq7ZwN1XbOhmo7Z8Oaj5wNXeiMzcJNij+woQuds+FUvczulzvdpCg22GUK2KRsOFVPoKXLuJcuajFSbee/flTbORuq7ZQNNyn+wIZqO2fDmo+cDV3onE3AJmVDFzpnw6l6qd3f6SZFtcHe6SZFORtO1VNo6biXLmoxUm2nv353unRRzoZqO2cTsEnZUG3nbFjzkbOhC52zoQuds6ELnbIZ+SbFM7u/002KaoO9002KcjacqqfQ0nEvXdRipNrOf/2otnM2VNs5G6rtnA3VdsqGmxR/YEMXOmdDFzpnQxc6ZxPYfWb3d7pJUW2wd7pJUc6GU/UUWjrupYtajFTb6a/fnS5dlLOh2s7ZUG3nbKi2czYBm5QNXeicDV3onA1d6JwNp+qldn+nmxTVBnunmxTlbDhVT6Gl4166qMVItZ3++t3p0kU5G6rtnA3Vds6Gajtnw5qPnA1d6JQNNyn+wIYudM6GU/VSu7/TTYpqg73TTYpyNpyqp9DScS9d1GKk2s5//ai2czZU2ykbblL8gQ3Vds6GNR85G7rQOZuATcqGLnTOhlP1Uru/002KaoO9002KcjacqqfQ0nEvXdRipNpOf/3udOminA3Vds4mYJOyodrO2bDmI2dDFzpnQxc6Z0MXOmOzjnyT4ondr3e6SVFssOudblKUs+FUPYGWrlOAUYGRajv/9aPaztlQbedsqLZzNlTbKRtuUvyBDV3onA1d6JwNXeicTWD3md3f6SZFtcHe6SZFORtO1VNo6biXLmoxUm2nv353unRRzoZqO2dDtZ2zodrO2QRsUjZ0oXM2dKFzNnShczacqpfa/Z1uUlQb7J1uUpSz4VQ9hZaOe+miFiPVdvrrd6dLF+VsqLZzNlTbORuq7ZwNaz5yNnShUzbcpPgDG7rQORtO1Uvt/k43KaoN9k43KcrZcKqeQkvHvXRRi5FqO//1o9rO2VBtp2y4SfEHNlTbORvWfORs6ELnbAI2KRu60DkbTtVL7f5ONymqDfZONynK2XCqnkJLx710UYuRajv99bvTpYtyNlTbOZuATcqGajtnw5qPnA1d6JwNXeicDV3olM3INyme2f2NblLclqN/sdnWdf/XBnujmxT1bO5TF/9DNsv0nFPL1OIVm4BNyuY+dbGezX3q4n/MRtjqudH1iKUY71Nt70s8f872Zeuv6qD71M/7Oj9Ds6/L8a/r5xvdjahnc5/6Wc/mPvWzns196mc9m4BNyuY+9bOezX3qZz2b+xTFejY3qnT/KZuz/uCN7kbc29/e6d6n48XT3ugKw32P9fm0e3+V+xvdNLgff0X5mKaXT0s3N+3m3ujuQD2boJ0kaCfd6JrBUozUuGkdd6MbCfVsBq5xT9nQ+83YxI1uJNSzofebs6H3m7Oh95uzCdikbAbu/Z70qeJGdwee96niRrcBnvep4kb3+533qeJGN/apezFxoxv79GyGXcmrbLDEjS73K8VIjZvWcTe6B1DPhvUNORt6vzkber85G3q/ORt6vymbG93Yp2dD7zdnM3Dv96xPdaMb+y70qW50B9+FPtWNbtW70Ke60T158l7Mje7J07O5TzVa2WC50ZV6lRhvdPuevI670e17ejasb8jZ0PvN2QRsUjb0fnM29H5zNvR+czb0fnM2A/d+z/pUN7on70Kf6kY3313oU93oLrsLfaob3U4n78Xc6HY6PRs2rCkaLDe6na4UIzVuWsfd6HY6PRvWN6RsbnQ7nZ4Nvd+cDb3fnA2935xNwCZlQ+83ZzNw7/esT3Wj2+ku9KludN/chT7VjW6Qu9CnutFFb/JezI1ub9OzYcOaosFyo4veSjEGdVxWx93oTjg9G9Y35Gzo/eZs6P3mbOj9pmxudCecng2935wNvd+czcC937M+1Y3uhLvQp7rRLW8X+lQ3urftQp9q3OvVznsxN7ozTc+GDWuKBsuNLmMrxUiNm9Zx3Nv2AxvWN+RsAjYpG3q/ORt6vzkber85G3q/ORt6vymbO93ypu5T3elOuPM+1Y3uhLvQp7rRLW8X+lTj3tt23osZ9zK2C2zYsKZosNzoMrZSjNS4eR1HjZuxadzb9gMber85G3q/ORt6vzmbgE3Kht5vzobeb85m4N7vSZ+q3elOuNM+VbvRnXDnfap2o1vezvtUbdx72057MW3cy9gusGHDmqDB0m50GVspRmrctI7j3rYf2LC+IWdD7zdnQ+83ZcO9bT+wofebs6H3m7Oh95uzCfpUWZ/qTnfCnfepbnQn3IU+1Y1uebvQpxr33rbzXsy4l7Gds7nRDWuVDZYbXcZWipEaN63juLftBzYBm5QNvd+cDb3fnA2935wNvd+cDb3flM2d7m2Tsxm493vWp7rTnXDnfaob3Ql3oU91o1veLvSpxr237bwXM+5lbBfYsGFN0WC50WVspRipcdM6jnvbfmDD+oacDb3fnA2935xNwCZlQ+83Z0PvN2dD7zdnM3Dv96xPdac74c77VDe6E+5Cn+pGt7xd6FONe2/beS9m3MvYLrAJGiyCBsuNLmMrxUiNm9Zx3Nv2AxvWN+Rs6P2mbLi37Qc29H5zNvR+czb0fnM2AZuUzcC937M+1Z3uhDvvU93oTrgLfaob3fJ2oU817r1t572YcS9ju8CGDWuKBsuNLmMrxUiNm9Zx3Nv2AxvWN+Rs6P3mbOj95mzo/eZs6P2mbEa+t+2UDb3fnM3Avd+zPtWd7oQ771Pd6E64C32qG93ydqFPNe69bee9mHEvY7vAhg1rigbLjS5jK8TYubctreM697b9wIb1DTkber85m4BNyobeb86G3m/Oht5vzobeb85m4N7vSZ+q3+lOuNM+Vb/RnXDnfap+o1vezvtUfdx72057MX3cy9gusGHDmqLBcqPL2EoxUuOmdRz3tv3AhvUNKRvubfuBDb3fnA2935wNvd+cTcAmZUPvN2czcO/3rE91pzvhzvtUN7oT7kKf6ka3vF3oU417b9t5L2bcy9gusGHDmqLBcqPL2EoxBnVcVsdxb9sPbFjfkLOh95uzofebs6H3m7Lh3rYf2ND7zdnQ+83ZDNz7PetT3elOuPM+1Y3uhLvQp7rRLW8X+lTj3tt23osZ9zK2C2zYsKZosNzoMrZSjNS4aR3HvW0/sGF9Q84mYJOyofebs6H3m7Oh95uzofebs6H3m7K50y1v6j7Vne6EO+9T3ehOuAt9qhvd8nahTzXuvW3nvZhxL2O7wIYNa4oGy40uYyvFSI2b13HUuCkb7m37gQ2935wNvd+cDb3fnE3AJmVD7zdnQ+83ZzNw7/esT3WnO+HO+1Q3uhPuQp/qRre8XehTjXtv23kvZtzL2C6wYcOaosFyo8vYSjFS46Z1HPe2/cCG9Q05G3q/ORt6vykb7m37gQ2935wNvd+cDb3fnE3Qp8r6VHe6E+68T3WjO+Eu9KludMvbhT7VuPe2nfdixr2M7ZTNdqMb1gobLNuNLmMrxUiNm9VxG/e2/cAmYJOyofebs6H3m7Oh95uzofebs6H3m7K5071tcjYD935P+lTbne6EO+1TbTe6E+68T7Xd6Ja38z7VNu69bee9mHEvY7vAhg1rigbLjS5jK8VIjZvWcdzb9gMb1jfkbOj95mzo/eZsAjYpG3q/ORt6vzkber85m4F7v2d9qjvdCXfep7rRnXAX+lQ3uuXtQp9q3Hvbznsx417GdoFN0GARNFhudBlbKUZq3LSO4962H9iwviFnQ+83ZcO9bT+wofebs6H3m7Oh95uzCdikbAbu/Z71qe50J9x5n+pGd8Jd6FPd6Ja3C32qce9tO+/FjHsZ2wU2bFhTNFhudBlbKUZq3LSO4962H9iwviFnQ+83Z0PvN2dD7zdnQ+83ZTPyvW2nbOj95mwG7v2e9anudCfceZ/qRnfCXehT3eiWtwt9qnHvbTvvxYx7GdsFNmxYUzRYbnQZWyVG7m3L6zjubfuBDesbcjb0fnM2AZuUDb3fnA2935wNvd+cDb3fnM3Avd+zPtWd7oQ771Pd6E64C32qG93ydqFPNe69bee9mHEvY7vAhg1rigbLjS5jK8VIjZvWcdzb9gMb1jekbLi37Qc29H5zNvR+czb0fnM2AZuUDb3fnM3Avd+zPtWd7oQ771Pd6E64C32qG93ydt6n2se9t+20F7OPexnbBTZsWBM0WPYbXcZWijGo45I6bufeth/YsL4hZ0PvN2dD7zdnQ+83ZcO9bT+wofebs6H3m7MZuPd70qfa73Qn3Gmfar/RnXDnfar9Rre8XehTjXtv23kvZtzL2C6wYcOaosFyo8vYSjFS46Z1HPe2/cCG9Q05m4BNyobeb86G3m/Oht5vzobeb86G3m/K5k63vKn7VHe6E+68T3WjO+Eu9KludMvbhT7VuPe2nfdixr2M7QIbNqwpGiw3uoytFCM1bl7HUeOmbLi37Qc29H5zNvR+czb0fnM2AZuUDb3fnA2935zNwL3fsz7Vne6EO+9T3ehOuAt9qhvd8nahTzXuvW3nvZhxL2O7wIYNa4oGy40uYyvFSI2b1nHc2/YDG9Y35Gzo/eZs6P2mbLi37Qc29H5zNvR+czb0fnM2QZ8q61Pd6U648z7Vje6Eu9CnutEtbxf6VOPe23beixn3MrZzNje6Ya2ywXKjy9hKMVLjpnUc97b9wCZgk7Kh95uzofebs6H3m7Oh95uzofebsrnTvW1yNgP3fs/6VHe6E+68T3WjO+Eu9KludMvbhT7VuPe2nfdixr2M7QIbNqwpGiw3uoytFCM1blrHcW/bD2xY35Czofebs6H3m7MJ2KRs6P3mbOj95mzo/eZsBu79nvWp7nQn3Gmf6rjRnXDnfarjRre8nfepjhvd23b0vj+fdpvaq6e9T315bHP7+7RtevW0cZ+nPda/ST72l0m+TQ24TNPzj37873j5tNZV3dG+flMegzV9//Cfb29dd51+e+vK6L++fbz49ta1y9m3t74xa56m9et7PP53X198f+fq4sr3d64X/v+///Hi+ztXAPO0zM9/H5qW5dX3d/5Nv/L9nX+lH9/5eMrQtK4v3v3Wtyxd+f7Ov7zz9Cjtnt//OLYX39/5t/fK93f+9b3w/a0v/rny/a1/fx8T+Pn+nKf+Yv5a34pz5ftb//7+9/f/ppl/v7/37+95/r1/f8+/v/fv7/n3//DfX+vbTh5zdt3/zt/2ov60vpHkwve3vjXkwvvf+maPK9//g35/X/1+Wd++ceH9Y32fxpXv/+G/v9b3Ulz5/ta/vxfe/x/++2t9W8KF97/1jQZXvv8H/f6++v2yvhngwvvH+vT+K9//w39/rU/Bv/L9rX9/z9//1qfJX/n+5r+/p+//D//9tT6V/cLvl/U56xfeP9ZnoV/5/h/++2t9UPiV72/9+3v+/rc+RfvK9zf//T19/3/476/1idEXfr+sT3We5yWe75952V6sH7M+efnxnY+/33+dX31/7/7z+ff3/vff8+9v/fv7+M7H3+8fr+av9+/v+ff3/v09//7ev7/LMX/7/i/Wf/76+bstnt+/vfxBOsy+0K+fNHv6hWa3L7S4faHV7QuF2xdqbl+ou32h336xt+X4+4VevKk3tzf15vam3t3e1L9+NOBZhn79PL4+f/Uvtt7azx9epunrw8s0//0a7VVls0zP/YPLfHz77J8HXUd50BjlQdsoD9pHedBtlAfdR3nQY5AH/fWz4soedDZ+0P+cHPB80GX/v19+lGrnGKXa+fUz08oe1LnaOZ13o1QwxygVzDFKBXM4VzA/z7t1+vVzvfrztOGtH/P/f7vh8YVmty+0uH0hwS/3snz9G8++xKu/I37h72i/8Hf0X/g7Xr/Rj+c/A8axHj//HS2Wry/U4r//jhdfaJufadr+778vPr7Q7vaFDrMvlJwgVPiFZrcvtLh9odXtC4XbF2puX6i7fSG3N/Xs9qae3d7Ui9ubenF7Uy9ub+rF7U29uL2pF7c39eL2pl7c3tSL25t6cXtTr25v6tXtTb26valXtzf16vamXt3e1Kvbm3p1e1Ovbm/q1e1NHW5v6nB7U4fbmzrc3tTh9qYOtzd1uL2pw+1NHW5v6nB7Uze3N3Vze1M3tzd1c3tTN7c3dXN7Uze3N3Vze1M3tzd1c3tTd7c3dXd7U3e3N3V3e1N3tzd1d3tTd7c3dXd7U3e3N3V3e1Nvbm/qze1Nvbm9qTe3N/Xm9qbe3N7Um9ubenN7U29ub+rN7U29u72pd7c39e72pt7d3tS725t6d3tT725v6t3tTb27val3tzf14famPtze1Ifbm/pwe1Mfbm/qw+1Nfbi9qQ+3N/Xh9qY+zN7U82T2pp4nszf1PJm9qefJ7E09T2Zv6nkye1PPk9mbenbbozi77VGc3fYozm57FGe3PYqz2x7F2W2P4uy2R3F226M4u+1RnN32KM5uexRntz2Ks9sexdltj+LstkdxdtujOLvtUZzd9ijObnsUZ7c9irPbHsXZbY/i7LZHcXbbozi77VGc3fYozm57FGe3PYqz2x7F2W2P4vzbexSP7fj6Qsd+4Qaw6e8NYHP/+/H58ff8eYDjwx/gt/dA/sMHWKb2fIBlnV89wPzpD7B8zgO0lw+wfvoDxKc/QPv0B+jWD9Da9HyA1tdXD7B9+gN4/xJfeADvX+LzB2jev8QXHsD7l/jCA3j/Evf9efzy3I/j1QN4/xJfeADvX+ILD+D9S3zhAbx/iS88gPcv8YUH8P4l3r8Vc/uyvHoA71/i8wfo1r/Ey+Ml8/UAy7L8dzn94vPH32vMj9i/fXr5elzr323941r/yv/Dx12m4+uQ/OXhVv/1uC++9/NE/fb91bN/kbEuH0rJhDWZWP5ezBH91Y9Kt65LrjyAdV3yeIC/2YytvXoA67rkygNY1yVXHsC6LrnwAJt3XXLhAbwrjQsP4F07XHgA65/4tvTnA7Rlf/U78NsnDvzDB1jX/fkAMb9qMm3Wv8RXHsD6l7hFO/4+wLGeVIn9mL4uNerHvH2v/F78c/YSX26xL335v2XiZv0bX4vGunqoRWNdl5Si2a0rnlo01rVULRrrKq0WjXf9V4omQJOh8a5ZS9FQDadoqIZTNFTDKRqq4QzNQTWcoqEaTtFQDadoqIZTNAGaDA3VcIqGajhFQzWcoqEaTtFQDSdololqOEVDNZyioRpO0VANp2gCNBkaquEUDdVwioZqOEVDNZyi8a6G27e1U22bfhXN7F0Nl6LxroZL0XhXw6VovKvhUjQBmgyNdzVcisa7Gi5F410Nl6LxroZL0VANZ2gWquEUDdVwioZqOEVDNZyiCdBkaKiGUzRUwykaquEUDdVwioZqOEOzUg2naKiGUzRUwykaquEUTYAmQ0M1nKKhGk7RUA2naKiGUzRUwxka7xsvatFQDadorKvhPh/LF5q+RD9Bc3pI6uJ9p4f+ceNGj6s8+XTxvlqklIx1zdp7f67T7H1fTshsbf0CubV4cSj24n3Dif5xrWtL/eNa14vyx/W+a0X/uNZ1nf5xvWs1+eN612ryx42xHte7APunj7t8e9z11ePeq6o6fVzvqkrtWd532+gf17uqKpQn7yt2SsmMVat538ajf9yxajXve3P0j3uvWu30ccfqgHnf4KN/3LE6YN63A8kf1/suIblned88JBcP73uK9I97p3+tlNqE93VJpWTGqtW8b23SP+5YtZr37Ur6xx2rVvO+BUn/uGN1wLxvK9I/7lgdMO9bheSe5X1TkFw8vG//0T/unf61UmoT3hf6lJIZq1bzvqNH/7hj1Wred+noH3esWs37zhv9447VAfO+m0b/uGN1wLzvkJF7lve9MGrxWL3vetE/7p3+tVJpE6v39S2lZIaq1dYpxnrcoWq11fvmFP3jDlWrrd43nOgfd6gO2Op9E4n+cYfqgK3eN4aoPWv1vgVELh7eN3voH5fDLRKb8L6so5TMWLWa9/0b+scdq1bzvidD/7hj1Wre91noH3esDpj3vRP6xx2rA+Z9P4Tcs7zvfJCLh/c9DvrH5RyMxCa8r2YoJTNWreZ924L+cceq1bxvRdA/7li1mvftBfrHHasD5n3LgP5xx+qAed8GIPcs7xP+5eIx1qn9661O7ZfaBAf8p2TGqtXGOrV/HevU/nWsU/vXsU7tX8c6tX8d69T+daxT+9exTu1fb3Zq/5lnmZ/arxYP81P75Y/LORiJTdzqgH8tmbFqNfMD/uWPO1atNtap/etYp/avY53av451av861qn961in9q83O7X/zLPMT+1Xi4f5qf3yx+UcjMQmbnXAv5bMWLWa+QH/8scdq1Yb69T+daxT+9exTu1fxzq1fx3r1P51rFP715ud2n/mWean9qvFw/zUfvnjcg5GYhO3OuBfS2asWs38gH/5445Vq411av861qn961in9q9jndq/jnVq/zrWqf3rzU7tP/Ms81P71eJhfmq//HE5B+O1TcStDvjXkhmqVgvzA/7ljztUrRZTjPW4Q9VqMdap/THWqf0x1qn9Mdap/XGzU/tPPCvMT+0Xi0eYn9ovf1zOwUhs4lYH/GvJjFWrmR/wL3/csWq1sU7tj7FO7Y+xTu2PsU7tj7FO7Y+xTu2Pm53af+ZZ5qf2q8XD/NR++eNyDkZiE7c64F9LZqxazfyAf/njjlWrjXVqf4x1an+MdWp/jHVqf4x1an+MdWp/3OzU/jPPMj+1Xy0e5qf2yx+XczASm7jVAf9aMmPVauYH/Msfd6xabaxT+2OsU/tjrFP7Y6xT+2OsU/tjrFP742an9p95lvmp/WrxMD+1X/64nIOR2MStDvjXkhmrVjM/4F/+uGPVamOd2h9jndofY53aH2Od2h9jndofY53aHzc7tf/Ms8xP7VeLh/mp/fLH5RyMxCZudcC/lsxYtZr5Af/yxx2rVhvr1P4Y69T+GOvU/hjr1P4Y69T+GOvU/rjZqf1nnmV+ar9aPMxP7Zc/LudgJDZxqwP+tWTGqtXMD/iXP+5YtdpYp/bHWKf2x1in9sdYp/bHWKf2x1in9sfNTu0/8yzzU/vV4mF+ar/8cTkHI7GJWx3wryUzVK3WzA/4lz/uULVaG+vU/jbWqf1tirEed6gOWBvr1P421qn97Wan9p94VjM/tV8sHs381H7543IOxmubaLc64F9LZqxazfyAf/njjlWrjXVqfxvr1P421qn9baxT+9tYp/a3sU7tbzc7tf/Ms8xP7VeLh/mp/fLH5RyMxCZudcC/lsxYtZr5Af/yxx2rVhvr1P421qn9baxT+9tYp/a3sU7tb2Od2t9udmr/mWeZn9qvFg/zU/vlj8s5GIlN3OqAfy2ZsWo18wP+5Y87Vq021qn9baxT+9tYp/a3sU7tb2Od2t/GOrW/3ezU/jPPMj+1Xy0e5qf2yx+XczASm7jVAf9aMmPVauYH/Msfd6xabaxT+9tYp/a3sU7tb2Od2t/GOrW/jXVqf7vZqf1nnmV+ar9aPMxP7Zc/LudgJDZxqwP+tWTGqtXMD/iXP+5YtdpYp/a3sU7tb2Od2t/GOrW/jXVqfxvr1P52s1P7zzzL/NR+tXiYn9ovf1zOwUhs4lYH/GvJjFWrmR/wL3/csWq1sU7tb2Od2t/GOrW/jXVqfxvr1P421qn97Wan9p95lvmp/WrxMD+1X/64nIOR2MStDvjXkhmrVjM/4F/+uEPVan2sU/v7WKf297FO7e9jndrfpxjrcYfqgPWbndp/4lnd/NR+sXh081P75Y/LORivbaLf6oB/LZmxajXzA/7ljztWrTbWqf19rFP7+1in9vexTu3vY53a38c6tb/f7NT+M88yP7VfLR7mp/bLH5dzMBKbuNUB/1oyY9Vq5gf8yx93rFptrFP7+1in9vexTu3vY53a38c6tb+PdWp/v9mp/WeeZX5qv1o8zE/tlz8u52AkNnGrA/61ZMaq1cwP+Jc/7li12lin9vexTu3vY53a38c6tb+PdWp/H+vU/n6zU/vPPMv81H61eJif2i9/XM7BSGziVgf8a8mMVauZH/Avf9yxarWxTu3vY53a38c6tb+PdWp/H+vU/j7Wqf39Zqf2n3mW+an9avEwP7Vf/ricg5HYxK0O+NeSGatWMz/gX/64Y9VqY53a38c6tb+PdWp/H+vU/j7Wqf19rFP7+81O7T/zLO9T+7fl6F+Pu63r/q/Fw/vUfv3jWldV//Bxl+kZ5mVq8eJxvU/t1z+udVWlf1zrquofP65Qjb2P4i8lE85k9iWeL/B92fqL32fvc/j3dX4O7b4ux7+uvrzP4dc/rnX1pX9c6+pL/7jW1Zf8cb3P4dc/rnX1pX9c6+pL/7jWJZX+ceNWj3vW9fA+h39vf5s8e5+OVw/gXSftsT4fYO8vA+dd+Rx/leWYppcPMFYnyfucevXjbt7n1Bca9eZ9pH0pmaEqpM379Hv948ZYjztU32nzPv1e/7hD9Z0279Pv9Y87VN9p8z7SXv+49+o7naj65n1O/bmqb94nz5+r+uZ9lvy5qm/ep8PL3dX7dHj9495pBZNUSL0Pki8lM1aF5H3mvP5xh/qXuc37zHn9447Vd/I+SF7/uGP1nbxPh9c/7lh9J+/T4eWq7n06/AVV9z7v/YKqe5/gfkHVvc9kl7ur95ns+scNhPS1kHof315KZqwKyfukd/3jjvUvc95nsssf1/tMdv3jjtV38j6TXf+4Y/WdvM9k1z/uvfpOZ6rufSb7BVX3PmX9gqp7n5t+QdW9T0KXu6v3Sej6x2WZdyKk3iehl5IZq0LyPgld/7hj/cuc90no+scdq+/kfRK6/nHH6jt5n4Suf9yx+k7eJ6HLVd37JPQLqu59tvkFVfc+rfyCqnsfKi53V++TwvWPyzLvREi9DxWvJON9/ri8ZPA+f1z/uGP9y5z3+eP6x42xHnesvpP3+eP6xx2r7+R9/rj+ce/VdzpTde/zxy+ouveJ4hdU3fuM8AuqfqujvM/d1ft8bv3jssw7EVLvg79LyYxVIY11Rvg21hnh21hnhG9jnRG+jXVG+DbWGeHbzc4IP33csfpO5ieKq1Xd/Pzxc1X3Pn/8gqp7nyh+rur7rc4IP3XX/VYHf194XJZ5vxbS3fvg71IyMVLJsI91Rvg+1hnh+1hnhO9jnRG+j3VG+D7WGeH7zc4IP33cofpOu/mJ4mJV383PHz9V9d37/PFzVd+9TxS/oOq3OiP83F1vdfD3hcdlmXcipN4Hf5eSGatCGuuM8H2sM8L3sc4I38c6I3wf64zwfawzwvebnRF++rhj9Z3MTxRXq7r5+ePnqu59/vgFVfc+UfyCqt/qjPBzd73Vwd8XHpdl3omQeh/8XUpmrApprDPC97HOCN/HOiN8H+uM8H2sM8L3sc4I3292Rvjp447VdzI/UVyt6ubnj5+ruvf54xdU3ftE8Quqfqszws/d9VYHf194XJZ5J0LqffB3KZmxKqSxzgjfxzojfB/rjPB9rDPC97HOCN/HOiN8v9kZ4aePO1bfyfxEcbWqm58/fq7q3uePX1B17xPFL6j6rc4IP3fXWx38ff643qd5Vwqp98HfpWTGqpDGOiN8H+uM8H2sM8L3sc4I38c6I3wf64zw/WZnhJ89rvkZ4fLHvVff6UzVzc8fP1d17/PHL6i694niF1T9VmeEn7vrrQ7+vvC4LPNOhNT74O9SMmNVSGOdEb6PdUb4PtYZ4ftYZ4TvY50Rvo91Rvh+szPCTx93rL6T+YnialU3P3/8VNUP7/PHz1X98D5R/FzVj1udEX7qrsetDv6+8LiBkL4U0sP74O9SMkNVSMdYZ4QfY50Rfox1Rvgx1hnhx1hnhB9jnRF+3OyM8NPHjbEe9159pxNVP8zPHz9Xde/zxy+ouveJ4hdU/VZnhJ+7660O/r7wuCzzToTU++DvUjJjVUhjnRF+jHVG+DHWGeHHWGeEH2OdEX6MdUb4cbMzwk8fd6y+k/mJ4mpVNz9//FzVvc8fv6Dq3ieKX1D1W50Rfu6utzr4+8Ljssw7EVLvg78ryYx1Rvgx1hnhx1hnhB9jnRF+jHVG+DHWGeHHWGeEHzc7I/z0ccfqO5mfKK5WdfPzx89V3fv88Quq7n2i+AVVv9UZ4efuequDvy88Lsu8EyH1Pvi7lMxYFdJYZ4QfY50Rfox1Rvgx1hnhx1hnhB9jnRF+3OyM8NPHHavvZH6iuFrVzc8fP1d17/PHL6i694niF1T9VmeEn7vrrQ7+vvC4LPNOhNT74O9SMjFUyTDWGeHHWGeEH2OdEX6MdUb4MdYZ4cdYZ4QfNzsj/PRxx+o7mZ8orlZ18/PHz1Xd+/zxC6rufaL4BVW/1Rnh5+56q4O/Lzwuy7wTIfU++LuUzFgV0lhnhB9jnRF+jHVG+DHWGeHHWGeEH2OdEX7c7Izw08cdqe8Uk/mJ4lpVfzyud1V1puqPB/Cuk85U/fEA3pXPmao/HiAGctfH4450N93jcVnm/VJIH2S4xi4jM1KF9HjcsSqkoc4IfzzuSH2nx+OO1Hd6PO5IfafH48ZYjztS3+nxuCP1nR6Pe6++05mqm58/fq7q3uePX1B17xPFL6j6rc4IP3fXWx38feFxWeadCKn3wd+lZMaqkIY6I/zxuCP9y9zjccfqOw11RnhMQ50R/njcsfpONzsj/PRxx+o7mZ8orlZ18/PHz1Xd+/zxC6rufaL4BVW/1Rnh5+56q4O/zx/X+zTvSiH1Pvi7lMxYFdJQZ4Q/HjfGetyx+k5DnRH+eNyx+k5DnRH+eNyx+k7mZ4TLH/defaczVTc/f/xc1b3PH7+g6t4nil9Q9VudEX7urrc6+PvC47LMOxFS74O/S8mMVSENdUb443HH+pe5oc4IfzzuWH2noc4IfzzuWH2nm50Rfvq4Y/WdzE8UV6u6+fnj56ruff74BVX3PlH8gqrf6ozwc3e91cHfFx43ENLXQup98HcpmbEqpKHOCH887lj/MjfUGeExDXVG+ONxx+o7DXVG+ONxx+o7mZ8RLn/ce/WdzlTd/Pzxc1X3Pn/8gqp7nyh+QdVvdUb4ubve6uDvC4/LMu9ESL0P/i4lM1aFNNQZ4Y/HHetf5oY6I/zxuGP1nYY6I/zxuEP1neabnRF++rhD9Z1m8xPFxao+m58/fqrq8xSfreqz94ni56o+3+qM8FN3nW918PeFx2WZ92shnb0P/q4kM9YZ4fNYZ4TPY50RPo91Rvg81hnh81hnhM9jnRE+3+yM8NPHHarvNJufKK5WdfPzx89V3fv88Quq7n2i+AVVv9UZ4efuequDvy88Lsu8EyH1Pvi7lMxYFdJYZ4TPY50RPo91Rvg81hnh81hnhM9jnRE+3+yM8NPHHavvZH6iuFrVzc8fP1d17/PHL6i694niF1T9VmeEn7vrrQ7+vvC4LPNOhNT74O9SMjFUyTDWGeHzWGeEz2OdET6PdUb4PNYZ4fNYZ4TPNzsj/PRxx+o7mZ8orlZ18/PHz1Xd+/zxC6rufaL4BVW/1Rnh5+56q4O/Lzwuy7wTIfU++LuUzFgV0lhnhM9jnRE+j3VG+DzWGeHzWGeEz2OdET7f7Izw08cdq+9kfqK4WtXNzx8/V3Xv88cvqLr3ieIXVP1WZ4Sfu+utDv6+8Lgs806E1Pvg71IyY1VIY50RPo91Rvg81hnh81hnhM9jnRE+j3VG+HyzM8JPH3esvpP5ieJqVTc/f/xc1b3PH7+g6t4nil9Q9VudEX7urrc6+PvC47LMOxFS74O/S8mMVSGNdUb4PNYZ4fNYZ4TPY50Rvox1Rvgy1hnhy83OCD993KH6TssUI6n6Yn7++KmqL97nj5+r+uJ9ovi5qi/eZ4Qfve/PB9im9uoBrKuTY5vb3wdo04sH8D5x+zjWvxE69lcRsj5D+1HOTV+ffvzvl78av34q9tG+/uQH0un7h/98odXtC0XlF4oXX6i5faFf/iWbp2n9+vTjf/f1xVfaar/S8eIr7b/9lR7RfX6lZXn1lQ67r/TbpwU/vsbxrNSmdX3xAvjt83+vfKXlt79Sm57FyNReDtzq95Xit79Sn/7Gu3/rG//9Ss3vK/3623vbludX2o4Xb+9l8/tKv/723tr+7Su9+NldjsqvtE8v3kvrr7+995j/fqVvmvr3K81+X+nX3977sn37Si/iva61X+nF23v99bf3Q/GeX+k4thdfqfl9pe73lTa/r/Tbb+9HDff82f3Pb/CLr3TYfaXfPrvx/+8r7S9elTHbZSkWv6+0+n0lv7f3b5/M94j0uv+Nd3vxG/fbp+dd+Uqb33vJ7+0dh92rsk12M675vb2b39u7+b29f/t0sQvvpeb39m7d7r3U/N7ebfd7VR52M677vb2739u7+729f/tUpQvvpe739u7N7r3U/d7efbN7Vfbdb8b5vb03v7f35vf2/u1zZC68lza/t/cWdu+lze/tvXW7V+Xm1/fe/N7em9/be/d7e//2iRgX3ku739t7X+3eS7vf23tvdq/K3e9fLXe/t/fu9/be/d7ex2T3Xjr83t7HYvdeOvze3kfYvSoPvzUnh9/b+/B7ex9+b+/jcHsvrZPd23udZrf30jrZvb3XaXV7Va5TuM24dbJ7e6+T3dt7neze3uu0+72X/N7e82T3Xpr93t7zYveqnO3WnKyz39t79nt7z35v73nzey/5vb1nu/Xe6+L39l5mu1flYrfmZF383t6L39t78Xt7L3brvdfF7+292K33Xhe/t/dqt1tnXe3WnKyr39t79Xt7++21XFe79d7r6vf2Xu3We69+ey3X1W63zhp2a05Wv72Wq99ey9Vvr+X663stz99Lfnst17Bb77367bVcw263zhp2a05Wv72Wq99ey9Vvr+Xa7NZ7r357Lddmt9579dtruTa73Tprs1tzsvrttVz99lqufnst12633nv122u5Fuy1PHsv+e21XLvdbp21+6058dtrufrttVz99lqum91679Vvr+W62a33Xv32Wq6b3W6ddfNbc+K313L122u5+u21XHe/9d5+ey3X3W+9t99ey7V4r+WrV+Xut+bEb6/l6rfXcvXba7nufuu9/fZaroffem+/vZbr4bdb59f3Wp7POL+9lqvfXsvVb6/levit9/bbaxmT3Xrv8NtrGZPdbp2Y7NacxGT39g6/vZbht9cyJrv13uG31zImu/Xe4bfXMma73Tox2605Cb+9luG31zL89lrGbLfeO/z2WsZst947/PZaxmK3WycWuzUn4bfXMvz2WobfXstY7NZ7h99ey1js1nuH317LWOx268Rqt+Yk/PZaht9ey/Dbaxm/vtfy/L3kt9cyVrv13uG31zJWu906sdqtOQm/vZbht9cy/PZaRtit9w6/vZYRduu9w2+vZYTdbp0IuzUn4bfXMvz2WobfXstoduu9w2+vZRTstTx7L/nttYxmt1snmt2ak/Dbaxl+ey3Db69ldLv13uG31zK63Xrv8NtrGd1ut050vzUnfnstw2+vZfjttYzNbr13+O21jM1uvXf47bWM4r2Wr16Vm9+aE7+9luG31zL89lrG5rfe22+vZex+67399lrGbrdbJ359r+X5jPPbaxl+ey3Db69l7H7rvf32Wsbht97bb69lHH67dQ6/NSd+ey3Db69l+O21jMNvvbffXss47NZ7N7+9lm2y263TJrs1J81vr2Wb7N7ezW+vZZvs1ns3v72WbbJb79389lq22W63Tpvt1pw0v72WzW+vZfPba9lmu/XezW+vZZvt1ns3v72WbbbbrdMWuzUnzW+vZfPba9n89lq2X99ref5e8ttr2Ra79d7Nb69lW+x267TFbs1J89tr2fz2Wja/vZZttVvv3fz2WrbVbr1389tr2Va73TpttVtz0vz2Wja/vZbNb69lC7v13s1vr2Ur2Gt59l7y22vZwm63Tgu7NSfNb69l89tr2fz2WrZmt967+e21bM1uvXfz22vZmt1undbs1pw0v72WzW+vZfPba9m63Xrv5rfXsnW79d7Nb69lK95r+epV2f3WnPjttWx+ey2b317L1u3Weze/vZZts1vv3fz2WrbNbrdO+/W9luczzm+vZfPba9n89lq2zW69d/Pba9l2v/Xefnst2263W6ftfmtO/PZaNr+9ls1vr2Xb/dZ7++21bLvfem+/vZbt8Nutc/itOfHba9n89lo2v72W7fBb7+2317Idfuu9/fZa9slut06f7NacdL+9lt1vr2Wf7N7efbJb79399lr2yW69d/fba9knu906fbZbc9L99lp2v72W3W+vZf/1vZbn7yW/vZZ9tlvv3f32WvbZbrdOn+3WnHS/vZbdb69l99tr2Re79d7db69lX+zWe3e/vZZ9sdut0xe7NSfdb69l99tr2f32WvbVbr1399tr2Qv2Wp69l/z2WvbVbrdOX+3WnHS/vZbdb69l99tr2cNuvXf322vZw269d/fba9nDbrdOD7s1J91vr2X322vZ/fZa9ma33rv77bXszW69d/fba9mL91q+elU2uzUn3W+vZffba9n99lr2Zrfeu/vttezdbr1399tr2bvdbp3+63stz2ec317L7rfXsvvttezdbr1399tr2Te79d7db69l3+x26/TNb82J317L7rfXsvvtteyb3Xrv7rfXsm9+67399lr23W63Tt/91pz47bXsfnstu99ey777rff222vZd7/13n57Lfvht1vn8Ftz4rfXsvvttex+ey374bfe22+vZT/81nv77bXsh91unW2yW3Oy+e213Pz2Wm5+ey23KdzeS5vfXsttslvvvfnttdwmu90622S35mTz22u5+e213Pz2Wm6z3XrvzW+v5Tbbrffe/PZabrPdbp1ttltzsvnttdz89lpufnstt8Vuvffmt9dyK9hrefZe8ttruS12u3W2xW7Nyea313Lz22u5+e213Fa79d6b317LbbVb77357bXcVrvdOttqt+Zk89trufnttdz89lpuYbfee/Pba7mF3XrvzW+v5Va81/LVqzLs1pxsfnstN7+9lpvfXsst7NZ7b357Lbdmt95789truTW73Trbr++1PJ9xfnstN7+9lpvfXsut2a333vz2Wm7dbr335rfXcut2u3W27rfmxG+v5ea313Lz22u5dbv13pvfXsut26333vz2Wm6b3W6dbfNbc+K313Lz22u5+e213Da79d6b317LbbNb77357bXcdrvdOtvut+bEb6/l5rfXcvPba7ntfuu9/fZabrvfem+/vZbb7rdb5/Bbc+K313Lz22u5+e213H59r+X5e8lvr+V2+K339ttruR1+u3UOuzUnu99ey91vr+Xut9dyn+zWe++T3dt7n+zWe+9+ey33yW63zj7ZrTnZ/fZa7n57LXe/vZb7bLfee/fba7kX7LU8ey/57bXcZ7vdOvtst+Zk99trufvttdz99lrui916791vr+W+2K333v32Wu6L3W6dfbFbc7L77bXc/fZa7n57LffVbr337rfXcl/t1nvvfnst9+K9lq9elavdmpPdb6/l7rfXcvfba7mvduu9d7+9lnvYrffe/fZa7mG3W2f/9b2W5zPOb6/l7rfXcvfba7mH3Xrv3W+v5d7s1nvvfnst92a3W2dvdmtOdr+9lrvfXsvdb6/l3uzWe+9+ey33Zrfee/fba7l3u906e/dbc+K313L322u5++213Lvdeu/db6/l3u3We+9+ey33zW63zr75rTnx22u5++213P32Wu6b3Xrv3W+v5b7Zrffe/fZa7pvdbp1991tz4rfXcvfba7n77bXcf32v5fl7yW+v5b77rff222u573a7dfbdb82J317L3W+v5e6313I//NZ7++213A+/9d5+ey33w2+3zuG35sRvr+Xht9fy8NtreUx2670Pv72WxxRu76XDb6/lMdnt1jkmuzUnh99ey8Nvr+Xht9fymO3Wex9+ey2P2W699+G31/KY7XbrHLPdmpPDb6/l4bfX8vDba3ksduu9D7+9lsdit9778NtreRTvtXz1qlzs1pwcfnstD7+9loffXstjsVvvffjttTxWu/Xeh99ey2O1261z/Ppey/MZ57fX8vDba3n47bU8Vrv13offXssj7NZ7H357LY+w261zhN2ak8Nvr+Xht9fy8NtreYTdeu/Db6/lEXbrvQ+/vZZHs9utczS7NSeH317Lw2+v5eG31/Joduu9D7+9lkezW+99+O21PLrdbp2j+6058dtrefjttTz89loe3W699+G31/Loduu9D7+9lke3261zbH5rTvz2Wh5+ey0Pv72Wx6/vtTx/L/nttTw2u/Xeh99ey2Oz261zbH5rTvz2Wh5+ey0Pv72Wx+633ttvr+Wx+6339ttreex2u3WO3W/Nid9ey8Nvr+Xht9fyOPzWe/vttTwK9lqevZf89loeh99uncNvzYnfXsvDbq9lm+z2Wj6+ktt678dXcnt7P76S23rvx1dye3s/vpLbbp3HV3Jbc/L4Sm5v78dXcnt7P76S39t7dlvv/fhKfm/v2W299+Mr+b29i/davnpVzm5rTh5fye/tbbfX8vGV/N7es9t67zbZ7bV8fCW39d6Pr+T39l7cdus8vlLYzTi7vZaPr+T39rbba/n4Sm7rvR9fye/tvbqt9358Jb+39+q2W+fxldzWnDy+kt/b226v5eMr+b29V7f13o+v5Pf2Xt3We7fJbq/l4yu57dZ5fCW3NSePr+T39rbba/n4Sn5v73Bb7/34Sn5v73Bb7/34Sn5v7+a2W+fxldzWnDy+kt/b226v5eMr+b29m9t678dX8nt7N7f13o+v5Pf2bm67ddrU/dac2O21fHwlv7e33V7Lx1cKu/eS3V7Lx1dyW+/9+Ep+b+/utlvn8ZX81pzY7bV8fCW/t7fdXsvHV3Jb7/34Sn5v781tvffjK/m9vTe33TqPr+S35sRur2Wb7PZaPr6S39t791vvbbfX8vGVwu69ZLfX8vGV3HbrPL6S35oTu72Wj6/k9/a222v5+Ep+673t9lo+vpLfem+7vZaPr+S3W+fwW3Nit9fy8ZX83t5+ey3nyW699+y313Ke7NZ7z357Lecp3F6V82S35mT222s5T3Zv79lvr+U82a33nv32Ws6z3Xrv2W+v5Tzb7daZf32v5fmM89trOfvttZz99lrOs91679lvr+W82K33nv32Ws6L3W6debFbczL77bWc/fZazn57LefFbr337LfXcl7s1nvPfnst59Vut8682q05mf32Ws5+ey1nv72W82q33nv222s5r3brvWe/vZZz2O3WmcNuzcnst9dy9ttrOfvttZzDbr337LfXcg679d6z317LOex268zNbs3J7LfXcvbbazn77bWcf32v5fl7yW+v5dzs1nvPfnst52a3W2dufmtO/PZazn57LWe/vZZzt1vvPfvttZy73Xrv2W+v5dztduvM3W/Nid9ey9lvr+Xst9dy3uzWe89+ey3ngr2WZ+8lv72W82a3W2fe/Nac+O21nP32Ws5+ey3n3W+9t99ey3n3W+/tt9dy3u1268y735oTv72Ws99ey9lvr+V8+K339ttrOR9+67399lrOxXstX70qD781J357LWe/vZaz317L+bBb77347bVcJrv13ovfXstlstuts0zhNuMWv72Wi99ey8Vvr+Uy2a33Xvz2Wi6z3XrvxW+v5TLb7dZZZrs1J4vfXsvFb6/l4rfXcpnt1nsvfnstl9luvffit9dyWex26yyL3ZqTxW+v5eK313Lx22u5LHbrvRe/vZbLYrfee/Hba7msdrt1ltVuzcnit9dy8dtrufjttVxWu/Xei99ey2W1W++9+O21XFa73TpL2K05Wfz2Wi5+ey0Xv72Wy6/vtTx/L/nttVzCbr334rfXcgm73TpL2K05Wfz2Wi5+ey0Xv72WS7Nb77347bVcmt1678Vvr+XS7HbrLM1uzcnit9dy8dtrufjttVy63XrvxW+v5VKw1/LsveS313Lpdrt1lu635sRvr+Xit9dy8dtruWx2670Xv72Wy2a33nvx22u5bHa7dZbNb82J317LxW+v5eK313LZ/dZ7++21XHa/9d5+ey2X4r2Wr16Vu9+aE7+9lovfXsvFb6/lsvut9/bba7kcfuu9/fZaLoffbp1f32t5PuP89loufnstF7+9lsvht97bb6/lOtmt91799lquk91unXWyW3OyTnZv79Vvr+Xqt9dynezWe69+ey3XyW699+q313Kd7XbrrLPdmpPVb6/l6rfXcvXba7nOduu9V7+9lutst9579dtruS52u3XWxW7Nyeq313L122u5+u21XBe79d6r317LdbFb77367bVcF7vdOutqt+Zk9dtrufrttVz99lquv77X8vy95LfXcl3t1nuvfnst19Vut8662q05Wf32Wq5+ey1Xv72Wa9it91799lquYbfee/Xba7mG3W6dNezWnKx+ey1Xv72Wq99ey7XZrfde/fZargV7Lc/eS357Lddmt1tnbXZrTla/vZar317L1W+v5drt1nuvfnst12633nv122u5drvdOmv3W3Pit9dy9dtrufrttVw3u/Xeq99ey3WzW++9+u21XIv3Wr56VW5+a0789lqufnstV7+9luvmt97bb6/luvut9/bba7nudrt11t/fa7nEc8bNyxYvvtKv197L8fcrrfOrr9T9vtLm95V+/V8t1+cf/fjf8Sreh91X+v29ludfaf79LM3fvtL64iu9fHv/5165r79lWffvX+nPf7a+95+9fAv+51+Yv/6zRyvnxX/W3vvP+uv/7Pmu/k+X5sV/tp3/Z8eL/+zlrGzR+nO8jvbiPzvO/rM2/1+S8XovWott+fu3xYv/bH7vP1veebZ4ve/q/NnivS/Z3vvP+nvPtr33bPt7X/J46z+bp7eebZ7ferZ5ee9Lru/9Z/Hes7X3nq2/9yW39/6z/b1ne+9dsrz3Llnee5cs771LlvfeJct775LlvXfJ8t67ZHnvXbK89y5Z3nuXrO+9S9b33iXre++S9b13yfreu2R9712yvvcuWd97l6zvvUvW994l8d67JN57l8R775J4710S771L4r13Sbz3Lon33iXx3rsk3nuXtPfeJe29d0l7713S3nuXtPfeJe29d0l7713S3nuXtPfeJe29d0l/713S33uX9PfeJf29d0l/713S33uX9PfeJf29d0l/713S33uXbO+9S7b33iXbe++S7b13yfbeu2R7712yvfcu2d57l2zvvUu2994l+3vvkv29d8n+3rtkf+9dsr/3Ltnfe5fs771L9vfeJft775L9vXfJ8d675HjvXXK89y453nuXHO+9S4733iXHe++S4713yXu913iv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99re672293qv7b3ea3uv99rf673293qv/b3ea3+v99rf673293qv/b3ea3+v99rf673293qv/b3ea3+v99rf673293qv/b3ea3+v99rf673293qv/b3ea3+v99rf673293qv/b3ea3+v99rf673293qv/b3ea3+v99rf673293qv/b3ea3+v99rf673293qv/b3ea3+v99rf673293qv/b3ea3+v99rf673293qv/b3ea3+v99rf673293qv/b3ea3+v99rf673293qv/b3ea3+v99pf914fpdjXtrlHwfNf2+Ze7CBc56+/Y16X7cXfsf7C3xGCv2Obnn/HPr/4O9ov/B39F/6O7Rf+jpdz5vEH78+/I7Z/O+bH//7veN3j/od/xwmr1w1x8d+x/MLfsf7C3/F6ns9tff4d//2fvTPm7Rf+ji74O85Ybb/wd+y/8Hcc//u/Y0vm+f61k/7hZuu/HPNt/oW/YxH8HWes1l/4O+IX/o72C3/H63m+LMfz7+j/tvZ5/Q884r9jF/wdZ6yO//3f8frfmcR/x/wLf8freb7052/tOrV/Oeav/7lL/HeE4O84Y9V+4e/ov/B3bL/wd7ye59v+9Xds8zKd/B1teh5O1NZvH44XH1768wiqpR9/v9D8n4No/s+n18dv6J9PPx7k77t56V9f//jor//63zc/5+vPn/31l8/++utnf/347K/fPvvr98/++ttnf/3P/tU9PvpXd5s++ld3mz76V3ebPvpXd5s++ld3mz76V3ebPvpXd5s++ld3mz76V3ebPvpXd5s++1d3/uxf3fmzf3Xnz/7VnT/7V3f+7F/d+bN/defP/tWdP/tXd/7sX935s391l8/+1V0++1d3+exf3eWzf3WXz/7VXT77V3f57F/d5bN/dZfP/tVdPvtXd/3sX931s39118/+1V0/+1d3/exf3fWzf3XXz/7VXT/7V3f97F/d9bN/deOzf3Xjs39147N/deOzf3Xjs39147N/deOzf3Xjs39147N/deOzf3XbZ//qts/+1W2f/avbPvtXt332r2777F/d9tm/uu2zf3XbZ//qts/+1e2f/avbP/tXt3/2r27/7F/d/tm/uv2zf3X7Z//q9s/+1e2f/avbP/tXd/vsX93ts391t8/+1d0++1d3++xf3e2zf3W3z/7V3T77V3f77F/d7bN/dffP/tXdP/tXd//sX939s39198/+1d0/+1d3/+xf3f2zf3U/+2yq7bPPpto++2yq7bPPpto++2yq7bPPpto++2yq7bPPpto++2yq7bPPpto++2yq7bPPpto/+2yq/bPPpto/+2yq/bPPptqnj/7V3T/7bKr9s8+m2j/7bKr9s8+m2j/7bKr9s8+m2j/7bKrd+2yqdqxf90O0o2/fv/6L77H3/vwiez/2F09r/SMtf1rr33T501qXAPKnta4Y5E9rXWDIn9a6HpE/rXX58g+f9tH6fj7tviw/f7wf09enH1/k75/9n7sj/8+H9yXiz4f371faPD78/zh6nzb2QRytC7oP4ninyrKS451q1kqOAUcJxzvV2ZUc71TBV3K8kxtUcryTdVRyxGckHL3PcfwgjviMhiM+o+GIz2g4BhwlHPEZDUd8RsMRn9FwxGc0HPEZCUfvE3I/iCM+o+GIz2g44jMajgFHCUd8RsMRn9FwxGc0HPEZDUd8RsLR++zxD+KIz2g44jMajviMhmPAUcIRn9FwxGc0HPEZDUd8RsMRn5Fw9L7V4YM44jMajviMhiM+o+EYcJRwxGc0HPEZDcff9pmtr18c93k54TjP2/H1Ry/TN+rH9hLk82H/w/Qvxqm/HNH9OaLbNH37dPtisw/LZl+25zdp7b/YvEj7tj7DfryI2DEuxieZ5fj2Z7+F8ddvwPHBeCzHE+PWXszUX79e54PeYr9+d88932K/fofQTd9iwVssfYs13mLp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SaG3pw/fD/0lFkfWV5/7P4beniasCn22pwPLQm/d/rLQW/e+LPTWjS8LfbLQrwq9dcvLQm/d77LQWze7LPTWzS4LvXWzq0JfrJtdFnrrZpeF3rrZZaG3bnZZ6JOFflXorZtdFnrrZpeF3rrZZaG3bnZZ6K2bXRX6at3sstBbN7ss9NbNLgu9dbPLQp8s9KtCb93sstBbN7ss9NbNLgu9dbPLQm/d7KrQN+tml4Xeutnvh/4bMrfNWtSfxFNT5rZZi6qbysniuSqVre/UTWVrJpelsjWTuqlsHeKyVLYOUTWVu7V9q1K5W9unm8rW9i1LZWv7dFM5WTxXpbK1fbqpbG3fslS2tk83la3tW5bK1vZppnJ21vYtSuXsrO3TTWVr+5alsrV9uqmcLJ6rUtnaPt1UtrZvWSpb26ebytb2LUtla/tUU9lb27cqlb21fbqpbG3fslS2tk83lZPFc1UqW9unm8rW9i1LZWv7dFPZ2r5lqWxtn2oqB2v7VqVysLZPN5Wt7VuWytb26aZysniuSmVr+3RT2dq+ZalsbZ9uKlvbtyyVre1TTeVobd+qVI7W9ummsrV9y1LZ2j7dVE4Wz1WpbG2fbipb27csla3t001la/uWpbK1faqpnKztW5XKydo+3VS2tm9ZKlvbp5vKyeK5KpWt7dNNZWv7lqWytX26qWxt37JUtrbvB6Gv+fj3W211kMoZu+27nOWvn86lCvEssV5/X6HcR/9JNO/yMnV39+kRyeVk6655mVK5T8zHD9fur1tI7bE+ZnHG7vg+NerYfeGnRh27JfzUqCeL+oKoY/eMnxp17M7yU6OO3VR+atSxW89PjTp21/mhUS/Wm66IuvWmK6JuvemKqFtvuiLqyaK+IOrWm66IuvWmK6JuvemKqFtvuiLq1psuiHq13nRF1K03XRF1601XRN160xVRTxb1BVG33nRF1K03XRF1601XRN160xVRt950QdSb9aYrom696YqoW2+6IurWm66IerKoL4i69aYrom696YqoW2+6IurWm66IuvWmC6LerTddEXXrTVdE3XrTFVG33nRF1JNFfUHUrTddEXXrTVdE3XrTFVG33nRF1K03nR/14qw3XRF1601XRN160xVRt950RdSTRX1B1K03XRF1601XRN160xVRt950RdStN10QdW+96YqoW2+6IurWm66IuvWmK6KeLOoLom696Yqo79ubliM0/vLxuVHftzddGfV9e9OVUd+3N10Y9bBvb7oy6vv2piujvm9vujLq+/amK6OeLOoLor5vb7oy6tabroi69aYrom696YqoW2+6IOrRetMVUbfedEXUwXvTmq+fLlH6beRcrr90XFz467N/fAXvCFV9TRv5Ct79qPoK3nOo+gp+0lf1Ffx8reor+KlW09cEfpZU9RX8BKfq60bnprTRuSmljXzd6NyUNjo3pY3OTWmjc1Pa6NyUNzo35Y3OTXmjc1Pe6NyU00a+bnRuyhudm/JG56a80bkpb3RuKhudm8pG56ay0bmpbHRuKulzfK3l+sV0c2nk6wedm0RfP+jcJPr6Qecm0dcPOjeJvn7QuUnyFf232VV9/aBzk+jrB52bRF8/6Nwk+po28nWjcxP670ur+rrRuQn9t5RVfd3o3IT+u8Gqvm50bkL/jVxVXz/o3NTC9cMtj543of8e7E989b5eH6553/vI2w86OX3D2w86O33D2w86PX3D2w86P33D2w86Qcneov++pbK3H3SK+oa3H3SO+oa3H3SS+oa3aStvtzpLof9en7K3W52l0H+fTtnbnc5SFf332JS93eksVdF/f0zZ253OUtWlrbzd6SxV0X9fStnbnc5SFf33lJS93eoshf77QcrebnWWQv+9HGVvtzpLof8+jLK3W52l0H8PRdnbrc5S6L//oeztVmcp9N+7UPZ2q7MU+u87KHu71VkK/fcMlL3d6iyFrt+v7O1WZyl0vXplb7c6S6Hrsyt7u9VZ6pP0yL/h7VZnqU/SJP+Gt1udpT5Jl/wb3m51lvokbfJveLvVWeqT9Mm/4e1WZ6lP0ij/hrdbnaU+Saf8G95udZb6JK3yb3i71Vnqk/TKv+HtVmepT9Is/4a3W52lPkm3/BvebnWW+iTt8m94u9VZ6pP0y7/h7VZnqU/SMP+Gt1udpT5Jx/wb3m51lvokLfNveLvVWeqT9My/4e1WZ6lP0jT/hrdbnaU+Sdf8G95udZb6JG3zb3i71Vnqk/TNv+HtVmepT9I4/4a3W52lPknn/BvebnWW+iSt8294u9VZ6pP0zr/h7VZnqU/SPP+Gt1udpbbSPa9b6Z7XrXTP61a653Ur3fO6le553Ur3vG6le1630j2vW+me1610z+tWuud1K93zupXued1K97xupXvettI9b1vpnretdM/bVrrnzaWtvN3pLNW20j1vW+met610z9tWuudtK93ztpXuedtK97xtpXvettI9b1vpnretdM/bVrrnbSvd87aV7nnbSve8baV73rbSPW9b6Z63rXTP21a6520r3fO2le5520r3vG2le9620j1vW+met610z9tWuudtK93ztpXuedtK97xtpXvettI9b1vpnretdM/bVrrnbSvd87aV7nnbSve8baV73rbSPW9b6Z63rXTP21a6520r3fO2le5520r3vG2le9620j1vW+met610z9tWuudtK93ztpXuedtK97xtpXvettI9b1vpnretdM/bVrrnbSvd87aV7nnbSve8baV73rbSPW9b6Z63rXTP21a6520r3fO2le5520r3vG2le9620j1vW+met610z9tWuudtK93ztpXuedtK97xtpXvePkr3PLQDJLo28vaTzlKx1StI8nHkrcJZquQjgar3r731qRyhKSHfeTuOTUhXb4O7j00ZfLqnK3SvXfhsPYJeQ7n7bL3GpVtcRnHR0FKHiUu/ftg7/3dg/jjrd3I27ORs3MnZ9DnOeh9vp5USR97mrbwtW3lbP8jb4K8nOR9SGXn7QWezb3j7QSeuSyN17MnBJ+HTyferjyn4esP+HZnuPujMpRyZDzqgKUfmg05zypH5oKOfcmSSReZJZD7qTKkamY86f6pG5pPOqrqR+aRzrW5k7Az8JDLezsDPImNn4GeRsTPws8jYGfhZZJJF5klk7Az8LDJ2Bn4WGTsDP4uMnYGfRcbOwE8iE+wM/CwydgZ+Fhk7Az+LjJ2Bn0UmWWSeRMbOwM8iY2fgZ5GxM/CzyNgZ+Flk7Az8JDLRzsDPImNn4GeRsTPws8jYGfhZZJJF5klk7Az8LDJ2Bn4WGTsDP4uMnYGfRcbOwE8ikz71DJwHM/89fdK5NpbD29jzyNtPOqvK3n7S+TOmeHj7n7dXTtzjySLzJDKfdP68i0z6z6f/ePtJZ8ocj7fRcxl6+0nnRNnbTzr7yd5+0nkuN3f82879446WP+k8pxuZTzr73UfmztfbHZI/6exX+g3EpZG3n3T2k71Nn+RtvWVy/+d7/JPOc7qR+aSz311k7kHu7pBPOvtdHl9d/+3u/7XjyZ90TryPTHWjPPikc2L3xxOQS+M68LZ80tlP9vaTznOq93j5pLOfeI+XTzr7yVmf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omu9qfpKXtfRdeFEfu75tkqk9Tbm555br+D6bTI/eV1H128T+bnn2yq4fpvMv8/cekXXelP1lbyuo+vCifzc822VSOttzM89t17B9dtkfvK6jq7fJvJzz7dVcP02mX+fufWKrvWm6it5XUfXhRP5uefbKpHW25ife269guu3yfzkdR1dv03k555vq+D6bTL/PnPrFV3rTdVX8rqOrgsn8pPPtxFpvY35uefWK7h+m8xPXtfR9dtEfvL5NnD9Npl/o7l1dK03VV/J6zq6LpzITz7fRqT1NuYnn1sH12+T+cnrOrp+m8hPPt8Grt8m8280t46u9abqK3ldR9eFE/nJ59uItN7G/ORz6+D6bTI/eV1H128T+cnn28D122T+jebW0bXeVH0lr+vounAiP/l8G5HW25iffG4dXL9N5iev6+j6bSI/+XwbuH6bzL/R3Dq61puqr9x1vaHrwon83PNtjUjrbczPPbfeHHZdl/m563pD128T+bnn2xq4fpvMv8/cekPXelP1lbyuo+vCifzc822NSOttzM89t97A9dtkfvK6jq7fJvJzz7c1cP02mX+fufWGrvWm6it5XUfXhRP5uefbGpHW25ife269geu3yfzkdR1dv03k555va+D6bTL/PnPrDV3rTdVX8rqOrgsn8nPPtzUirbcxP/fcegPXb5P5yes6un6byM8939bA9dtk/n3m1hu61puqr+R1HV0XTuQnn28j0nob83PPrTdw/TaZn7yuo+u3ifzk823g+m0y/z5z6w1d603VV/K6jq4LJ/KTz7cRab2N+cnn1sH122R+8rqOrt8m8pPPt4Hrt8n8G82to2u9qfpKXtfRdeFEfvL5NiKttzE/+dw6uH6bzE9e19H120R+8vk2cP02mX+juXV0rTdVX8nrOrounMhPPt9GpPU25iefWwfXb5P5yes6un6byE8+3wau3ybzbzS3jq71puoreV1H14UT+cnn24i03sb83HPrHVy/TebnrusdXb9N5Oeeb+sOvFaL/PvMrXd0rTdVX7nrekfXhRP5uefbOpHW25ife269g+u3yfzkdR1dv03k555v6+D6bTL/PnPrHV3rTdVX8rqOrgsn8nPPt3UirbcxP/fcegfXb5P5yes6un6byM8939bB9dtk/n3m1ju61puqr+R1HV0XTuTnnm/rRFpvY37uufUOrt8m85PX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YL1YsF4sWC8WrBcL1osF68WC9WLBerFgvVisXh6d0uDHUTAuB+NKMI6DcTUYJ8E4Dca1YFywXihYLxSsFwrWCwXrhYL1QsF6oWC9ULBeKFgvFKyXHKyXHKyXHKyXHKyXHKyXHKyXHKyXHKyXHKyXHKyXEqyXEqyX8qhe2hFXypwNRvTo7Ier0DAUmgqFRqDQKBSaBoXGkNBwgkJDUGigtJihtJihtJihtJihtJihtJihtJihtLhCaXGF0uIKpcUVSosrlBZXKC2uUFpcobS4QmlxhdJigdJigdJigdJigdJigdJigdJigdJigdJigdJigdJihdJihdJihdJihdJihdJihdJihdJihdJihdJihdLiBqXFDUqLG5QWNygtblBa3KC0uEFpcYPS4galxQ1Kiw1Kiw1Kiw1Kiw1Kiw1Kiw1Kiw1Kiw1Kiw1Kiw1Ji0tC0uKSkLS4JCQtLglJix8cPX0ZGiQtLglJi0tC0uKSkLS4JCgtJigtJigtJigtJigtJigtJigtJigtJigtJigtJigtzlBanKG0OENpcYbS4gylxRlKizOUFmcoLc5QWpyhtLhAaXGB0mKovrsC1XdXoPruClTfXYHquytQfXcFqu+uQPXdFai+uwLVd1eg+u4KVN9dgeq7K1B9dwWq765A9d0VqL67AtV3V6D67gpU312B6rsrUH13BarvrkD13RWovrsC1XdXoPruClTfXYHquytQfXcFqu+uQPXdFai+uwLVd1eg+u4KVN9dgeq7K1B9dwWq765A9d0VqL67AtV3V6D67gpU312B6rsrUH13BarvrkD13RWovrsC1XdXoPruClTfXYHquytQfXcFqu+uQPXdFai+uwLVd1eg+u4KVN9dgeq7K1B9dwWq765A9d0VqL67AtV3V6D67gpU3x1D9d0xVN8dQ/XdMVTf3YMXpl6GBkmLGarvjqH67hiq746h+u4Yqu+OofruGKrvjqH67hiq746h+u4Yqu+OofruGKrvjqH67hiq746h+u4Yqu+OofruGKrvjqH67hiq746h+u4Yqu+OofruGKrvjqH67hiq746h+u4Yqu+OofruGKrvjqH67hiq746h+u4Yqu+OofruGKrvjqH67hiq746h+u4Yqu+OofruGKrvjqH67hiq746h+u4Yqu+OofruGKrvjqH67hiq746h+u4Yqu+OofruGKrvjqH67hiq744f9d2xph0NN7lH8xXHwbgajJNgnAbjWjDOYnGPuqPcOArG5WBcsF40WC8arBcN1osG60WD9aLBemnBemnBemnBemnBemnBemnBemnBemnBemnBemnBerFgvViwXixYLxasFwvWiwXrxYL1YsF6sWC9WKxeakrBOArG5WBcCcZxMK4G4yQYp8G4FowL1gsF64WC9ULBeqFgvVCwXihYLxSsFwrWCwXrhYL1koP1koP1koP1koP1koP1koP1koP1koP1koP1koP18mjXwyY8e1yt/O9T7prro10PF6HJUGgKFBqGQlOh0AgUGoVC06DQGBIahtJihtJihtJihtJihtJihtJihtJihtJihtJihtLiCqXFFUqLK5QWVygtrlBaXKG0uEJpcYXS4gqlxRVKiwVKiwVKiwVKiwVKiwVKiwVKiwVKiwVKiwVKiwVKixVKixVKixVKixVKixVKixVKixVKixVKixVKixVKixuUFjcoLW5QWtygtLhBaXGD0uIGpcUNSosblBY3KC02KC02KC02KC02KC02KC02KC02KC02KC02KC02JC2WhKTFkpC0WBKSFktC0mJJSFosCUmLJSFpsSQkLZaEpMWSvq/Fn3GUgnEUjMvBuBKM42BcDcZJME6DcS0YF6yXHKyXHKyXHKyXHKyXHKyXHKyXHKyXHKyXHKyXHKyXEqyXEqyXEqyXEqyXEqyXEqyXEqyXEqyXEqyXEqwXDtYLB+uFg/XCwXrhYL1wsF44WC8crBcO1gsH66UG66UG66UG66UG66UG66UG66UG66UG66UG66UG60WC9SLBepFgvUiwXiRYLxKsFwnWiwTrRYL1IsF60WC9aLBeNFgvGqwXDdaLButFg/WiwXrRYL1osF5asF5asF5asF5asF5asF5asF5asF5asF5asF5asF4sWC8WrBcL1osF68WC9WLBenn49Ehlj5NZ58HJw6dH16BpQGj0wROSj6nWDc2Hjf71F9YH6/Xbf7A9TrOc42owToJxGoxrwTiLxT1YAfbjHv1+TZ7HPbieJmWPMy3Pq3D76nZ8+iguSr+S6IwkbUYS+3aSz7gHC7V+HAXjcjCuBOM4GFeDcRKM01jco4XTdHewKaV0jntg1JTLEcf5HMfBuBqMk2CcBuNaMM5icY8WMumwt+1vPsdRMC4H40ow7lG9sNzF1XNcDcZJME6DcS0YZ7G4RwuZbhz9QX324h78fjkf+pK5PjevRvnXh9vdR28zvIenrw9MIQNSeBb88KT0oUnajCQ2IcnD48qHJqEZSfKMJGVGEp6RpM5IMmPEy4wRL98f8V9xFovTFIxDOvBfFenAf1Wkl6/oo8X8n0Lz3Ju1QqERKDQKhaZBoTEkNC1BoXl0YO+xWJc5nzX84QsHvLgSjONgXOzAXg2+cECDLxxQqKY4hWqKU6imOJ3dFPd8/M5uinPQFCg0/G00X3E1GCfBOKSHeor1UO9hS9gVaNrDlrAfQvO0vtvDlrBr0GQoNA+UqPGxCt3ktMre0gPNaKJ7nKV6jquP8qW7ODnHWSzuUduLG8fBuEcPn/nu4ayUc1yA379v//p///f/9p/+9//jP//H/2eL+viP/+P//g///T/9l//71z//+//3X2//5f/4b//pP//n//R//W//9b/9l//wH//P//Hf/uP/9p//y3/4+G//ln79z/+yTXL/tZXnhuejKETrv6TVD3Sf/1HkX9uKxMc/P4bTdpO5/VP/1+2b6RZP25M1avwr3vRflPQWTpX/RdVu4STpXyT5IzzfwnPif+Vcb+FtC297uOV/bU/r9vDtv+aUPsLLnr3RFtKK/fqC7Tn69s+0f8PHOPj4ffbv+Li02/98guAdxLaY9q+8TWt/fct2h/Gvwvu3ZK1l+8+13b5l+6h+fN4+vqXevqW07fKUZrdv2dL+q+X9YpS20d/+p96+pdg2PS9G9PEtcvuW7Xn+1xX8/Dm2yy/7j/HxdbfgVv61/UxboH4Els8rSf/KRMfFq7er1W4fqRvAevy6ouVfojsr2X48sU9O9hHxxX2j9PkllA6evOFumm48U/vX9jMcPAtv/7nsP3tpG9jtfz7hEt3AfBaH8H6RU9rw7hcnb9cmf10ayjua8vFFn/+/vQLy9uxlq6BSfqH5+mfevzYn2f5New1vH/2ouCKfX7OXQKGtkArthVQ2dOVAV+jjtyLinRRthbT9z2chUT0Qbv/fL6KyE/2s4/w5xj4EZrsV26iy7r/Ddp+2VTZT2THyZgvb/3xR3X/hDcNWHJTk1xdtdf8x9toxYFqm7f+R5Sj3Ztv/w7br+O+bdPz/","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"10":{"source":"pub struct Vec<T> {\n    pub(crate) slice: [T],\n}\n// A mutable vector type implemented as a wrapper around immutable slices.\n// A separate type is technically not needed but helps differentiate which operations are mutable.\nimpl<T> Vec<T> {\n    pub fn new() -> Self {\n        Self { slice: &[] }\n    }\n\n    // Create a Vec containing each element from the given slice.\n    // Mutations to the resulting Vec will not affect the original slice.\n    pub fn from_slice(slice: [T]) -> Self {\n        Self { slice }\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Panics if the given index\n    /// points beyond the end of the vector.\n    pub fn get(self, index: u32) -> T {\n        self.slice[index]\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn set(&mut self, index: u32, value: T) {\n        self.slice[index] = value;\n    }\n\n    /// Push a new element to the end of the vector, returning a\n    /// new vector with a length one greater than the\n    /// original unmodified vector.\n    pub fn push(&mut self, elem: T) {\n        self.slice = self.slice.push_back(elem);\n    }\n\n    /// Pop an element from the end of the given vector, returning\n    /// a new vector with a length of one less than the given vector,\n    /// as well as the popped element.\n    /// Panics if the given vector's length is zero.\n    pub fn pop(&mut self) -> T {\n        let (popped_slice, last_elem) = self.slice.pop_back();\n        self.slice = popped_slice;\n        last_elem\n    }\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    pub fn insert(&mut self, index: u32, elem: T) {\n        self.slice = self.slice.insert(index, elem);\n    }\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the removed element\n    pub fn remove(&mut self, index: u32) -> T {\n        let (new_slice, elem) = self.slice.remove(index);\n        self.slice = new_slice;\n        elem\n    }\n\n    /// Returns the number of elements in the vector\n    pub fn len(self) -> u32 {\n        self.slice.len()\n    }\n}\n\nmod tests {\n    use crate::collections::vec::Vec;\n\n    #[test]\n    fn set_updates_values_properly() {\n        let mut vec = Vec { slice: &[0, 0, 0, 0, 0] };\n\n        vec.set(0, 42);\n        assert_eq(vec.slice, &[42, 0, 0, 0, 0]);\n\n        vec.set(1, 43);\n        assert_eq(vec.slice, &[42, 43, 0, 0, 0]);\n\n        vec.set(2, 44);\n        assert_eq(vec.slice, &[42, 43, 44, 0, 0]);\n\n        vec.set(1, 10);\n        assert_eq(vec.slice, &[42, 10, 44, 0, 0]);\n\n        vec.set(0, 0);\n        assert_eq(vec.slice, &[0, 10, 44, 0, 0]);\n    }\n\n    #[test(should_fail)]\n    fn panics_when_writing_elements_past_end_of_vec() {\n        let mut vec = Vec::new();\n        vec.set(0, 42);\n\n        // Need to use println to avoid DIE removing the write operation.\n        crate::println(vec.get(0));\n    }\n}\n","path":"std/collections/vec.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"20":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"26":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// docs:start:sha256\n#[deprecated(\"sha256 is being deprecated from the stdlib, use https://github.com/noir-lang/sha256 instead\")]\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\n#[deprecated(\"sha256 is being deprecated from the stdlib, use https://github.com/noir-lang/sha256 instead\")]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\n#[deprecated(\"sha256 is being deprecated from the stdlib, use https://github.com/noir-lang/sha256 instead\")]\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        // Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        // Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    // Safety: the msg_len is checked below in verify_msg_len\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n\n        // Safety: testing context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        // Safety: test context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        // Safety: testing context\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n","path":"std/hash/sha256.nr"},"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"61":{"source":"mod tests;\nmod utils;\n\nuse jwt::JWT;\n\nuse zkemail::{\n    headers::{body_hash::get_body_hash, email_address::get_email_address},\n    MAX_EMAIL_ADDRESS_LENGTH, partial_hash::partial_sha256_var_end,\n    dkim::RSAPubkey, KEY_LIMBS_2048, Sequence\n};\n\nuse utils::position_and_salary_extractor::{\n    extract_position_from_email_body, // @dev - extract_position_from_email_body() function\n    extract_salary_from_email_body    // @dev - extract_salary_from_body() function\n}; \nuse utils::email_2048_bit_dkim_verifier::{\n    MAX_EMAIL_HEADER_LENGTH, MAX_EMAIL_BODY_LENGTH, \n    verify_email_2048_bit_dkim,        // @dev - verify_email_2048_bit_dkim() function\n};\n\n// @dev - [NOTE]: The following imported-variables are temporary variables. They are stored into the \"test_header\" and \"test_body\" for passing the verify_email_2048_bit_dkim() function. Thus, this should be removed once appropreate implementation will be done in the future.\nuse tests::test_inputs::{\n    EmailLarge::{\n        HEADER, BODY,\n    },\n};\n\nglobal MAX_PARTIAL_DATA_LENGTH: u32 = 640; // signed data length after partial SHA\nglobal MAX_DOMAIN_LENGTH: u32 = 64;\nglobal MAX_EMAIL_LENGTH: u32 = 128;\nglobal MAX_POSITION_LENGTH: u32 = 128;\nglobal MAX_SALARY_LENGTH: u32 = 32;\n\n// Rating must be between 1 and 5\nfn verify_rating(rating: u8) {\n    assert(rating >= 1, \"rating must be at least 1\");\n    assert(rating <= 5, \"rating must be at most 5\");\n}\n\n/**\n * @brief Verify JWT signature (RSA/SHA256 only) and validate domain field\n * Also verify position and salary claims\n *\n * @param partial_data: OIDC JWT (id_token) base64 data (`$header.$payload`) as byte array of ascii characters\n *                      We do partial SHA on the data up to hd field outside of the circuit, to reduce constraints\n *                      This field only contains the bytes after partial SHA; padded to MAX_PARTIAL_DATA_LENGTH\n * @param partial_hash: The 256-bit partial hash of the `data`\n * @param full_data_length: The full length of the `data` (before partial SHA)\n * @param base64_decode_offset: Offset needed in `partial_data` to make the payloadB64 a multiple of 4\n *                    Signed data is $header.$payload. $payload might not be a multiple of 4 in `partial_data`, so we need to offset\n *                    Not attack-able by giving an incorrect offset, as string match of domain will fail\n * @param jwt_pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n * @param jwt_pubkey_redc_params_limbs: RSA reduction parameters limbs\n * @param jwt_signature_limbs: RSA signature limbs\n * @param domain: Domain name (`hd` key) as a byte array of ascii characters padded to MAX_DOMAIN_LENGTH\n * @param position: Position at the company as a byte array of ascii characters padded to MAX_POSITION_LENGTH\n * @param salary: Salary at the company as a byte array of ascii characters padded to MAX_SALARY_LENGTH\n * @param work_life_balance: Work-life balance rating (1-5)\n * @param culture_values: Culture and values rating (1-5)\n * @param career_growth: Career growth rating (1-5)\n * @param compensation_benefits: Compensation and benefits rating (1-5)\n * @param leadership_quality: Leadership quality rating (1-5)\n * @param operational_efficiency: Operational efficiency rating (1-5)\n **/\nfn main(\n    partial_data: BoundedVec<u8, MAX_PARTIAL_DATA_LENGTH>,\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    jwt_pubkey_modulus_limbs: pub [u128; 18],\n    jwt_pubkey_redc_params_limbs: [u128; 18],\n    jwt_signature_limbs: [u128; 18],\n    domain: pub BoundedVec<u8, MAX_DOMAIN_LENGTH>,\n    position: pub BoundedVec<u8, MAX_POSITION_LENGTH>,   // Position, which is part of Email Body-extracted from the Entire Email Body.\n    salary: pub BoundedVec<u8, MAX_SALARY_LENGTH>,       // Salary, which is part of Email Body-extracted from the Entire Email Body.\n    work_life_balance: pub u8,\n    culture_values: pub u8,\n    career_growth: pub u8,\n    compensation_benefits: pub u8,\n    leadership_quality: pub u8,\n    operational_efficiency: pub u8,\n\n    // @dev - Input parameters for email verification /w ZKEmail.nr\n    header: BoundedVec<u8, MAX_EMAIL_HEADER_LENGTH>,  // Entire Email Header\n    body: BoundedVec<u8, MAX_EMAIL_BODY_LENGTH>,      // Entire Email Body\n    pubkey: RSAPubkey<KEY_LIMBS_2048>,\n    signature: [Field; KEY_LIMBS_2048],\n    body_hash_index: u32,\n    dkim_header_sequence: Sequence\n) {\n    // Init JWT struct and verify signature\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        jwt_pubkey_modulus_limbs,\n        jwt_pubkey_redc_params_limbs,\n        jwt_signature_limbs,\n    );\n    jwt.verify();\n\n    // Assert email_verified claim\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n\n    // Get email claim\n    let email: BoundedVec<u8, MAX_EMAIL_LENGTH> = jwt.get_claim_string(\"email\".as_bytes());\n\n    // Get domain start_index from email claim - unconstrained, but we verify the domain bytes below\n    // Safety: This function is unconstrained but its output is verified by the domain check below\n    let domain_start_index = unsafe { get_domain_start_index_in_email(email) };\n\n    // Verify domain passed is present in the email claim after the @\n    assert(email.storage()[domain_start_index - 1] == 64, \"char before domain is not '@'\");\n    for i in 0..MAX_DOMAIN_LENGTH {\n        assert(email.storage()[domain_start_index + i] == domain.storage()[i], \"invalid domain\");\n    }\n\n    // Verify position and salary claims\n    // These are separate inputs, NOT from the JWT\n    let position_claim: BoundedVec<u8, MAX_POSITION_LENGTH> = position;\n    for i in 0..MAX_POSITION_LENGTH {\n        assert(position_claim.storage()[i] == position.storage()[i], \"invalid position\");\n    }\n\n    let salary_claim: BoundedVec<u8, MAX_SALARY_LENGTH> = salary;\n    for i in 0..MAX_SALARY_LENGTH {\n        assert(salary_claim.storage()[i] == salary.storage()[i], \"invalid salary\");\n    }\n\n    // Verify ratings are valid (1-5)\n    verify_rating(work_life_balance);\n    verify_rating(culture_values);\n    verify_rating(career_growth);\n    verify_rating(compensation_benefits);\n    verify_rating(leadership_quality);\n    verify_rating(operational_efficiency);\n\n    // @dev - [NOTE]: The following variables are temporary variables. They are just for passing the verify_email_2048_bit_dkim() function. Thus, this should be replaced with a given \"header\" and \"body\" going forward.\n    let test_header: BoundedVec<u8, MAX_EMAIL_HEADER_LENGTH> = HEADER;\n    let test_body: BoundedVec<u8, MAX_EMAIL_BODY_LENGTH> = BODY;\n\n    // @dev - Verify an arbitrary email, which is signed by a 2048-bit RSA DKIM signature\n    let return_value: [Field; 2] = verify_email_2048_bit_dkim(\n        test_header,  // [TODO]: Should be replaced with a given \"header\" in the future.\n        //header,\n        test_body,    // [TODO]: Should be replaced with a given \"body\" in the future.\n        //body,\n        pubkey,\n        signature,\n        body_hash_index,\n        dkim_header_sequence\n    );\n\n    /// @dev - Validate to check whether a given \"position\" is included in the entire email body or not.\n    /// @dev - Compare a given \"position\" (BoundedVec<u8, MAX_POSITION_LENGTH>) and a given \"body\" (BoundedVec<u8, MAX_EMAIL_BODY_LENGTH>)\n    let is_position_found_in_email_body: bool = unsafe { is_position_found_in_email_body(position, body) };\n    assert(is_position_found_in_email_body == true, \"Position can not be found in email body\");\n\n    /// @dev - Validate to check whether a given \"salary\" is included in the entire email body or not.\n    /// @dev - Compare a given \"salary\" (BoundedVec<u8, MAX_SALARY_LENGTH>) and a given \"body\" (BoundedVec<u8, MAX_EMAIL_BODY_LENGTH>)\n    /// @dev - In the following implementation, the maximum number of sequences-matched is 5. (\"5\" is enuough for judging whether a given salary is included in the email body or not)\n    let is_salary_found_in_email_body: bool = unsafe { is_salary_found_in_email_body(salary, body) };\n    assert(is_salary_found_in_email_body == true, \"Salary can not be found in email body\");\n}\n\n\n/**\n * @notice - Get (Identify) a start index of domain in email\n */\nunconstrained fn get_domain_start_index_in_email(email: BoundedVec<u8, MAX_EMAIL_LENGTH>) -> u32 {\n    let mut domain_start_index = 0;\n    for i in 0..MAX_EMAIL_LENGTH {\n        if email.storage()[i] == (\"@\".as_bytes())[0] {\n            domain_start_index = i + 1;\n            break;\n        }\n    }\n\n    domain_start_index\n}\n\n/**\n * @dev - Validate to check whether a given \"position\" is included in the entire email body or not.\n * @dev - Compare a given \"position\" (BoundedVec<u8, MAX_POSITION_LENGTH>) and a given \"body\" (BoundedVec<u8, MAX_EMAIL_BODY_LENGTH>)\n */\nunconstrained fn is_position_found_in_email_body(\n    position: BoundedVec<u8, MAX_POSITION_LENGTH>, \n    body: BoundedVec<u8, MAX_EMAIL_BODY_LENGTH>\n) -> bool {\n    /// @dev - Logging\n    let position_storage = position.storage(); \n    let body_storage = body.storage(); \n    println(f\"position.storage(): {position_storage}\\n\");\n    println(f\"body.storage(): {body_storage}\\n\");\n\n    /// @dev - Look for \"position\" in \"email_body\"\n    let mut is_position_found_in_email_body: bool = false;\n    for i in 0..body.len() {\n        if (position.storage()[0] == body.storage()[i]) {\n            if (position.len() == 1) { // @dev - The position and the sentence in the Email Body would completely be matched - In the case that the number of vectors of \"position\" is \"1\". \n                is_position_found_in_email_body = true;\n                break;\n            }\n\n            let mut position_array: Vec<u8> = Vec::new();\n            //let mut position_array: BoundedVec<Field, position.len()> = BoundedVec::new();\n            for j in 1..position.len() {\n                if (position.storage()[j] == body.storage()[i+j]) {\n                    /// @dev - Logging\n                    position_array.push(position.storage()[j]);\n                    println(f\"position_array: {position_array}\\n\");\n\n                    /// @dev - Logging\n                    let position_len = position.len() - 1;\n                    let position_array_len = position_array.len();\n                    println(f\"position.len() - 1: {position_len}\\n\");\n                    println(f\"position_array.len(): {position_array_len}\\n\");\n\n                    // @dev - The position and the sentence in the Email Body would completely be matched - In the case that the number of vectors of \"position\" is \"many\" (Not \"1\"). \n                    if ((j == position.len() - 1) & (position_array.len() == position.len() - 1)) { /// @dev - Since \"j\" get started from \"1\", \"1\" should be subtracted from the position.len()\n                        is_position_found_in_email_body = true;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    is_position_found_in_email_body\n}\n\n/** \n * @dev - Validate to check whether a given \"salary\" is included in the entire email body or not.\n * @dev - Compare a given \"salary\" (BoundedVec<u8, MAX_SALARY_LENGTH>) and a given \"body\" (BoundedVec<u8, MAX_EMAIL_BODY_LENGTH>)\n * @dev - In the following implementation, the maximum number of sequences-matched is 5. (\"5\" is enuough for judging whether a given salary is included in the email body or not)\n */\nunconstrained fn is_salary_found_in_email_body(\n    salary: BoundedVec<u8, MAX_SALARY_LENGTH>, \n    body: BoundedVec<u8, MAX_EMAIL_BODY_LENGTH>\n) -> bool {\n    let mut is_salary_found_in_email_body: bool = false;\n    for i in 0..body.len() {\n        if (salary.storage()[0] == body.storage()[i]) {\n            if (salary.len() == 1) {\n                // @dev - Salary is found in the email body\n                is_salary_found_in_email_body = true;\n                break;\n            }\n\n            let mut salary_array: Vec<u8> = Vec::new();\n            //let mut salary_array: BoundedVec<Field, salary.len()> = BoundedVec::new();\n            for j in 1..salary.len() {\n                if (salary.storage()[j] == body.storage()[i+j]) {\n                    /// @dev - Logging\n                    salary_array.push(salary.storage()[j]);\n                    println(f\"salary_array: {salary_array}\\n\");\n\n                    /// @dev - Logging\n                    let salary_len = salary.len() - 1;\n                    let salary_array_len = salary_array.len();\n                    println(f\"salary.len() - 1: {salary_len}\\n\");\n                    println(f\"position_array.len(): {salary_array_len}\\n\");\n\n                    // @dev - The position and the sentence in the Email Body would completely be matched - In the case that the number of vectors of \"position\" is \"many\" (Not \"1\"). \n                    if ((j == salary.len() - 1) & (salary_array.len() == salary.len() - 1)) { /// @dev - Since \"j\" get started from \"1\", \"1\" should be subtracted from the position.len()\n                        is_salary_found_in_email_body = true;\n                        break;\n                    }\n                }\n            }\n         }\n    }\n\n    is_salary_found_in_email_body\n}","path":"/Users/unomasanori/Projects/DEMO_MVP/【Noir】NoirHack - OpenBands (zkGlassdoor 👓)/clone/OpenBands/circuit/src/main.nr"},"64":{"source":"use std::{collections::bounded_vec::BoundedVec, hash::{pedersen_hash, sha256_var}};\nuse zkemail::{dkim::RSAPubkey, headers::body_hash::get_body_hash, KEY_LIMBS_2048, Sequence};\n\nglobal MAX_EMAIL_HEADER_LENGTH: u32 = 512;\nglobal MAX_EMAIL_BODY_LENGTH: u32 = 1024;\n\n/**\n * Verify an arbitrary email signed by a 2048-bit RSA DKIM signature\n * @dev TOTAL CONSTRAINTS: ~222,783\n *\n * @param header - The email header, 0-padded at end to the MAX_EMAIL_HEADER_LENGTH\n * @param body - The email body, 0-padded at end to the MAX_EMAIL_BODY_LENGTH\n * @param pubkey - The DKIM RSA Public Key modulus and reduction parameter\n * @param signature - The DKIM RSA Signature\n * @param body_hash_index - The index of the body hash in the partial hash array\n * @param dkim_header_sequence - The index and length of the DKIM header field\n * @return - \n *         0: Pedersen hash of DKIM public key (root of trust)\n *         1: Pedersen hash of DKIM signature (email nullifier)\n */\nfn verify_email_2048_bit_dkim(\n    header: BoundedVec<u8, MAX_EMAIL_HEADER_LENGTH>,\n    body: BoundedVec<u8, MAX_EMAIL_BODY_LENGTH>,\n    pubkey: RSAPubkey<KEY_LIMBS_2048>,\n    signature: [Field; KEY_LIMBS_2048],\n    body_hash_index: u32,\n    dkim_header_sequence: Sequence,\n) -> pub [Field; 2] {\n    // check the body and header lengths are within bounds\n    assert(header.len() <= MAX_EMAIL_HEADER_LENGTH);\n    assert(body.len() <= MAX_EMAIL_BODY_LENGTH);\n\n    // ~ 86,553 constraints\n    // verify the dkim signature over the header\n    pubkey.verify_dkim_signature(header, signature);\n\n    // ~ 6,289 constraints\n    // extract the body hash from the header\n    let signed_body_hash = get_body_hash(header, dkim_header_sequence, body_hash_index);\n\n    // ~ 113,962 constraints\n    // hash the asserted body\n    let computed_body_hash: [u8; 32] = sha256_var(body.storage, body.len() as u64);\n\n    // compare the body hashes\n    assert(\n        signed_body_hash == computed_body_hash,\n        \"SHA256 hash computed over body does not match body hash found in DKIM-signed header\",\n    );\n\n    // ~ 10,255 constraints\n    // hash the pubkey and signature for the standard outputs\n    let email_nullifier = pedersen_hash(signature);\n    [pubkey.hash(), email_nullifier]\n}\n","path":"/Users/unomasanori/Projects/DEMO_MVP/【Noir】NoirHack - OpenBands (zkGlassdoor 👓)/clone/OpenBands/circuit/src/utils/email_2048_bit_dkim_verifier.nr"},"67":{"source":"mod partial_hash;\n\nuse base64::BASE64_URL_DECODER;\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse nodash::str_to_u64;\nuse partial_hash::partial_sha256_var_end;\nuse rsa::rsa::verify_sha256_pkcs1v15;\nuse sha256::sha256_var;\nuse string_search::{StringBody, SubString};\n\n/**\n * @brief Struct representing a JWT. Use the init functions to create an instance\n *        Currently only supports RSA 2048/SHA256 signatures\n **/\npub struct JWT<let MAX_DATA_LENGTH: u32> {\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    pubkey_modulus_limbs: [u128; 18],\n    redc_params_limbs: [u128; 18],\n    signature_limbs: [u128; 18],\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    is_partial_hash: bool, // compile time variable used internally\n}\n\nimpl<let MAX_DATA_LENGTH: u32> JWT<MAX_DATA_LENGTH> {\n    /**\n    * @brief Initialize JWT struct\n    *\n    * @param data: Signed JWT data (base64 encoded `$header.$payload`) as byte array of ascii characters\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Any 4x multiple from the payload start index.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs (2048-bit split into 18 limbs)\n    * @param signature_limbs: RSA signature limbs (2048-bit split into 18 limbs)\n    **/\n    pub fn init(\n        data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(data.len() <= MAX_DATA_LENGTH, \"data length is too long\");\n\n        JWT {\n            data,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            // below fields are not relevant unless for partial hash\n            full_data_length: MAX_DATA_LENGTH,\n            partial_hash: [0; 8],\n            is_partial_hash: false,\n        }\n    }\n\n    /**\n    * @brief Initialize JWT with partial SHA256 hash'ed input\n    *        Since SHA hash is expensive to compute in circuit, we can optimize by pre-hashing up to a certain block outside the circuit,\n    *        and verify for correctness in the circuit. This is possible since SHA works in incremental blocks.\n    *        You can pre-hash up to the SHA-256 block from where you want to extract a claim.\n    *\n    * @param partial_data: Signed JWT data (base64 encoded `$header.$payload`) after partial hashed block\n    * @param partial_hash: The 256-bit partial hash of the `partial_data` up to a certain block\n    * @param full_data_length: The full length of the `data` (before partial SHA)\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Trimming `offset` nubmer of bytes from the data should it base64 decode-able.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs\n    * @param signature_limbs: RSA signature limbs\n    **/\n    pub fn init_with_partial_hash(\n        partial_data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        partial_hash: [u32; 8],\n        full_data_length: u32,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(partial_data.len() <= MAX_DATA_LENGTH, \"partial_data length is too long\");\n\n        JWT {\n            data: partial_data,\n            full_data_length,\n            partial_hash,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            is_partial_hash: true,\n        }\n    }\n\n    /**\n    * @brief Verify JWT signature with RSA 2048/SHA256\n    **/\n    pub fn verify(mut self) {\n        let mut data_hash: [u8; 32] = [0; 32];\n\n        if (!self.is_partial_hash) {\n            // this is a compile time conditional\n            // Hash the data using SHA256\n            data_hash = sha256_var(self.data.storage(), self.data.len() as u64);\n        } else {\n            // Compute the full SHA256 hash with the given partial hash\n            data_hash = partial_sha256_var_end(\n                self.partial_hash,\n                self.data.storage(),\n                self.data.len() as u64,\n                self.full_data_length as u64,\n            );\n        }\n\n        // Verify RSA signature\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(false, self.pubkey_modulus_limbs, self.redc_params_limbs);\n\n        let signature = RuntimeBigNum { params, limbs: self.signature_limbs };\n\n        assert(verify_sha256_pkcs1v15(data_hash, signature, 65537));\n    }\n\n    /**\n    * @brief Get a string claim from the JWT payload\n    *\n    * @param KEY_LENGTH: The length of the claim key\n    * @param MAX_VALUE_LENGTH: The maximum length of the claim value\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        self.get_claim::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key, true)\n    }\n\n    /**\n    * @brief Assert a string claim in the JWT payload.\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: BoundedVec<u8, MAX_VALUE_LENGTH>,\n    ) {\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> =\n            self.get_claim_string::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a number (u64) claim from the JWT payload\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_number<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> u64 {\n        let claim = self.get_claim::<KEY_LENGTH, 20>(claim_key, false);\n        str_to_u64(claim.storage())\n    }\n\n    /**\n    * @brief Assert a number (u64) claim in the JWT payload.\n    *        Refer to `get_claim_number` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_number<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: u64,\n    ) {\n        let value = self.get_claim_number::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a boolean claim from the JWT payload\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_bool<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> bool {\n        let value = self.get_claim::<KEY_LENGTH, 5>(claim_key, false);\n        let mut is_true = true;\n        for i in 0..4 {\n            is_true = is_true & (value.storage()[i] == \"true\".as_bytes()[i]);\n        }\n        let is_false = value.storage() == \"false\".as_bytes();\n\n        assert(is_true | is_false, \"incorrect value for claim\");\n        is_true\n    }\n\n    /**\n    * @brief Assert a boolean claim in the JWT payload.\n    *        Refer to `get_claim_bool` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_bool<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: bool,\n    ) {\n        let value = self.get_claim_bool::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Internal function to get claim bytes from the JWT payload\n    **/\n    fn get_claim<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        //Safety: extract the value in unconstrained mode, and verify later\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> = unsafe {\n            self.extract_claim_unconstrained::<KEY_LENGTH, MAX_VALUE_LENGTH>(\n                claim_key,\n                is_value_quoted,\n            )\n        };\n\n        // constrain the extracted value is present in the payload using string_search lib\n        // haystack is the base64 decoded payload;\n        let haystack = self.prepare_haystack();\n\n        // needle is the key with quotes around it - searching for just the key string might return false positives from elsewhere\n        // Note: key length is known at compile time as this lib doesn't support runtime keys\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = claim_key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle: SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // assert value after quoted key is a colon\n        let colon_index = position + KEY_LENGTH + 2; // +2 for the quotes around the key\n        assert(haystack.body[colon_index] == 58); // :\n\n        // assert the value is correct - string have quotes around them, numbers and booleans don't\n        let mut value_start_index = colon_index + 1; // Value starts after the colon\n        let mut index_after_value = value_start_index + value.len(); // Index after the value, quoted or otherwise\n\n        if (is_value_quoted) {\n            // adjust start index for the quotes around the value\n            value_start_index = value_start_index + 1; // Adjust for the quote before the value\n            index_after_value = index_after_value + 2; // Adjust for the quotes around the value\n\n            // assert the char before and after the value is a quote\n            assert(haystack.body[value_start_index - 1] == 34); // \"\n            assert(haystack.body[index_after_value - 1] == 34); // \"\n        }\n\n        // assert the value is correct\n        for i in 0..MAX_VALUE_LENGTH {\n            if (i < value.len()) {\n                assert(haystack.body[value_start_index + i] == value.storage()[i]);\n            }\n        }\n\n        // assert the char after the value is a comma or a closing brace (last claim in the payload)\n        let char_after_value = haystack.body[index_after_value];\n        assert((char_after_value == 44) | (char_after_value == 125)); // , or }\n\n        value\n    }\n\n    /**\n    * @brief Internal function to prepare the haystack for string search (base64 decoded payload with offset applied)\n    **/\n    fn prepare_haystack(\n        self,\n    ) -> StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> {\n        // We need to decode the payload from the payload_b64_offset; i.e. data.slice(0, base64_decode_offset)\n        let mut data_to_b64_decode: [u8; MAX_DATA_LENGTH] = [0; MAX_DATA_LENGTH];\n\n        // Conditional inside the for loop blows up the constraint size\n        // So we fill the full MAX_DATA_LENGTH (rotate on overflow) and prepare a BoundedVec with the correct length later\n        for i in 0..MAX_DATA_LENGTH {\n            data_to_b64_decode[i] =\n                self.data.storage()[(i + self.base64_decode_offset) % self.data.len()];\n        }\n\n        let data_to_decode_bv: BoundedVec<u8, MAX_DATA_LENGTH> = BoundedVec::from_parts(\n            data_to_b64_decode,\n            self.data.len() - self.base64_decode_offset,\n        );\n\n        // Decode the payload\n        let payload: BoundedVec<u8, ((MAX_DATA_LENGTH / 4) * 3)> =\n            BASE64_URL_DECODER::decode_var(data_to_decode_bv); // b64 decoded length is ceil(MAX_DATA_LENGTH / 3) * 4\n\n        // Create the haystack\n        let haystack: StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> =\n            StringBody::new(payload.storage(), payload.len());\n\n        haystack\n    }\n\n    /**\n    * @brief Unconstrained function to extract claim bytes from the JWT payload\n    **/\n    pub unconstrained fn extract_claim_unconstrained<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        let haystack = self.prepare_haystack();\n\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle: SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // Get the value after the key\n        let mut value_start_idx = position + key.len() + 3; // +3 for the quote around the key and the colon\n        if (is_value_quoted) {\n            value_start_idx += 1; // +1 for the quote before the value\n        }\n\n        let mut value: BoundedVec<u8, MAX_VALUE_LENGTH> = BoundedVec::new();\n\n        for i in 0..MAX_VALUE_LENGTH {\n            let val = haystack.body[value_start_idx + i];\n            if ((val == 34) | (val == 44) | (val == 125)) {\n                break;\n            }\n            value.push(haystack.body[value_start_idx + i]);\n        }\n\n        value\n    }\n}\n\n#[test]\nfn test_verify() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_verify_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_get_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_get_claim_string_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_assert_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let value: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    jwt.assert_claim_string(\"email\".as_bytes(), value);\n}\n\n#[test]\nfn test_get_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let iat: u64 = jwt.get_claim_number(\"iat\".as_bytes());\n    let expected_iat: u64 = 1737642217;\n    assert(iat == expected_iat);\n}\n\n#[test]\nfn test_assert_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let expected_iat: u64 = 1737642217;\n    jwt.assert_claim_number(\"iat\".as_bytes(), expected_iat);\n}\n\n#[test]\nfn test_get_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email_verified: bool = jwt.get_claim_bool(\"email_verified\".as_bytes());\n    assert(email_verified);\n}\n\n#[test]\nfn test_assert_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n}\n\n#[test]\nfn test_get_last_claim() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let exp: u64 = jwt.get_claim_number(\"exp\".as_bytes()); // exp is the last claim in the test payload\n    let expected_exp: u64 = 1799999999;\n    assert(exp == expected_exp);\n}\n","path":"/Users/unomasanori/nargo/github.com/saleel/noir-jwt/v0.4.4/src/lib.nr"},"68":{"source":"// Copied form https://raw.githubusercontent.com/zkemail/zkemail.nr/refs/heads/main/lib/src/partial_hash.nr\n// Use dependency one zkemail.nr is updated to bignum 0.6.0\n\nuse std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L23\n// Convert 64-byte array to array of 16 u32s\npub fn msg_u8_to_u32(msg: [u8; BLOCK_SIZE]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L38\nunconstrained fn build_msg_block_iter<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> ([u8; BLOCK_SIZE], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L59\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32,\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE: u32 = 64;\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L86-L116\n/**\n * Partially computes a SHA256 hash of a message but does not finalize\n * @notice can be used for post-partial hashing where client proves part of hash and relies on server to finish\n * \n *\n * @param N: the length of the message to hash.\n *  --- WARNING: N must be divisible by BLOCK_SIZE such that N % BLOCK_SIZE == 0 \n *      otherwise the remaining bytes will not be inputted when computing the initial hash\n * @param msg: the preimage to begin hashing\n * @return the intermediate hash state\n */\npub fn partial_sha256_var_start<let N: u32>(msg: [u8; N]) -> [u32; 8] {\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block_iter(msg, N, msg_start) };\n        if msg_start < N {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, N, msg_block, msg_start);\n            if msg_start < N {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < N {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < N) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    h\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block_iter(msg, N, msg_start) };\n        if msg_start < N {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, N, msg_block, msg_start);\n            if msg_start < N {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < N {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < N) & (msg_byte_ptr == BLOCK_SIZE) & (msg_start < message_size) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    h\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L85\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the remaining preimage\n * @param real_message_size -= the total size of the preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u64,\n    real_message_size: u64,\n) -> [u8; 32] {\n    let message_size = message_size as u32; // noir stdlib uses u64\n    let real_message_size = real_message_size as u32; // noir stdlib uses u64\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block_iter(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block_iter(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !is_unconstrained() {\n        for i in 0..64 {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..64 {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, real_message_size) };\n\n    if !is_unconstrained() {\n        for i in 0..56 {\n            if i < msg_byte_ptr {\n                assert_eq(msg_block[i], last_block[i]);\n            } else {\n                assert_eq(msg_block[i], zero);\n            }\n        }\n\n        let len = 8 * real_message_size;\n        let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n        for i in 56..64 {\n            assert_eq(msg_block[i], len_bytes[i - 56]);\n        }\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; BLOCK_SIZE],\n    mut msg_byte_ptr: u32,\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: [u8; BLOCK_SIZE],\n    mut msg_byte_ptr: u32,\n    message_size: u32,\n) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n","path":"/Users/unomasanori/nargo/github.com/saleel/noir-jwt/v0.4.4/src/partial_hash.nr"},"70":{"source":"unconstrained fn __boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let mut r: [Field; Range] = [0; Range];\n    for i in limit..Range {\n        r[i] = 1;\n    }\n    r\n}\n\n/**\n * @brief Return a size-Range array of values that describe whether an index `i` is in the range `0<=i<limit`\n * @details When evaluating variable-length loops of size `limit`, it is neccessary to iterate over a maximum bound defined at compile-time\n *          Any constraints or evaluations that occur where `i >= limit` must be discarded.\n *          This is most efficiently performed by using predicate `Field` values, where `predicate[i] = 0` if `i < limit`, otherwise `predicate[i] = 1`.\n *          This method efficiently generates such predicate values more efficiently than querying whether `i <= limit` at every iteration.\n *          Gate cost is 3 * Range\n **/\npub fn boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let r = unsafe {\n        //@safety r contains claims about whether `r[i] >= limit`. the rest of this function checks this claim is correct\n        __boundary_check(limit)\n    };\n\n    let mut transition_index = 0;\n    // **\n    // We have an array of Field elements `r` such that:\n    // if i < limit, `r = 0`\n    // if i >= limit, `r = 1`\n    // We validate the predicate list `r` is correct by checking:\n    // 1. every r[i] element is 0 or 1\n    // 2. if r[i] = 1, r[i+1] must also be 1\n    // 3. if r[i] = 0 and r[i+1] = 1, then i == limit\n    // we check point 3 by tracking a `transition_index` variable, where\n    // transition_index += (1 - r[i]) * (r[i+1]) * i\n    // i.e. if r[i] == 0 and r[i+1] == 1, transition_index += i\n    //      else transition_index += 0\n    // NOTE: total constraint cost is 3 gates per iteration\n    // **\n    if Range > 0 {\n        for i in 0..Range - 1 {\n            assert_eq(r[i] * r[i], r[i]);\n            assert_eq(r[i] * r[i + 1], r[i]);\n            let idx = (r[i + 1] * (1 - r[i])) * (i as Field + 1);\n            transition_index = transition_index + idx;\n            std::as_witness(transition_index);\n        }\n        assert_eq(r[Range - 1] * r[Range - 1], r[Range - 1]);\n        transition_index = transition_index + (1 - r[Range - 1]) * limit as Field;\n        assert(transition_index == limit as Field);\n        r\n    } else {\n        [0; Range]\n    }\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir_base64/v0.4.0/src/boundary_check.nr"},"71":{"source":"use super::defaults::{\n    BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK, INVALID_DECODE_VALUE,\n};\n\npub use crate::boundary_check::boundary_check;\nuse crate::tables::{\n    BASE64_DECODE_BE_TABLE, BASE64_DECODE_BE_URL_TABLE, BASE64_DECODE_BE_URL_VAR_TABLE,\n    BASE64_DECODE_BE_VAR_TABLE,\n};\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64DecodeBE {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 0>(input)\n    }\n}\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64DecodeBENoPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 0>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64DecodeBEUrlSafe {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 1>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64DecodeBEUrlSafeWithPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Return a human-readable error if the input is invalid Base64\n * @details We constrain the decoding to be correct by using a lookup table to decode Base64.\n *          Validation is performed by batch-checking that no lookups returned an error state.\n *          This produces unhelpful error messages so we put this sanitised check in an unconstrained fn\n **/\nunconstrained fn __validate_decoded(decoded: Field, input_byte: u8, offset: u32) {\n    assert(\n        decoded != INVALID_DECODE_VALUE,\n        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n    );\n}\n\n/**\n * @brief Given a variable-sized number of Base64 encoded characters, return a *claim* about how many are padding chars\n * @note The returned value is only a claim and must be validated\n **/\nunconstrained fn __get_num_padding_chars_var<let InputElements: u32>(\n    input: BoundedVec<u8, InputElements>,\n) -> (bool, bool) {\n    let len = input.len();\n    let r1 = if len > 1 {\n        input.get(len - 2) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    let r2 = if len > 0 {\n        input.get(len - 1) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    (r1, r2)\n}\n\n/**\n * @brief Take an array of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\nfn decode<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; OutputBytes] {\n    let rem = OutputBytes % 3;\n    // Calculate the number of padding characters and the length of the input without padding\n    let num_padding_chars = if rem == 1 {\n        2\n    } else if rem == 2 {\n        1\n    } else {\n        0\n    };\n\n    // Assert that the output length & input length are correct\n    // Every 3 output chars will be encoded as 4 base64 input chars\n    let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n    if Pad != 0 {\n        assert(\n            encoded_length == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n        );\n        // enforce Base64 padding is valid\n        if num_padding_chars == 2 {\n            let offset = InputElements - 1;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n            let offset = InputElements - 2;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        } else if num_padding_chars == 1 {\n            let offset = InputElements - 1;\n            assert(\n                input[InputElements - 1] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        }\n    } else {\n        let expected = encoded_length - num_padding_chars;\n        assert(\n            encoded_length - num_padding_chars == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n        );\n    }\n\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n    let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    // validity_check = accumulator value that we add every output from BASE64_DECODE_BE_TABLE into.\n    // Invalid error states will return a lookup value of -2^32 , which will cause `validity_check` to fail a 32-bit range check.\n    // This batch-validation technique is more efficient than asserting every returned token is valid.\n    let mut validity_check: Field = 0;\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_TABLE[input_byte]\n                } else {\n                    BASE64_DECODE_BE_TABLE[input_byte]\n                };\n                validity_check += decoded;\n                slice += decoded as Field;\n                unsafe {\n                    //@safety get a sensible error message out if the decoding is invalid.\n                    // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                    // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                    // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                    // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        // process the final chunk, which may contain padding\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_elements_in_final_chunk = if Pad != 0 {\n            InputElements - base64_offset - num_padding_chars\n        } else {\n            InputElements - base64_offset\n        };\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_TABLE[input_byte]\n            } else {\n                BASE64_DECODE_BE_TABLE[input_byte]\n            };\n            validity_check += decoded;\n            slice += decoded as Field;\n            unsafe {\n                //@safety get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                __validate_decoded(decoded, input_byte, offset);\n            }\n        }\n\n        // If any lookups returned an error state, this 32-bit range check will fail.\n        validity_check.assert_max_bit_size::<32>();\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Take a variable-length vector of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\npub fn decode_var<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: BoundedVec<u8, InputElements>,\n) -> BoundedVec<u8, OutputBytes> {\n    // We don't know how many padding bytes the input string contains - we use an unconstrained fn to return a *claim* that we will later validate\n    let (has_first_padding_byte_claim, has_second_padding_byte_claim) = if (Pad == 1) {\n        unsafe {\n            //@safety get claims about whether the bytes input[input.len() - 2] and input[input.len() - 1] are padding chars\n            // we validate this later on by requiring these characters equal BASE64_PADDING_CHAR by looking up BASE64_DECODE_BE_VAR_TABLE\n            crate::decoder::__get_num_padding_chars_var::<InputElements>(input)\n        }\n    } else {\n        (false, false)\n    };\n\n    // num_padding_chars is a claim that depends on has_first_padding_byte_claim and has_second_padding_byte_claim being correct\n    let num_padding_chars: u32 = if Pad == 1 {\n        has_first_padding_byte_claim as u32 + has_second_padding_byte_claim as u32\n    } else {\n        0\n    };\n\n    let input_length = input.len();\n    let input = input.storage();\n\n    // boundary_flags = array of Field elements.\n    // if `i < input_length, boundary_flags[i] = 0`\n    // if `i >= input_length, boundary_flags[i+1] = 1`\n    // used as cheap(ish) predicates when iterating over bounded vector elements\n    let boundary_flags: [Field; InputElements] = boundary_check(input_length);\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n\n    let max_num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    let mut validity_check: Field = 0;\n    // if statement should be known at compile time\n    if max_num_chunks > 0 {\n        let final_chunk: u32 = max_num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n\n                let mut decode_index: Field = 0;\n                if Pad == 1 {\n                    let mut might_be_second_padding_char = 0;\n                    let mut might_be_first_padding_char = 0;\n                    // These if statements should not cost extra gates as the condition is known at compile time\n                    if (offset + 2 < InputElements) {\n                        might_be_first_padding_char = (1 - boundary_flags[offset])\n                            * (1 - boundary_flags[offset + 1])\n                            * boundary_flags[offset + 2];\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else if (offset + 1 < InputElements) {\n                        // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                        might_be_first_padding_char =\n                            (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else // last character\n                    {\n                        might_be_first_padding_char = 0;\n                        might_be_second_padding_char = (1 - boundary_flags[offset]);\n                    }\n\n                    // Cases where we need to require a padding character is present:\n                    // Case 1: we are at byte position `input.len() - 2` and `has_first_padding_byte_claim = true`\n                    // Case 2: we are at byte position `input.len() - 1` and `has_second_padding_byte_claim = true`\n                    let require_padding = might_be_first_padding_char\n                        * has_first_padding_byte_claim as Field\n                        + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n\n                    // The `decode_index` is used to map the input Base64 character into an output decoded character.\n                    // We know `input_byte` is in the range 0-255 , so we use a size 768 lookup to handle the following 3 cases:\n                    // Case 1 (index range 0-255): No special cases. We decode the Base64 ASCII char into an ASCII char\n                    // Case 2 (index range 256-511): We have exceeded the length of the input. The only valid input is 0, which decodes to 0 (all other byte values return an error state)\n                    // Case 3 (index range 512-767): A claim has been made that a padding byte is present, and we are at the appropriate byte location to check this.\n                    //                               The only valid input is BASE64_PADDING_CHAR, which decodes to 0. All other inputs return an error state\n                    decode_index =\n                        input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n                } else {\n                    decode_index = input_byte as Field + boundary_flags[offset] * 256;\n                }\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n                } else {\n                    BASE64_DECODE_BE_VAR_TABLE[decode_index]\n                };\n\n                validity_check += decoded;\n                slice += decoded;\n                unsafe {\n                    //@safety get a sensible error message out if the decoding is invalid.\n                    // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                    // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                    // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                    // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            // convert the decoded slice into bytes and populate result array\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n        // process the final chunk\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        // might include padding characters\n        let base64_elements_in_final_chunk = InputElements - base64_offset;\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n\n            let mut decode_index: Field = 0;\n            if Pad == 1 {\n                let mut might_be_second_padding_char = 0;\n                let mut might_be_first_padding_char = 0;\n                // These if statements should not cost extra gates as the condition is known at compile time\n                if (offset + 2 < InputElements) {\n                    might_be_first_padding_char = (1 - boundary_flags[offset])\n                        * (1 - boundary_flags[offset + 1])\n                        * boundary_flags[offset + 2];\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else if (offset + 1 < InputElements) {\n                    // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                    might_be_first_padding_char =\n                        (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else // last character\n                {\n                    might_be_first_padding_char = 0;\n                    might_be_second_padding_char = (1 - boundary_flags[offset]);\n                }\n\n                let require_padding = might_be_first_padding_char\n                    * has_first_padding_byte_claim as Field\n                    + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n                decode_index =\n                    input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n            } else {\n                decode_index = input_byte as Field + boundary_flags[offset] * 256;\n            }\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n            } else {\n                BASE64_DECODE_BE_VAR_TABLE[decode_index]\n            };\n            unsafe {\n                //@safety get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                __validate_decoded(decoded, input_byte, offset);\n            }\n            validity_check += decoded;\n            slice += decoded as Field;\n        }\n\n        validity_check.assert_max_bit_size::<32>();\n\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    if Pad == 1 {\n        assert(input_length % 4 == 0, \"base64 encoded strings must be a multiple of 4 bytes\");\n    }\n\n    assert_eq(\n        has_first_padding_byte_claim,\n        has_second_padding_byte_claim * has_first_padding_byte_claim,\n        \"if first byte contains padding so must the second\",\n    );\n    let output_length = ((input_length * 3) / 4) - num_padding_chars;\n    BoundedVec::from_parts_unchecked(result, output_length)\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = Base64DecodeBE::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = Base64DecodeBENoPad::decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = Base64DecodeBE::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafeWithPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let input: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result: [u8; 44] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = Base64DecodeBE::decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_empty() {\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBE::decode_var(input);\n    println(f\"result {result}\");\n    println(f\"expected {expected}\");\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 8> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 6> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    // fo\n    println(f\"result {result}, expected {expected}\");\n\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n\n    assert(result == expected);\n\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 61, offset 3\")]\nfn test_decode_var_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([47, 43, 65, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([255, 224]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var() {\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let input: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let input_no_pad: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n    // \"Hello, World!\"\n    let expected: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n\n    // all configurations should decode the same way\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    println(f\"result {result}, expected {expected}\");\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_multi_chunks() {\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir_base64/v0.4.0/src/decoder.nr"},"109":{"source":"use crate::constants::TWO_POW_120;\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n        (limbs[0] + limbs[1] * TWO_POW_120) as Field\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        (\n            limbs[0] as Field\n                + limbs[1] as Field * TWO_POW_120 as Field\n                + limbs[2] as Field * TWO_POW_120 as Field * TWO_POW_120 as Field\n        )\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(field: Field) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(field) };\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n\n        // validate that the last limb is less than the modulus\n        if N > 2 {\n            // validate that the result is less than the modulus\n            let mut grumpkin_modulus = [0; N];\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n            // validate that the limbs are in range\n            validate_in_range::<_, N, MOD_BITS>(result);\n        }\n        // validate the limbs sum up to the field value\n        let TWO_POW_120_FIELD = TWO_POW_120 as Field;\n        let field_val = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field + result[1] as Field * TWO_POW_120_FIELD\n        } else {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field\n                + result[1] as Field * TWO_POW_120_FIELD\n                + result[2] as Field * TWO_POW_120_FIELD * TWO_POW_120_FIELD\n        };\n        assert_eq(field_val, field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: u128 = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as u128 + (1 - need_more_bytes as u128));\n                limb += byte as u128 * need_more_bytes as u128;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, _, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [u128; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        // result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    predicate: bool,\n) -> [u128; N] {\n    let mut result: [u128; N] = lhs;\n    for i in 0..N {\n        // (lhs[i] - rhs[i]) * predicate + rhs[i]\n        // in case lhs < rhs, this will underflow so we have to do one extra multiplication to prevent it\n        result[i] = lhs[i] * predicate as u128 + rhs[i] * (1 - predicate as u128);\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_n *= TWO_POW_120 as Field;\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_n += params.modulus[N - i - 1] as Field;\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [u128; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [u128; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = (modulus[i] as Field - val[i] as Field);\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += (borrow_flags[0] as Field * TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] +=\n            (borrow_flags[i] as Field * TWO_POW_120 as Field - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= (borrow_flags[N - 2] as Field);\n    validate_in_range::<_, _, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, _, MOD_BITS>(result);\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] as Field - rhs[0] as Field + addend[0] - result[0] as Field - 1\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] as Field - rhs[i] as Field + addend[i]\n            - result[i] as Field\n            - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] as Field - rhs[N - 1] as Field + addend[N - 1]\n        - result[N - 1] as Field\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb = modulus[0] + (borrow_flags[0] as u128 * TWO_POW_120) - val[0] - result[0];\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] + (borrow_flags[i] as u128 * TWO_POW_120)\n                - val[i]\n                - result[i]\n                - borrow_flags[i - 1] as u128;\n            assert(result_limb == 0);\n        }\n        let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as u128;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            // __add_u128(params, lhs, rhs)\n            __add(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [u128; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] as Field + rhs[0] as Field\n            - subtrahend[0] as Field\n            - result[0] as Field\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] as Field + rhs[i] as Field\n                - subtrahend[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120 as Field;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = lhs[N - 1] as Field + rhs[N - 1] as Field\n            - subtrahend[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params, lhs, rhs) };\n\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [u128; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n            + addend[0] as Field\n            + lhs[0] as Field\n            - rhs[0] as Field\n            - result[0] as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n                + addend[i] as Field\n                + lhs[i] as Field\n                - rhs[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = addend[N - 1] as Field + lhs[N - 1] as Field\n            - rhs[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/constrained_ops.nr"},"110":{"source":"use crate::utils::split_bits;\n\nuse crate::constants::{TWO_POW_120, TWO_POW_126, TWO_POW_246};\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\n\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n    assert(remainder == [0; N]);\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] as Field * params.modulus[j] as Field;\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{246 - 120} = 2^{126}\n    let downshift: Field = 1 / (TWO_POW_120 as Field);\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits =\n        (mulout_p[0] - mulout_n[0] + (borrow_flags[0] as Field * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n    flags: [bool; M],\n) -> ([u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [u128; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [u128; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + (modulus2[j] as Field - x[i][j] as Field) as u128;\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [u128; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] as Field * rhs[k][j] as Field);\n            }\n        }\n        mulout[i] += add[i] as Field;\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout: [Field; (N * 2)] = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, k, params.modulus);\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([u128; N], [u128; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [u128; N] = params.double_modulus;\n\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i] as Field;\n                    t0[k][i] += double_modulus[i] as Field;\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i] as Field;\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i] as Field;\n                    t1[k][i] += double_modulus[i] as Field;\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i] as Field;\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i] as Field;\n                t4[i] += double_modulus[i] as Field;\n            } else {\n                t4[i] += linear_terms[j][i] as Field;\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term =\n                        t0[k][i] * t1[k][j] - quotient[i] as Field * params.modulus[j] as Field;\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j] as Field;\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] as Field * params.modulus[j] as Field;\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] as Field * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/expressions.nr"},"112":{"source":"/**\n* @brief construct a BigNum instance out of an array of bytes in BIG ENDIAN format\n* @description: each 120-bit limb represents 15 bytes, we require that the size of the byte array\n*               is precisely large enough to cover MOD_BITS\n* @param x: input byte array\n**/\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    x: [u8; NBytes],\n) -> [u128; N] {\n    let num_bits = NBytes * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result: [u128; N] = [0; N];\n\n    let excess_bytes = N * 15 - NBytes;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: u128 = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as u128;\n        k += 1;\n    }\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: u128 = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as u128;\n            k += 1;\n        }\n        result[N - i - 1] = limb;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - (NBytes * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    val: [u128; N],\n) -> [u8; NBytes] {\n    let nbytes = (MOD_BITS / 8) + (MOD_BITS % 8 != 0) as u32;\n    assert(nbytes <= NBytes);\n\n    let mut result: [u8; NBytes] = [0; NBytes];\n    for i in 0..N - 1 {\n        let limb_bytes: [u8; 15] = (val[i] as Field).to_le_bytes();\n        for j in 0..15 {\n            result[i * 15 + j] = limb_bytes[j];\n        }\n    }\n    let last_limb_bytes: [u8; 15] = (val[N - 1] as Field).to_le_bytes();\n    let num_last_bytes = (NBytes - (N - 1) * 15);\n    for i in 0..num_last_bytes {\n        result[(N - 1) * 15 + i] = last_limb_bytes[i];\n    }\n    result\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/serialization.nr"},"113":{"source":"use crate::constants::{TWO_POW_119, TWO_POW_120, TWO_POW_60};\nuse crate::fns::unconstrained_ops::{__add, __gte, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\nuse crate::utils::msb::get_msb64;\nuse crate::utils::split_bits::__normalize_limbs;\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [u128; N] {\n    let mut x = field;\n    let x_first_u128 = (x as u128);\n    let first: u128 = x_first_u128 % TWO_POW_120;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_120 as Field);\n    let x_second_u128 = (x as u128);\n    let second = x_second_u128 % TWO_POW_120;\n    x = (x - (second as Field)) / (TWO_POW_120 as Field);\n    let x_third_u128 = (x as u128);\n    let third = x_third_u128 % TWO_POW_120;\n    let mut result: [u128; N] = [0; N];\n    if N > 2 {\n        result[0] = first;\n        result[1] = second;\n        result[2] = third;\n    }\n    if N == 2 {\n        result[0] = first;\n        result[1] = second;\n    }\n    if N == 1 {\n        result[0] = first;\n    }\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [u128; N] = params.modulus;\n    flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        flags[i] = modulus[i] < val[i] + flags[i - 1] as u128;\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N]) {\n    let mut a = lhs;\n    let mut b = rhs;\n    let underflow = !__gte(lhs, rhs);\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 1;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = a[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = b[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = (borrow * TWO_POW_120 + add_term - sub_term);\n\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry as bool;\n            borrow_flags[i] = borrow as bool;\n        }\n    }\n\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> ([u128; N], [bool; N]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let sub_term = val[i] + borrow_in;\n        let borrow = (sub_term > params.modulus[i]) as u128;\n        result[i] = borrow * TWO_POW_120 + params.modulus[i] - sub_term;\n\n        borrow_in = borrow;\n        borrow_flags[i] = borrow as bool;\n    }\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N], bool) {\n    let add_res = __helper_add(lhs, rhs);\n    let overflow = __gte(add_res, params.modulus);\n\n    let mut subtrahend: [u128; N] = [0; N];\n    let mut result: [u128; N] = [0; N];\n\n    if overflow {\n        subtrahend = params.modulus;\n    }\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term = lhs[i] + rhs[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry as u128;\n\n        let sub_term = subtrahend[i] + borrow_in;\n\n        let mut borrow: u128 = (sub_term > add_term) as u128;\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow as u128;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry as bool;\n            borrow_flags[i] = borrow as bool;\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N], bool) {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let underflow = !__gte(lhs, rhs);\n    let addend: [u128; N] = if underflow { params.modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = rhs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = borrow as u128 * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry as bool;\n            borrow_flags[i] = borrow as bool;\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout_field[i + j] += x[i] as Field * redc_param[j] as Field;\n        }\n    }\n\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field, 3 * N - 1);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n    // the quotient has bunch of zero limbs now, so we can just take the first N limbs as a result\n    let mut smaller_quotient = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = __into_field_array(quotient);\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] +=\n                partial_quotient_full[i] * modulus[j] as Field;\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    let long_quotient_mul_modulus_normalized: [u128; 2 * N] =\n        __normalize_limbs(quotient_mul_modulus_normalized, 2 * N);\n    let mut quotient_mul_modulus_normalized: [u128; N] = [0; N];\n    for i in 0..N {\n        quotient_mul_modulus_normalized[i] = long_quotient_mul_modulus_normalized[i];\n    }\n\n    let mut long_remainder = __helper_sub(x, long_quotient_mul_modulus_normalized);\n    // ugly but have to remove a bunch of zeros from this\n    let mut remainder = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n    // barrett reduction is quirky so might need to remove a few modulus from the remainder\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n\n    (smaller_quotient, remainder)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let mut target = __helper_sub(params.modulus, one);\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target = __shr1(target);\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [u128; N],\n    p_minus_one_over_two: [u128; N],\n) -> (bool, [u128; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [u128; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = exped == neg_one;\n    let mut result: (bool, [u128; N]) = (found, target);\n    if (!found) {\n        let _target: [u128; N] = __add(params, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [u128; N] {\n    let mut target: [u128; N] = __one();\n    let p_minus_one_over_two = __shr1(__helper_sub(params.modulus, __one()));\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [u128; N],\n    i: u32,\n) -> u32 {\n    let one: [u128; N] = __one();\n    let is_one = t2m == one;\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let mut add_term = (val[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u8;\n    let remainder_shift = (120 - limb_shift) as u8;\n    let mask: u128 = (((1 as u128) << limb_shift) - 1) << remainder_shift;\n    result[0] = (input[0 + num_shifted_limbs] >> limb_shift);\n    for i in 1..(N - num_shifted_limbs) {\n        let value = input[i + num_shifted_limbs];\n        result[i] = value >> limb_shift;\n        let remainder: u128 = (value << remainder_shift) & mask;\n        result[i - 1] = result[i - 1] + remainder;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u8;\n    let remainder_shift: u8 = 120 - limb_shift as u8;\n\n    // 83\n    // limb shift = 1\n    // inside shift = 19 bits to the left\n    // meaning we have 19 carry bits and 41 remainder bits\n    let mask: u128 = (1 as u128 << 120) - 1;\n    //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n    let value = input[0];\n\n    let mut remainder = (value >> remainder_shift);\n    result[num_shifted_limbs] = (value << limb_shift) & mask;\n\n    // shift 84. num shifted = 1\n    for i in 1..((N) - num_shifted_limbs) {\n        let value = input[i];\n        let upshift = ((value << limb_shift) + remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = (value >> remainder_shift);\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    for i in 0..N {\n        borrow = ((rhs[i] + borrow_in) > lhs[i]) as u128;\n        let sub = (borrow << 120) + lhs[i] as u128 - rhs[i] as u128 - borrow_in;\n        result[i] = sub;\n        borrow_in = borrow;\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value = input[N - 1];\n    input[N - 1] = value >> 1;\n\n    let mut remainder = (value & 1) << 119;\n\n    for i in 1..N {\n        let value = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) + remainder;\n        remainder = (value << 119) & TWO_POW_119;\n    }\n    input\n}\n\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count = 0;\n    for i in 0..N {\n        let v = val[((N) - 1 - i)];\n        let v_low = v as u64 % TWO_POW_60 as u64;\n        let v_high = ((v - v_low as u128) / TWO_POW_60) as u64;\n        if (v_high > 0) {\n            count = 60 * ((2 * N) - 1 - (i * 2)) + get_msb64(v_high);\n            break;\n        }\n        if (v_low > 0) {\n            count = 60 * ((2 * N) - 1 - (i * 2 + 1)) + get_msb64(v_low);\n            break;\n        }\n    }\n    count\n}\n\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index = bit % 120;\n    let limb: u128 = input[segment_index];\n    let value = (limb >> uint_index as u8) & 1;\n    value == 1\n}\n\npub(crate) fn __into_field_array<let N: u32>(input: [u128; N]) -> [Field; N] {\n    let mut result: [Field; N] = [0; N];\n    for i in 0..N {\n        result[i] = input[i] as Field;\n    }\n    result\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/unconstrained_helpers.nr"},"114":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_sub, __increment,\n    __multiplicative_generator, __primitive_root_log_size, __shl, __shr,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse super::unconstrained_helpers::__shr1;\n\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> [u128; N] {\n    let f: [u128; N] = limbs;\n    __helper_sub(params.modulus, f)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    // check if the result is greater than the modulus\n    if __gte(result, params.modulus) {\n        __helper_sub(result, params.modulus)\n    } else {\n        result\n    }\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += (lhs[i] as Field * rhs[j] as Field);\n        }\n    }\n    let to_reduce: [u128; (N * 2)] = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    // ([0; N], [0; N])\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n\n    let b = divisor;\n    let numerator_msb = __get_msb(numerator);\n    let divisor_msb = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = __get_msb(remainder) - __get_msb(divisor);\n        let mut accumulator: [u128; N] = __one();\n        let mut divisor = __shl(divisor, bit_difference);\n        accumulator = __shl(accumulator, bit_difference);\n\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor); // >>= 1;\n            accumulator = __shr1(accumulator); //  >>= 1;\n        }\n\n        (quotient, remainder)\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one = __one();\n    let exp = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let x = exponent;\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [u128; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if __get_bit(x, num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]; M] = std::mem::zeroed();\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]],\n) -> [[u128; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one = __one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let Q = __shr(\n        __helper_sub(params.modulus, one),\n        primitive_root_log_size - 1,\n    );\n    let two = __helper_add(one, one);\n    let Q_minus_one_over_two = __shr(__helper_sub(Q, two), 2);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [u128; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __gte<let N: u32, let MOD_BITS: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let mut result = false;\n    let mut early_exit = false;\n    for i in 0..(N) {\n        let idx = (N) - 1 - i;\n        if (rhs[idx] == lhs[idx]) {\n            continue;\n        }\n\n        result = rhs[idx] < lhs[idx];\n        early_exit = true;\n        break;\n    }\n    if early_exit {\n        result\n    } else {\n        lhs[0] == rhs[0]\n    }\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/unconstrained_ops.nr"},"116":{"source":"pub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [u128; N],\n\n    // @brief double_modulus: used when performing negations and subtractions\n    // @note we borrow 1 from the last limb. This is for easing up the operations that might underflow\n    pub double_modulus: [u128; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [u128; N],\n}\n\n// To be implemented by the user for any BigNum they define, or within the predefined BigNums in the `fields/` dir.\npub trait BigNumParamsGetter<let N: u32, let MOD_BITS: u32> {\n    fn get_params() -> BigNumParams<N, MOD_BITS>;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [u128; N],\n        redc_param: [u128; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [u128; N]) -> [u128; N] {\n    let TWO_POW_120: u128 = 0x1000000000000000000000000000000;\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (modulus[i] + modulus[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/params.nr"},"117":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, is_zero, mul, neg,\n        sub, udiv, udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::ops::Neg;\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [u128; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {\n\n    pub fn zero(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [u128; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::zero(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [u128]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [u128; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    pub fn from_be_bytes<let NBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        x: [u8; NBytes],\n    ) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x), params }\n    }\n\n    pub fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    pub fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    pub fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    pub fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    pub fn get_limbs(self) -> [u128; N] {\n        self.limbs\n    }\n\n    pub fn get_limb(self, idx: u32) -> u128 {\n        self.limbs[idx]\n    }\n\n    pub fn set_limb(&mut self, idx: u32, value: u128) {\n        self.limbs[idx] = value;\n    }\n\n    pub unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    pub unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs =\n            unsafe { __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn| Self::get_limbs(bn))) };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // Note: can't return a slice from this unconstrained to a constrained function.\n    pub unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs = {\n            let inv_slice =\n                __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn| Self::get_limbs(bn)));\n            inv_slice.as_array()\n        };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let (q_limbs, r_limbs) = unsafe {\n            __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n                params,\n                map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                lhs_flags,\n                map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                rhs_flags,\n                map(linear_terms, |bn| Self::get_limbs(bn)),\n                linear_flags,\n            )\n        };\n        (Self { limbs: q_limbs, params }, Self { limbs: r_limbs, params })\n    }\n\n    pub fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| Self::get_limbs(bn)),\n            linear_flags,\n        )\n    }\n\n    pub fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    pub fn validate_in_range(self) {\n        validate_in_range::<_, _, MOD_BITS>(self.limbs);\n    }\n\n    pub fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    pub fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    pub fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let params = lhs.params;\n        assert(params == rhs.params);\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate), params }\n    }\n\n    pub fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/runtime_bignum.nr"},"124":{"source":"use crate::constants::TWO_POW_120;\n\nunconstrained fn split_120_bits(mut x: Field) -> (u128, u128) {\n    // Here we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low = (x as u128) % TWO_POW_120;\n    let high = ((x - low as Field) / TWO_POW_120 as Field) as u128;\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [u128; N] {\n    let mut normalized: [u128; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n        normalized[i] = lo as u128;\n        next = input[i + 1] + hi as Field;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n        normalized[range - 1] = lo as u128;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/utils/split_bits.nr"},"135":{"source":"use dep::bignum::RuntimeBigNum;\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme.\n * @note The `exponent` can be either 65537 or 3 (i.e. the most common values in use for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    assert((exponent == 3) | (exponent == 65537), \"Exponent must be 65537 or 3\");\n    let mut exponentiated = sig * sig; // sig^2\n    if exponent == 65537 {\n        // e = 65537 = 1 0000 0000 0000 0001\n        exponentiated = exponentiated * exponentiated; // sig^4\n        exponentiated = exponentiated * exponentiated; // sig^8\n        exponentiated = exponentiated * exponentiated; // sig^16\n        exponentiated = exponentiated * exponentiated; // sig^32\n        exponentiated = exponentiated * exponentiated; // sig^64\n        exponentiated = exponentiated * exponentiated; // sig^128\n        exponentiated = exponentiated * exponentiated; // sig^256\n        exponentiated = exponentiated * exponentiated; // sig^512\n        exponentiated = exponentiated * exponentiated; // sig^1024\n        exponentiated = exponentiated * exponentiated; // sig^2048\n        exponentiated = exponentiated * exponentiated; // sig^4096\n        exponentiated = exponentiated * exponentiated; // sig^8192\n        exponentiated = exponentiated * exponentiated; // sig^16384\n        exponentiated = exponentiated * exponentiated; // sig^32768\n        exponentiated = exponentiated * exponentiated; // sig^65536\n    }\n    // otherwise, e = 3 = 11\n    exponentiated = exponentiated * sig; // either sig^2 * sig = sig^3 or sig^65536 * sig = sig^65537\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\nmod tests {\n\n    use crate::types::RBN2048;\n    use super::verify_sha256_pkcs1v15;\n    use bignum::params::BigNumParams;\n    use bignum::RuntimeBigNum;\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_1024() {\n        // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170, 193,\n            96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n        ];\n\n        let params: BigNumParams<9, 1024> = BigNumParams::new(\n            false,\n            [\n                0xab238ad9cb37979a43aefbf10be8fb,\n                0x31347febe45fe8c2dac1dd30900704,\n                0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n                0x5eac6390f7873fe97ff9bb14a173ea,\n                0xbc41f700c91fd733a2c63177bbdbd4,\n                0x41442bd58769a3595b659a2ec9c6be,\n                0x4ddc91395f330382aa2e2d3fbe147,\n                0x3d008ff255a0bc71c7887f5728ba1,\n                0xb640c3a8f511c64e,\n            ],\n            [\n                0x5d53d2634c6a0918266043968ce263,\n                0x5dd4be3dce0323a492ee9340aec4db,\n                0xf82d0e2e5c8319f01a460c72c01854,\n                0x236e6fc6e62e8a1d522acda5fb3892,\n                0xdaf755619d66e580901aa224d03174,\n                0x8366291616480e7e1f202dbcedda87,\n                0x40ba1202537d1e94561ccc05265586,\n                0x69b993d857ba89ea5de9822aeb4b93,\n                0x167968c0000761a273,\n            ],\n        );\n\n        let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xc3850e84ea02da3f028ff422f4d6a9,\n                0x9761f0bd9021f76d45c60df0670a19,\n                0xc1ede421a43607ab623ed4d5a17fc8,\n                0x86197b4315206f4d53200b42555831,\n                0xe95783b69db28c26a83706f39d04cd,\n                0x18b178dc1a9ec76fb22b57e4dfa703,\n                0xdd0e19cd5a09ab48e7af4d0e3470e3,\n                0x10004dfab1cf91304e80e6baa4dfc7,\n                0x241c3fd77b90adef,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048() {\n        // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131, 166,\n            79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n                0xbfb937fc4d3cf02cc0af780f3cab44,\n                0xd20637ef7adcf5d238ee87bccc9bca,\n                0xb9db4f2663108e2f8b673f7612ae8b,\n                0x85f894ef669b36bfd3d86b0a28873,\n                0xdcc70e1884e38b8229cce3b884121d,\n                0x35488d1138e0b03e1676f7f5d8a5b3,\n                0xe1a97820e7dcbb4eab35c9b71bb273,\n                0x97d19eb3c63249ddbfcff915863f54,\n                0x3a78c7af6da0f6af0d67b1ca4b6065,\n                0xd7a3c433c020f624821e5e678c7d69,\n                0x52d5b53240feae82ffea3d2a3d9b09,\n                0xb8aad5e19e2163f68997c6fdd71906,\n                0x5db432d06e8b0bf59511100c7894e2,\n                0xadc0bbc4c54da10d1cc88438ea3127,\n                0xece1cf6a1501109cd2734d5893c8d9,\n                0x7196b90acdf06c31b1288064fd0c27,\n                0xc8,\n            ],\n            [\n                0x1b1deccf4dbde852c34a5d6908a0f,\n                0xbc9e5bdab22f023fbcca58692bccf5,\n                0x1f65439685623e45396ff55751c3bf,\n                0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n                0x5ca2e8e3048243c16c708a8030ab0d,\n                0x30079bfeb1fa51e5501581173ca19c,\n                0xff8d5f6bea485fdcc2716327f69ab4,\n                0x36b599d81589416b5b5f037986b999,\n                0x75612e34a4ff29f0a19a7823512f58,\n                0x288b6897929b54c3b26a5faa07c00f,\n                0x4b5675fa13ab7444f1f047d3eb1bbe,\n                0x6ba0ac610ef9f267ab30fe25bb1c84,\n                0xa386b48ee03168d5cea3ecb9dc901f,\n                0xacf1a01f7dba44e050c976142fb1f6,\n                0x97a63b5cb7efc60d3502946aec63cf,\n                0x12cc1d5cab10a1e9e2398d29b9e3ef,\n                0x4635cf25c66e76bba8034df46204fb,\n                0x146f,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xad29e07d16a278de49a371b9760a27,\n                0x86311920cc0e17a3c20cdff4c56dbb,\n                0x863556c6c5247dd83668dd825716ae,\n                0xc247c960945f4485b46c33b87425ca,\n                0x7326463c5c4cd5b08e21b938d9ed9a,\n                0x4f89fe0c82da08a0259eddb34d0da1,\n                0x43a74e76d4e1bd2666f1591889af0d,\n                0x240f7b80f0ff29f4253ee3019f832d,\n                0xc6edd131fbaaf725fd423dac52b362,\n                0x85f9732679242163e8afff44f6104d,\n                0xd3c3bbcb1757013fd6fb80f31dd9a6,\n                0x9008633f15df440e6df6d21ee585a2,\n                0x324df3425ed256e283be5b6b761741,\n                0xc60c1302929bd0e07caa4aeff4e8fd,\n                0x600d804ff13ba8d0e1bc9508714212,\n                0x50f7e75e5751d7edd61167027926be,\n                0x0db41d39442023e1420a8a84fe81d9,\n                0xab,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n        // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132, 239,\n            227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0xe40ee47801326543c8e84b85d567c1,\n                0x5b54ea87f0ce29de1995697b0696fd,\n                0x457078f8fdce68b437cac0970b2452,\n                0x473ec776fee3731b6ab06e35875ddc,\n                0x62dedd594e5f12c80c3ccb5791a6cd,\n                0xecb934b9d8272c5e3a418145345499,\n                0xd1af643b3d785470ed0c6cd633f706,\n                0xb58a57b9e96eccbdfc7c17f0333d4,\n                0x2ebd34b5039fc596504927c282c60d,\n                0x3a44928a74f25fc1043bb37ce4dfa8,\n                0x91448459f9617fac33a2816162ac9e,\n                0x70cb910d9f3e1a78864640ec6c8240,\n                0x9aed33f6b31f1c9de67248a98c180,\n                0x7f1416e032c79488c94b311e87bd9c,\n                0x7191b4ebb1b3fffa949fa48ed01e5,\n                0x350a75cbaeca6bfdd71ca83cdbcae9,\n                0xfb1d274fa207457c6814d42c09f9cf,\n                0xd4,\n            ],\n            [\n                0x803bf4d38110a7d37fdd05f590dee9,\n                0xa68d317c933f37cab5ab4e7c00a3b9,\n                0x476a05a536bf5f2aa1b8850146cba7,\n                0xca297ea8b5528d91d4836ff27c30ab,\n                0x75cf2eaab76eefa12bbd570f1aea9f,\n                0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n                0xd497db1f6ebe83decacaa647fabea6,\n                0x686b27ca330e25e7a7cf197f6433ef,\n                0xfde04d2225c8308b07580af0058a0f,\n                0xa29fb69777c0e916976243b2b09855,\n                0xf983592285852e7e1c2cb3ae968323,\n                0x673608017f9f5acf67a01b73728d70,\n                0xeeff82521c0bc432a05f4b7444fac0,\n                0x85a89c4d229f60aaa3aa7ac7dac1e2,\n                0xcfecff93bc9fbfe0d6dff6091f2db8,\n                0xf20f047dcb224b4447bd098c07f8c2,\n                0x554bb53cadeb3eaab911a189f90227,\n                0x133b,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa250eff812c63eaaeaa3f04641c05f,\n                0xecc09613cb8b289c1f37c8f92e6a05,\n                0x2c0a0510058360c07af65d46f594fd,\n                0x943d67513363d3de430c94a1dafe7c,\n                0x511ec8e9b10bc6c6ff0d6c232ccf92,\n                0x50ffd07b3c093b3f5fc027de847731,\n                0xc268e1489449943fdafdf89ff168c3,\n                0x0b8b7f9f49b492f78fda58d252f23a,\n                0x491c6c4ef836a6a8730b7bf81e865e,\n                0x8746c75fb079d014e419543f56d7f0,\n                0x65804c417d6168a8bc0025d255cebf,\n                0xf695e91b77890b8e3fd775fa56e627,\n                0x5e90001c0218550f4083ae28025a2f,\n                0x526bd4eff34f25f62a698f0470e0a6,\n                0x7f224306a7d9daf536b1559434c6c6,\n                0x88809f16fe1fcea3c87511d9319735,\n                0x7694685fee0bfab4a9196b92ec6f2e,\n                0xa7,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n    }\n\n    #[test]\n    fn smoke_test() {\n        // Output of `cargo run -- --msg \"hello world\"` in the `signature_gen` directory\n        // Create runtime params:\n        let modulus_limbs = [\n            0x65af46d235241cf0e8fbe8cff4abb7,\n            0xeead39ba3f377ddd5ccb2ef2085190,\n            0xe483f94c0a98e8b618d92fb926f596,\n            0x1fa8c1b2c62cca6db090cd74a29db2,\n            0xc38e22042fcb74585a7e535301f50f,\n            0xcbc4378e5212752743ae78a75a44a9,\n            0xf5acc41788d9a346a0f75630a8b2b6,\n            0xf7a741bb3ecf1aadd5a327f362abd8,\n            0x4d5f24e815db43a1b2cc2ba40f8715,\n            0xe501f1a01305cb198475a4bff0da2e,\n            0xd541b78cfbc2b314083c340840c82c,\n            0xa0ab069c26b2a0458f4c642bf72526,\n            0x2ccb676d8f22517116fee0d2340533,\n            0x7cf2a7cf772025c0a83747bbc18228,\n            0xf9475f17988a56f17b3bdf88dc72dc,\n            0x4ff228bee24415fae7a7c05771e830,\n            0x55acd96b485515c38906106cf0d189,\n            0xb9,\n        ];\n        let redc_limbs = [\n            0x172c8f156f020ad88d30fa3ba47f03,\n            0x1740a43a67cb9a7be1ac1422d77246,\n            0x2d967be1edf369834317e04856e591,\n            0x65d9fa0de5fdab598c04d9a515156a,\n            0xc6791a661ea7621db7e6c4ec48f466,\n            0xa4a1a7c06d3e8a0bcbc540c6af6788,\n            0xdcaffeb149f5bf646caa00d7355715,\n            0xb75471630a9d0fefb5cb61e66991a1,\n            0x97c041a0fc30fdff3d5ed16997da02,\n            0xbfbe7d217694b269e1ed37819c2f17,\n            0x1b44ffc3180531e2ab8bdf7848a3a9,\n            0x9f004af11132cb68bb55998ed7616a,\n            0x1b15dbbb96ce80f479724bbd768a0c,\n            0x59ba1419093ae6ed2592ffb3065867,\n            0xa35b69affa3bb3f4713f315e50b584,\n            0xa873210f83a6de0d8cbb816af3e37,\n            0xbe4fe7cf98da87ec87638030797e92,\n            0x1619,\n        ];\n\n        let signature_limbs = [\n            0x2f397c4611d4a4271453e1e50e1578,\n            0xe506a7f47c721a4943783e8ad459e6,\n            0x6cc4ae1d91cb381cba9673470999fb,\n            0x1e127364d07f94e58227f50fbf5687,\n            0xf64a2579c7189f882d68832d16faa4,\n            0x3b014b74c6c6f76f2f8af170fa0fe4,\n            0x7df41e68c86815a6fdc33968c66b67,\n            0x6a57ac06282527242fddb6ed08dbdc,\n            0xac40d37b819c4b6193f90a634e4fc7,\n            0x96606ed166a7f032d858cd40ac73a5,\n            0x8eb7d4351159a46733f92610d5c597,\n            0xc8e8e9faa9738e82dbe774a3f5cf07,\n            0x89ca84fd54ee3d5cca87c9f178375e,\n            0xdb7a1465fc76507ea498a351af70dd,\n            0x6ac6fe14f51c711f983125c776f712,\n            0x3254c17fef51bf4194a8a1674634e3,\n            0xee38c83c77c6e1ff7b70a5d9d1dd0f,\n            0x26,\n        ];\n\n        let hash: [u8; 32] = [\n            0xb9, 0x4d, 0x27, 0xb9, 0x93, 0x4d, 0x3e, 0x08, 0xa5, 0x2e, 0x52, 0xd7, 0xda, 0x7d,\n            0xab, 0xfa, 0xc4, 0x84, 0xef, 0xe3, 0x7a, 0x53, 0x80, 0xee, 0x90, 0x88, 0xf7, 0xac,\n            0xe2, 0xef, 0xcd, 0xe9,\n        ];\n\n        let has_multiplicative_inverse = false;\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(has_multiplicative_inverse, modulus_limbs, redc_limbs);\n\n        let signature: RBN2048 = RBN2048::from_array(params, signature_limbs);\n\n        assert(verify_sha256_pkcs1v15(hash, signature, 65537));\n    }\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir_rsa/v0.7.0/src/rsa.nr"},"141":{"source":"mod utils;\n\npub use utils::{conditional_select, DebugRandomEngine, lt_f};\nuse std::collections::bounded_vec::BoundedVec;\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\npub struct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    pub byte_length: u32,\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\npub struct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    pub byte_length: u32,\n}\n\npub type StringBody32 = StringBody<62, 2, 32>;\npub type StringBody64 = StringBody<93, 3, 64>;\npub type StringBody128 = StringBody<155, 5, 128>;\npub type StringBody256 = StringBody<279, 9, 256>;\npub type StringBody512 = StringBody<527, 17, 512>;\npub type StringBody1024 = StringBody<1054, 34, 1024>;\npub type StringBody2048 = StringBody<2077, 67, 2048>;\npub type StringBody4096 = StringBody<4123, 133, 4096>;\npub type StringBody8192 = StringBody<8215, 265, 8192>;\npub type StringBody16384 = StringBody<16399, 529, 16384>;\n\npub type SubString32 = SubString<62, 1, 32>;\npub type SubString64 = SubString<93, 2, 64>;\npub type SubString128 = SubString<155, 4, 128>;\npub type SubString256 = SubString<279, 8, 256>;\npub type SubString512 = SubString<527, 16, 512>;\npub type SubString1024 = SubString<1054, 33, 1024>;\n\npub trait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: Field,\n        body_chunk_offset: Field,\n        num_full_chunks: Field,\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: Field) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    pub fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes,\n            \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes,\n            \"SubString::concat, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    pub fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes,\n            \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes,\n            \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: Field) -> u8 {\n        self.body[idx as u32]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: Field,\n        starting_haystack_chunk: Field,\n        num_full_chunks: Field,\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte as Field + (i as Field * 31) + j as Field;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate: Field = lt_f(i as Field, num_full_chunks) as Field;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as Field * (i as Field + starting_haystack_chunk)];\n            assert(predicate * (lhs - rhs) == 0);\n        }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    pub fn substring_match<NeedleSubString>(self, substring: NeedleSubString) -> (bool, u32)\n    where\n        NeedleSubString: SubStringTrait,\n    {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text\n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len(),\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length,\n            \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\",\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: Field = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: Field = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks =\n            lt_f(substring_length as Field, num_bytes_in_first_chunk as Field);\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk =\n                num_full_chunks as Field * 31 + num_bytes_in_first_chunk as Field;\n\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes =\n                num_full_chunks as Field + chunk_index as Field + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index as Field;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n        when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n        a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n        Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n        The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n        If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: Field = chunk_offset as Field;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk =\n            self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: Field = i as Field;\n            let predicate: Field = lt_f(i as Field, offset_to_first_needle_byte_in_chunk) as Field;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = (1 - predicate) * (idx - offset_to_first_needle_byte_in_chunk);\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index: Field =\n                starting_needle_byte_index_of_final_chunk as Field + i as Field;\n            let predicate = lt_f(lhs_index, substring_length as Field);\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n            NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let substring_idx = (predicate as Field) * lhs_index;\n            let byte_from_substring = substring.get(substring_idx) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/\n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field\n            * (final_needle_chunk - initial_needle_chunk)\n            + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset: Field = chunk_index as Field + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk as Field,\n            body_chunk_offset,\n            num_full_chunks as Field,\n        );\n        (true, position)\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for StringBody<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n///\n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(\n    body: [u8; MaxPaddedBytes],\n) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text =\n        \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n\n#[test]\nfn test_substring_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_string_body_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn regression_20() {\n    let haystack: [u8; 128] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x92, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x6e, 0x00, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    let needle: [u8; 32] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let needle_len: u32 = 0x20;\n    let id_haystack: StringBody128 = StringBody::new(haystack, 128);\n    let pk_needle: SubString32 = SubString::new(needle, needle_len);\n    let (result, _): (bool, u32) = id_haystack.substring_match(pk_needle);\n    assert(result);\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir_string_search/v0.3.2/src/lib.nr"},"142":{"source":"pub unconstrained fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32,\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\npub unconstrained fn get_lt_predicate_f(x: Field, y: Field) -> bool {\n    let a = x as u32;\n    let b = y as u32;\n    a < b\n}\n\npub fn lt_f(x: Field, y: Field) -> bool {\n    // Safety: As `x` and `y` are known to be valid `u32`s, this function reimplements the\n    // compiler's internal implementation of `lt`\n    unsafe {\n        let predicate = get_lt_predicate_f(x, y);\n        let delta = y as Field - x as Field;\n        let lt_parameter = 2 * (predicate as Field) * delta - predicate as Field - delta;\n        lt_parameter.assert_max_bit_size::<32>();\n\n        predicate\n    }\n}\n\npub struct DebugRandomEngine {\n    pub seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = std::hash::blake3(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    pub unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir_string_search/v0.3.2/src/utils.nr"},"143":{"source":"use crate::{KEY_LIMBS_1024, KEY_LIMBS_2048, RSA_EXPONENT};\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse rsa::{rsa::verify_sha256_pkcs1v15, types::{RBN1024, RBN2048}};\nuse std::hash::{pedersen_hash, sha256_var};\n\npub struct RSAPubkey<let KEY_LIMBS: u32> {\n    modulus: [Field; KEY_LIMBS],\n    redc: [Field; KEY_LIMBS],\n}\n\nimpl<let KEY_LIMBS: u32> RSAPubkey<KEY_LIMBS> {\n\n    pub fn new(modulus: [Field; KEY_LIMBS], redc: [Field; KEY_LIMBS]) -> Self {\n        let pubkey = Self { modulus, redc };\n        pubkey\n    }\n}\n\nimpl RSAPubkey<KEY_LIMBS_1024> {\n    pub fn verify_dkim_signature<let MAX_HEADER_LENGTH: u32>(\n        self,\n        header: BoundedVec<u8, MAX_HEADER_LENGTH>,\n        signature: [Field; KEY_LIMBS_1024],\n    ) -> [u8; 32] {\n        // hash the header\n        let header_hash = sha256_var(header.storage(), header.len() as u64);\n\n        let params: BigNumParams<KEY_LIMBS_1024, 1024> =\n            BigNumParams::new(false, self.modulus, self.redc);\n\n        let signature: RBN1024 = RuntimeBigNum::from_array(params, signature);\n        signature.validate_in_range();\n\n        // verify the DKIM signature over the header\n        assert(verify_sha256_pkcs1v15(header_hash, signature, RSA_EXPONENT));\n\n        header_hash\n    }\n\n    pub fn hash(self) -> Field {\n        // validate\n        self.validate_in_range();\n        let mut dkim_preimage = [0; 9];\n        // compose first 4 limbs of modulus and redc\n        for i in 0..4 {\n            let modulus_hi = self.modulus[i * 2] * 2.pow_32(120);\n            let redc_hi = self.redc[i * 2] * 2.pow_32(120);\n            dkim_preimage[i] = modulus_hi + self.modulus[i * 2 + 1];\n            dkim_preimage[i + 4] = redc_hi + self.redc[i * 2 + 1];\n        }\n        // compose last two elements of redc and modulus together\n        let modulus_hi = self.modulus[8] * 2.pow_32(120);\n        dkim_preimage[8] = modulus_hi + self.redc[8];\n        // hash the pubkey\n        pedersen_hash(dkim_preimage)\n    }\n\n    pub fn validate_in_range(self) {\n        for i in 0..(KEY_LIMBS_1024 - 1) {\n            self.modulus[i].assert_max_bit_size::<120>();\n            self.redc[i].assert_max_bit_size::<120>();\n        }\n        self.modulus[KEY_LIMBS_1024 - 1].assert_max_bit_size::<1024 - ((KEY_LIMBS_1024 - 1) * 120)>();\n        self.redc[KEY_LIMBS_1024 - 1].assert_max_bit_size::<120>();\n    }\n}\n\nimpl RSAPubkey<KEY_LIMBS_2048> {\n    pub fn verify_dkim_signature<let MAX_HEADER_LENGTH: u32>(\n        self,\n        header: BoundedVec<u8, MAX_HEADER_LENGTH>,\n        signature: [Field; KEY_LIMBS_2048],\n    ) -> [u8; 32] {\n        // hash the header\n        let header_hash = sha256_var(header.storage(), header.len() as u64);\n\n        let params: BigNumParams<KEY_LIMBS_2048, 2048> =\n            BigNumParams::new(false, self.modulus, self.redc);\n\n        let signature: RBN2048 = RuntimeBigNum::from_array(params, signature);\n        signature.validate_in_range();\n\n        // verify the DKIM signature over the header\n        assert(verify_sha256_pkcs1v15(header_hash, signature, RSA_EXPONENT));\n\n        header_hash\n    }\n\n    pub fn hash(self) -> Field {\n        // validate range\n        self.validate_in_range();\n        let mut dkim_preimage = [0; 18];\n        // compose limbs\n        for i in 0..9 {\n            let modulus_hi = self.modulus[i * 2] * 2.pow_32(120);\n            let redc_hi = self.redc[i * 2] * 2.pow_32(120);\n            dkim_preimage[i] = modulus_hi + self.modulus[i * 2 + 1];\n            dkim_preimage[i + 9] = redc_hi + self.redc[i * 2 + 1];\n        }\n        // hash the pubkey\n        pedersen_hash(dkim_preimage)\n    }\n\n    pub fn validate_in_range(self) {\n        for i in 0..(KEY_LIMBS_2048 - 1) {\n            self.modulus[i].assert_max_bit_size::<120>();\n            self.redc[i].assert_max_bit_size::<120>();\n        }\n        self.modulus[KEY_LIMBS_2048 - 1].assert_max_bit_size::<2048 - ((KEY_LIMBS_2048 - 1) * 120)>();\n        self.redc[KEY_LIMBS_2048 - 1].assert_max_bit_size::<120>(); // we get 2053 sometimes?\n    }\n}\n","path":"/Users/unomasanori/nargo/github.com/zkemail/zkemail.nr/v0.4.3/lib/src/dkim.nr"},"144":{"source":"use crate::{\n    BODY_HASH_BASE64_LENGTH, headers::constrain_header_field, MAX_DKIM_HEADER_FIELD_LENGTH,\n    Sequence,\n};\nuse base64::BASE64_DECODER;\n\n// ON DKIM-SIGNATURE PARSING:\n// In the current version, DKIM-SIGNATURE tags are mostly ignored:\n// c= is ignored, meaning we assume the canonicalization is relaxed. This can cause denial of service issues\n// v= is ignored, meaning we do not check for a valid version of dkim signing\n// l= is ignored, meaning we otherwise constrain the body length to be safe\n// x= is ignored, meaning we accept signatures without expiration\n// sdid= is ignored, meaning that we don't explicitly bind dkim keys to exact signing domains\n// See line 42 of this file for parsing bh=;\n// You will need to implement your own parsing for the tags' expected values\n\n/**\n * Constrained access to the body hash in the header\n * \n * @param MAX_HEADER_LENGTH - The maximum length of the email header\n * @param header - The email header as validated in the DKIM signature\n * @param dkim_header_field_sequence - The sequence of the DKIM header field\n * @param body_hash_index - The index of the body hash in the header\n */\npub fn get_body_hash<let MAX_HEADER_LENGTH: u32>(\n    header: BoundedVec<u8, MAX_HEADER_LENGTH>,\n    dkim_header_field_sequence: Sequence,\n    body_hash_index: u32,\n) -> [u8; 32] {\n    // constrain the access of dkim signature field\n    let header_field_name: [u8; 14] = comptime { \"dkim-signature\".as_bytes() };\n    constrain_header_field::<MAX_HEADER_LENGTH, MAX_DKIM_HEADER_FIELD_LENGTH, 14>(\n        header,\n        dkim_header_field_sequence,\n        header_field_name,\n    );\n    // constrain access to the body hash\n    let start_range = body_hash_index > dkim_header_field_sequence.index;\n    let end_range =\n        body_hash_index + BODY_HASH_BASE64_LENGTH < dkim_header_field_sequence.end_index() + 1;\n    assert(start_range & end_range, \"Body hash index accessed outside of DKIM header field\");\n\n    // check bh prefix\n    let bh_prefix_first_no_space: [u8; 5] = comptime { \"e:bh=\".as_bytes() };\n    let bh_prefix_space: [u8; 5] = comptime { \": bh=\".as_bytes() };\n    let bh_prefix_subsequent: [u8; 5] = comptime { \"; bh=\".as_bytes() };\n    let mut found_first = true;\n    let mut found_subsequent = true;\n    for i in 0..5 {\n        let character = header.get_unchecked(body_hash_index - 5 + i);\n        let match_first_no_space = character == bh_prefix_first_no_space[i];\n        let match_first_space = character == bh_prefix_space[i];\n        let match_first = match_first_no_space | match_first_space;\n        found_first = found_first & match_first;\n        let match_subsequent = character == bh_prefix_subsequent[i];\n        found_subsequent = found_subsequent & match_subsequent;\n    }\n    assert(found_first | found_subsequent, \"No ':bh=' or '; bh=' prefix found before body hash\");\n\n    // check that bh is followed by ;\n    let bh_suffix: u8 = comptime { \";\".as_bytes()[0] };\n    assert(\n        header.get_unchecked(body_hash_index + BODY_HASH_BASE64_LENGTH) == bh_suffix,\n        \"No ';' suffix found at asserted bh index\",\n    );\n    // get the body hash\n    get_body_hash_unsafe(header, body_hash_index)\n}\n\n/**\n * Get the body hash from the header without validating the access index. Does not validate body\n * hash is valid base64 sequence (https://github.com/noir-lang/noir_base64/blob/4431d08ac661ada9d8d18b115487ff0190b43856/src/lib.nr#L209-L232)\n *\n * @param MAX_HEADER_LENGTH - The maximum length of the email header\n * @param header - The email header as validated in the DKIM signature\n * @param body_hash_index - The asserted index to find the body hash at\n */\npub fn get_body_hash_unsafe<let MAX_HEADER_LENGTH: u32>(\n    header: BoundedVec<u8, MAX_HEADER_LENGTH>,\n    body_hash_index: u32,\n) -> [u8; 32] {\n    // get the body hash\n    let mut body_hash_encoded: [u8; BODY_HASH_BASE64_LENGTH] = [0; BODY_HASH_BASE64_LENGTH];\n    for i in 0..BODY_HASH_BASE64_LENGTH {\n        body_hash_encoded[i] = header.get_unchecked(body_hash_index + i);\n    }\n    // return the decoded body hash\n    // idk why encode vs decode...\n    BASE64_DECODER.decode(body_hash_encoded)\n}\n","path":"/Users/unomasanori/nargo/github.com/zkemail/zkemail.nr/v0.4.3/lib/src/headers/body_hash.nr"},"146":{"source":"use crate::{CR, LF, Sequence};\n\npub mod body_hash;\npub mod email_address;\n\n/**\n * Constrain a sequence in a header to be within the correct bounds\n *\n * @param MAX_HEADER_LENGTH - The maximum length of the email header\n * @param MAX_HEADER_FIELD_LENGTH - The maximum length of the header field\n * @param HEADER_FIELD_NAME_LENGTH - The length of the header field name\n * @param header - The email header as validated in the DKIM signature\n * @param header_field_sequence - The sequence of the header field\n * @param header_field_name - The name of the header field\n */\nfn check_header_field_bounds<let MAX_HEADER_LENGTH: u32, let MAX_HEADER_FIELD_LENGTH: u32, let HEADER_FIELD_NAME_LENGTH: u32>(\n    header: BoundedVec<u8, MAX_HEADER_LENGTH>,\n    header_field_sequence: Sequence,\n    header_field_name: [u8; HEADER_FIELD_NAME_LENGTH],\n) {\n    // check the range of the sequence is within the header (so we can use get_unchecked)\n    let end_index = header_field_sequence.end_index();\n    assert(end_index <= header.len(), \"Header field out of bounds of header\");\n\n    // if the sequence is not the start, check for a newline\n    if header_field_sequence.index != 0 {\n        assert(\n            header.get_unchecked(header_field_sequence.index - 2) == CR,\n            \"Header field must start with CRLF\",\n        );\n        assert(\n            header.get_unchecked(header_field_sequence.index - 1) == LF,\n            \"Header field must start with CRLF\",\n        );\n    }\n\n    // if the sequence is not the end, check for a newline\n    if end_index != header.len() {\n        assert(header.get_unchecked(end_index) == CR, \"Header field must end with CRLF\");\n        assert(header.get_unchecked(end_index + 1) == LF, \"Header field must end with CRLF\");\n    }\n\n    // check that the header field name matches the expected name\n    for i in 0..HEADER_FIELD_NAME_LENGTH {\n        assert(\n            header.get_unchecked(header_field_sequence.index + i) == header_field_name[i],\n            \"Header field name does not match\",\n        );\n    }\n    assert(\n        header.get_unchecked(header_field_sequence.index + HEADER_FIELD_NAME_LENGTH) == 0x3a,\n        \"Header field name must be followed by a colon\",\n    );\n}\n\n/**\n * Constrain a sequence in a header to match the specific header field\n *\n * @param MAX_HEADER_LENGTH - The maximum length of the email header\n * @param MAX_HEADER_FIELD_LENGTH - The maximum length of the header field\n * @param HEADER_FIELD_NAME_LENGTH - The length of the header field name\n * @param header - The email header as validated in the DKIM signature\n * @param header_field_sequence - The sequence of the header field\n * @param header_field_name - The name of the header field\n */\npub fn constrain_header_field<let MAX_HEADER_LENGTH: u32, let MAX_HEADER_FIELD_LENGTH: u32, let HEADER_FIELD_NAME_LENGTH: u32>(\n    header: BoundedVec<u8, MAX_HEADER_LENGTH>,\n    header_field_sequence: Sequence,\n    header_field_name: [u8; HEADER_FIELD_NAME_LENGTH],\n) {\n    // constrain beginning of header field\n    check_header_field_bounds::<MAX_HEADER_LENGTH, MAX_HEADER_FIELD_LENGTH, HEADER_FIELD_NAME_LENGTH>(\n        header,\n        header_field_sequence,\n        header_field_name,\n    );\n\n    // check the header field is uninterrupted\n    let start_index = header_field_sequence.index + HEADER_FIELD_NAME_LENGTH + 1;\n    for i in 0..MAX_HEADER_FIELD_LENGTH {\n        // is it safe enough to cut this constraint cost in half by not checking lf? i think so\n        let index = start_index + i;\n        if (index < header_field_sequence.end_index()) {\n            assert(header.get_unchecked(index) != CR, \"Header field must not contain newlines\");\n        }\n    }\n}\n\n/**\n * constrain_header_field with checks for the last occurence of \"<\" inside the loop to save constraints\n */\npub fn constrain_header_field_detect_last_angle_bracket<let MAX_HEADER_LENGTH: u32, let MAX_HEADER_FIELD_LENGTH: u32, let HEADER_FIELD_NAME_LENGTH: u32>(\n    header: BoundedVec<u8, MAX_HEADER_LENGTH>,\n    header_field_sequence: Sequence,\n    header_field_name: [u8; HEADER_FIELD_NAME_LENGTH],\n) -> u32 {\n    // constrain beginning of header field\n    check_header_field_bounds::<MAX_HEADER_LENGTH, MAX_HEADER_FIELD_LENGTH, HEADER_FIELD_NAME_LENGTH>(\n        header,\n        header_field_sequence,\n        header_field_name,\n    );\n\n    // check the header field is uninterrupted\n    let mut last_angle_bracket = 0;\n    let start_index = header_field_sequence.index + HEADER_FIELD_NAME_LENGTH + 1;\n    for i in (HEADER_FIELD_NAME_LENGTH + 1)..MAX_HEADER_FIELD_LENGTH {\n        // is it safe enough to cut this constraint cost in half by not checking lf? i think so\n        let index = start_index + i;\n        if (index < header_field_sequence.end_index()) {\n            let byte = header.get_unchecked(index);\n            assert(byte != CR, \"Header field must not contain newlines\");\n            if byte == 0x3c {\n                last_angle_bracket = index;\n            }\n        }\n    }\n    last_angle_bracket\n}\n","path":"/Users/unomasanori/nargo/github.com/zkemail/zkemail.nr/v0.4.3/lib/src/headers/mod.nr"},"147":{"source":"use std::hash::pedersen_hash;\npub mod dkim;\npub mod headers;\npub mod masking;\npub mod partial_hash;\npub mod remove_soft_line_breaks;\npub mod utils;\nmod tests;\n\nglobal RSA_EXPONENT: u32 = 65537;\nglobal KEY_LIMBS_1024: u32 = 9;\nglobal KEY_LIMBS_2048: u32 = 18;\nglobal BODY_HASH_BASE64_LENGTH: u32 = 44;\nglobal CR: u8 = 0x0D;\nglobal LF: u8 = 0x0A;\nglobal MAX_DKIM_HEADER_FIELD_LENGTH: u32 = 300; // kinda arbitrary but gives > 100 chars for selector and domain\nglobal MAX_EMAIL_ADDRESS_LENGTH: u32 = 320; // derived via (https://datatracker.ietf.org/doc/html/rfc5321#section-4.5.3.1.1)\n\npub struct Sequence {\n    index: u32,\n    length: u32,\n}\n\nimpl Sequence {\n    pub fn end_index(self) -> u32 {\n        self.index + self.length\n    }\n}\n// allowable chars in an email address (js/src/utils:makeAllowableEmailCharsTable()\n// \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.-@\" = 1\n// \"<: \" = 2\n// \">\\r\\n\" = 3\nglobal EMAIL_ADDRESS_CHAR_TABLE: [u8; 123] = [\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 2, 0, 3, 0,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n];\n\n/**\n * Create a nullifier for a signature with a blinding factor\n *\n * @param signature - The signature to nullify\n * @param nonce - The nonce to use in the nullifier as a blinding factor\n * @return - The blinded nullifier for the signature\n */\npub fn blinded_nullifier<let KEY_LIMBS: u32>(signature: [Field; KEY_LIMBS], nonce: Field) -> Field {\n    let preimage = unsafe { __blinded_nullifier(signature, nonce) };\n    for i in 0..KEY_LIMBS {\n        assert(preimage[i] == signature[i], \"Preimage does not contain signature\");\n    }\n    assert(preimage[KEY_LIMBS] == nonce, \"Preimage does not contain nonce\");\n    pedersen_hash(preimage)\n}\n\n/**\n * Builds the nullifier preimage with a nonce\n * @notice the nonce should be governed at the app level - i.e. an aztec note can pass this in\n * \n * @param signature - The signature to nullify\n * @param nonce - The nonce to use in the nullifier as a blinding factor\n */\nunconstrained fn __blinded_nullifier<let KEY_LIMBS: u32>(\n    signature: [Field; KEY_LIMBS],\n    nonce: Field,\n) -> [Field; KEY_LIMBS + 1] {\n    let mut nullifier_preimage = [0; KEY_LIMBS + 1];\n    for i in 0..KEY_LIMBS {\n        nullifier_preimage[i] = signature[i];\n    }\n    nullifier_preimage[KEY_LIMBS] = nonce;\n\n    nullifier_preimage\n}\n","path":"/Users/unomasanori/nargo/github.com/zkemail/zkemail.nr/v0.4.3/lib/src/lib.nr"},"154":{"source":"use super::defaults::BASE64_PADDING_CHAR;\n\n/// Standard Base64 Alphabet (base64) with padding.\npub global STANDARD: Base64DecodeBE = Base64DecodeBE::new(true);\n\n/// Standard Base64 Alphabet (base64) without padding.\npub global STANDARD_NO_PAD: Base64DecodeBE = Base64DecodeBE::new(false);\n\n/// URL and Filename Safe Alphabet without padding.\npub global URL_SAFE: Base64DecodeBE = Base64DecodeBE::base64url(false);\n\n/// URL and Filename Safe Alphabet with padding.\npub global URL_SAFE_WITH_PAD: Base64DecodeBE = Base64DecodeBE::base64url(true);\n\n/// Invalid value for the lookup table.\nglobal INVALID_VALUE: u8 = 255;\n\n/// Base64 decoder for big-endian byte arrays.\n///\n/// > Note: If the lookup table is not defined in a struct, access costs are expensive and ROM\n/// tables aren't being used.\nstruct Base64DecodeBE {\n    /// The base64 lookup table.\n    table: [u8; 256],\n    /// Whether the input has padding.\n    pad: bool,\n}\n\nimpl Base64DecodeBE {\n    /// Creates a new decoder that uses the standard Base64 Alphabet (base64) specified in RFC 4648\n    /// (https://datatracker.ietf.org/doc/html/rfc4648#section-4).\n    ///\n    /// ## Value Parameters\n    ///\n    /// - `pad`: Whether the input has padding.\n    ///\n    /// ## Returns\n    ///\n    /// The Base64 decoder instance.\n    ///\n    /// ## Usage\n    ///\n    /// ```nr\n    /// let decoder = Base64DecodeBE::new(true);\n    /// ```\n    fn new(pad: bool) -> Self {\n        Base64DecodeBE {\n            table: [\n                // 0-42\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                62, // 43\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE, // 44-46\n                63, // 47\n                52,\n                53,\n                54,\n                55,\n                56,\n                57,\n                58,\n                59,\n                60,\n                61, // 48-57\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE, // 58-64\n                0,\n                1,\n                2,\n                3,\n                4,\n                5,\n                6,\n                7,\n                8,\n                9,\n                10,\n                11,\n                12,\n                13,\n                14,\n                15,\n                16,\n                17,\n                18,\n                19,\n                20,\n                21,\n                22,\n                23,\n                24,\n                25, // 65-90 (A-Z)\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE, // 91-96\n                26,\n                27,\n                28,\n                29,\n                30,\n                31,\n                32,\n                33,\n                34,\n                35,\n                36,\n                37,\n                38,\n                39,\n                40,\n                41,\n                42,\n                43,\n                44,\n                45,\n                46,\n                47,\n                48,\n                49,\n                50,\n                51, // 97-122 (a-z)\n                // 123-255\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n            ],\n            pad,\n        }\n    }\n\n    /// Creates a new decoder that uses the URL and Filename Safe Alphabet specified in RFC 4648\n    /// (https://datatracker.ietf.org/doc/html/rfc4648#section-5).\n    ///\n    /// ## Value Parameters\n    ///\n    /// - `pad`: Whether the input has padding.\n    ///\n    /// ## Returns\n    ///\n    /// The Base64 decoder instance.\n    ///\n    /// ## Usage\n    ///\n    /// ```nr\n    /// let decoder = Base64DecodeBE::base64url(true);\n    /// ```\n    fn base64url(pad: bool) -> Self {\n        Base64DecodeBE {\n            table: [\n                // 0-44 (no mapping)\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                62, // 45 (-)\n                INVALID_VALUE,\n                INVALID_VALUE, // 46-47 (no mapping)\n                52,\n                53,\n                54,\n                55,\n                56,\n                57,\n                58,\n                59,\n                60,\n                61, // 48-57 (0-9)\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE, // 58-64 (no mapping)\n                0,\n                1,\n                2,\n                3,\n                4,\n                5,\n                6,\n                7,\n                8,\n                9,\n                10,\n                11,\n                12,\n                13,\n                14,\n                15,\n                16,\n                17,\n                18,\n                19,\n                20,\n                21,\n                22,\n                23,\n                24,\n                25, // 65-90 (A-Z)\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE, // 91-94 (no mapping)\n                63, // 95 (_)\n                INVALID_VALUE, // 96 (no mapping)\n                26,\n                27,\n                28,\n                29,\n                30,\n                31,\n                32,\n                33,\n                34,\n                35,\n                36,\n                37,\n                38,\n                39,\n                40,\n                41,\n                42,\n                43,\n                44,\n                45,\n                46,\n                47,\n                48,\n                49,\n                50,\n                51, // 97-122 (a-z)\n                // 123-255\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n                INVALID_VALUE,\n            ],\n            pad,\n        }\n    }\n\n    /// Gets the lookup table value at a given index.\n    ///\n    /// ## Value Parameters\n    ///\n    /// - `idx`: The index to get the value for.\n    ///\n    /// ## Returns\n    ///\n    /// The value from the lookup table.\n    ///\n    /// ## Usage\n    ///\n    /// ```nr\n    /// let value = Base64DecodeBE::new(true).get(65);\n    /// ```\n    fn get(self, idx: Field) -> u8 {\n        self.table[idx]\n    }\n\n    /// Converts an array of ASCII values into a packed byte array of base64 values.\n    ///\n    /// > Note: Each Base64 value is 6 bits. This method will produce a byte array where data is\n    /// > concatenated so that there are no sparse bits (e.g. encoding 4 ASCII values produces 24\n    /// > bits of Base64 data = 3 bytes of output data).\n    ///\n    /// ## Type Parameters\n    ///\n    /// - `InputElements`: The number of input elements.\n    /// - `OutputBytes`: The number of output bytes.\n    ///\n    /// ## Value Parameters\n    ///\n    /// - `self`: The Base64 decoder instance.\n    /// - `input`: The input array.\n    ///\n    /// ## Constraints\n    ///\n    /// - input and output lengths are correct, including padding.\n    ///\n    /// ## Returns\n    ///\n    /// The packed byte array of base64 values.\n    ///\n    /// ## Usage\n    ///\n    /// ```nr\n    /// let result = Decoder::new(false).decode::<4, 3>([65, 66, 67, 68]);\n    /// ```\n    pub fn decode<let InputElements: u32, let OutputBytes: u32>(\n        self,\n        input: [u8; InputElements],\n    ) -> [u8; OutputBytes] {\n        let rem = OutputBytes % 3;\n        // Calculate the number of padding characters and the length of the input without padding\n        let num_padding_chars = if rem == 1 {\n            2\n        } else if rem == 2 {\n            1\n        } else {\n            0\n        };\n\n        // Assert that the output length & input length are correct\n        // Every 3 output chars will be encoded as 4 base64 input chars\n        let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n        if self.pad {\n            assert(\n                encoded_length == InputElements,\n                f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n            );\n            // enforce Base64 padding is valid\n            if num_padding_chars == 2 {\n                assert(input[InputElements - 1] == BASE64_PADDING_CHAR);\n                assert(input[InputElements - 2] == BASE64_PADDING_CHAR);\n            } else if num_padding_chars == 1 {\n                assert(input[InputElements - 1] == BASE64_PADDING_CHAR);\n            }\n        } else {\n            let expected = encoded_length - num_padding_chars;\n            assert(\n                encoded_length - num_padding_chars == InputElements,\n                f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n            );\n        }\n\n        // 240 bits fits 40 6-bit chunks and 30 8-bit chunks\n        // we pack 40 base64 values into a field element and convert into 30 bytes\n        // TODO: once we support arithmetic ops on generics, derive OutputBytes from InputBytes\n        let mut result: [u8; OutputBytes] = [0; OutputBytes];\n        let BASE64_ELEMENTS_PER_CHUNK: u32 = 40;\n        let BYTES_PER_CHUNK: u32 = 30;\n        let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n            + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n        if num_chunks > 0 {\n            let final_chunk = num_chunks - 1;\n\n            for i in 0..final_chunk {\n                let mut slice: Field = 0;\n                for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                    slice *= 64;\n                    let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                    let input_byte = input[offset];\n                    let decoded = self.get(input_byte as Field);\n                    assert(\n                        decoded != INVALID_VALUE,\n                        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n                    );\n                    slice += decoded as Field;\n                }\n                let slice_bytes: [u8; 30] = slice.to_be_bytes();\n                for j in 0..BYTES_PER_CHUNK {\n                    result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n                }\n            }\n\n            // process the final chunk, which may contain padding\n            let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n            let byte_offset = final_chunk * BYTES_PER_CHUNK;\n            let base64_elements_in_final_chunk = if self.pad {\n                InputElements - base64_offset - num_padding_chars\n            } else {\n                InputElements - base64_offset\n            };\n\n            // pack the base64 values into the field element\n            let mut slice: Field = 0;\n            for j in 0..base64_elements_in_final_chunk {\n                slice *= 64;\n                let offset = base64_offset + j;\n                let input_byte = input[offset];\n                let decoded = self.get(input_byte as Field);\n                assert(\n                    decoded != INVALID_VALUE,\n                    f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n                );\n                slice += decoded as Field;\n            }\n            for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n            }\n\n            // TODO: check is it cheaper to use a constant value in `to_be_bytes` or can we use `bytes_in_final_chunk`?\n            // extract the bytes from the Field element\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n            for i in 0..num_bytes_in_final_chunk {\n                result[byte_offset + i] = slice_bytes[i];\n            }\n        }\n\n        result\n    }\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = STANDARD.decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = STANDARD.decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = STANDARD.decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = STANDARD.decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = STANDARD_NO_PAD.decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = STANDARD_NO_PAD.decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = STANDARD_NO_PAD.decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = STANDARD.decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = STANDARD_NO_PAD.decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = URL_SAFE_WITH_PAD.decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = URL_SAFE.decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = STANDARD_NO_PAD.decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = STANDARD_NO_PAD.decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = STANDARD.decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = STANDARD.decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = URL_SAFE_WITH_PAD.decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = URL_SAFE.decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = URL_SAFE.decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = URL_SAFE.decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = STANDARD.decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = STANDARD_NO_PAD.decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = URL_SAFE_WITH_PAD.decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = URL_SAFE.decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = STANDARD.decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = STANDARD_NO_PAD.decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = URL_SAFE_WITH_PAD.decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = URL_SAFE.decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    let expected = \"The quick brown fox jumps over the lazy dog, while 42 ravens perch atop a rusty mailbox. Zany quilters fabricate 9 cozy blankets, as 3 jovial wizards expertly mix 5 potent elixirs. Bright neon signs flash \\\"OPEN 24/7\\\" in the misty night air, illuminating 8 vintage cars parked along Main Street. A gentle breeze carries the aroma of fresh coffee and warm cinnamon rolls from Joe's Diner, enticing 6 sleepy truckers to stop for a late-night snack. Meanwhile, 11 mischievous kittens playfully chase a ball of yarn across Mrs. Johnson's porch, their antics observed by 2 wise old owls perched on a nearby oak tree.\";\n\n    let input: [u8; 816] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 119, 103, 100, 50,\n        104, 112, 98, 71, 85, 103, 78, 68, 73, 103, 99, 109, 70, 50, 90, 87, 53, 122, 73, 72, 66,\n        108, 99, 109, 78, 111, 73, 71, 70, 48, 98, 51, 65, 103, 89, 83, 66, 121, 100, 88, 78, 48,\n        101, 83, 66, 116, 89, 87, 108, 115, 89, 109, 57, 52, 76, 105, 66, 97, 89, 87, 53, 53, 73,\n        72, 70, 49, 97, 87, 120, 48, 90, 88, 74, 122, 73, 71, 90, 104, 89, 110, 74, 112, 89, 50, 70,\n        48, 90, 83, 65, 53, 73, 71, 78, 118, 101, 110, 107, 103, 89, 109, 120, 104, 98, 109, 116,\n        108, 100, 72, 77, 115, 73, 71, 70, 122, 73, 68, 77, 103, 97, 109, 57, 50, 97, 87, 70, 115,\n        73, 72, 100, 112, 101, 109, 70, 121, 90, 72, 77, 103, 90, 88, 104, 119, 90, 88, 74, 48, 98,\n        72, 107, 103, 98, 87, 108, 52, 73, 68, 85, 103, 99, 71, 57, 48, 90, 87, 53, 48, 73, 71, 86,\n        115, 97, 88, 104, 112, 99, 110, 77, 117, 73, 69, 74, 121, 97, 87, 100, 111, 100, 67, 66,\n        117, 90, 87, 57, 117, 73, 72, 78, 112, 90, 50, 53, 122, 73, 71, 90, 115, 89, 88, 78, 111,\n        73, 67, 74, 80, 85, 69, 86, 79, 73, 68, 73, 48, 76, 122, 99, 105, 73, 71, 108, 117, 73, 72,\n        82, 111, 90, 83, 66, 116, 97, 88, 78, 48, 101, 83, 66, 117, 97, 87, 100, 111, 100, 67, 66,\n        104, 97, 88, 73, 115, 73, 71, 108, 115, 98, 72, 86, 116, 97, 87, 53, 104, 100, 71, 108, 117,\n        90, 121, 65, 52, 73, 72, 90, 112, 98, 110, 82, 104, 90, 50, 85, 103, 89, 50, 70, 121, 99,\n        121, 66, 119, 89, 88, 74, 114, 90, 87, 81, 103, 89, 87, 120, 118, 98, 109, 99, 103, 84, 87,\n        70, 112, 98, 105, 66, 84, 100, 72, 74, 108, 90, 88, 81, 117, 73, 69, 69, 103, 90, 50, 86,\n        117, 100, 71, 120, 108, 73, 71, 74, 121, 90, 87, 86, 54, 90, 83, 66, 106, 89, 88, 74, 121,\n        97, 87, 86, 122, 73, 72, 82, 111, 90, 83, 66, 104, 99, 109, 57, 116, 89, 83, 66, 118, 90,\n        105, 66, 109, 99, 109, 86, 122, 97, 67, 66, 106, 98, 50, 90, 109, 90, 87, 85, 103, 89, 87,\n        53, 107, 73, 72, 100, 104, 99, 109, 48, 103, 89, 50, 108, 117, 98, 109, 70, 116, 98, 50, 52,\n        103, 99, 109, 57, 115, 98, 72, 77, 103, 90, 110, 74, 118, 98, 83, 66, 75, 98, 50, 85, 110,\n        99, 121, 66, 69, 97, 87, 53, 108, 99, 105, 119, 103, 90, 87, 53, 48, 97, 87, 78, 112, 98,\n        109, 99, 103, 78, 105, 66, 122, 98, 71, 86, 108, 99, 72, 107, 103, 100, 72, 74, 49, 89, 50,\n        116, 108, 99, 110, 77, 103, 100, 71, 56, 103, 99, 51, 82, 118, 99, 67, 66, 109, 98, 51, 73,\n        103, 89, 83, 66, 115, 89, 88, 82, 108, 76, 87, 53, 112, 90, 50, 104, 48, 73, 72, 78, 117,\n        89, 87, 78, 114, 76, 105, 66, 78, 90, 87, 70, 117, 100, 50, 104, 112, 98, 71, 85, 115, 73,\n        68, 69, 120, 73, 71, 49, 112, 99, 50, 78, 111, 97, 87, 86, 50, 98, 51, 86, 122, 73, 71, 116,\n        112, 100, 72, 82, 108, 98, 110, 77, 103, 99, 71, 120, 104, 101, 87, 90, 49, 98, 71, 120, 53,\n        73, 71, 78, 111, 89, 88, 78, 108, 73, 71, 69, 103, 89, 109, 70, 115, 98, 67, 66, 118, 90,\n        105, 66, 53, 89, 88, 74, 117, 73, 71, 70, 106, 99, 109, 57, 122, 99, 121, 66, 78, 99, 110,\n        77, 117, 73, 69, 112, 118, 97, 71, 53, 122, 98, 50, 52, 110, 99, 121, 66, 119, 98, 51, 74,\n        106, 97, 67, 119, 103, 100, 71, 104, 108, 97, 88, 73, 103, 89, 87, 53, 48, 97, 87, 78, 122,\n        73, 71, 57, 105, 99, 50, 86, 121, 100, 109, 86, 107, 73, 71, 74, 53, 73, 68, 73, 103, 100,\n        50, 108, 122, 90, 83, 66, 118, 98, 71, 81, 103, 98, 51, 100, 115, 99, 121, 66, 119, 90, 88,\n        74, 106, 97, 71, 86, 107, 73, 71, 57, 117, 73, 71, 69, 103, 98, 109, 86, 104, 99, 109, 74,\n        53, 73, 71, 57, 104, 97, 121, 66, 48, 99, 109, 86, 108, 76, 103, 61, 61,\n    ];\n    let result: [u8; 610] = STANDARD.decode(input);\n    assert(result == expected.as_bytes());\n\n    let input: [u8; 814] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 119, 103, 100, 50,\n        104, 112, 98, 71, 85, 103, 78, 68, 73, 103, 99, 109, 70, 50, 90, 87, 53, 122, 73, 72, 66,\n        108, 99, 109, 78, 111, 73, 71, 70, 48, 98, 51, 65, 103, 89, 83, 66, 121, 100, 88, 78, 48,\n        101, 83, 66, 116, 89, 87, 108, 115, 89, 109, 57, 52, 76, 105, 66, 97, 89, 87, 53, 53, 73,\n        72, 70, 49, 97, 87, 120, 48, 90, 88, 74, 122, 73, 71, 90, 104, 89, 110, 74, 112, 89, 50, 70,\n        48, 90, 83, 65, 53, 73, 71, 78, 118, 101, 110, 107, 103, 89, 109, 120, 104, 98, 109, 116,\n        108, 100, 72, 77, 115, 73, 71, 70, 122, 73, 68, 77, 103, 97, 109, 57, 50, 97, 87, 70, 115,\n        73, 72, 100, 112, 101, 109, 70, 121, 90, 72, 77, 103, 90, 88, 104, 119, 90, 88, 74, 48, 98,\n        72, 107, 103, 98, 87, 108, 52, 73, 68, 85, 103, 99, 71, 57, 48, 90, 87, 53, 48, 73, 71, 86,\n        115, 97, 88, 104, 112, 99, 110, 77, 117, 73, 69, 74, 121, 97, 87, 100, 111, 100, 67, 66,\n        117, 90, 87, 57, 117, 73, 72, 78, 112, 90, 50, 53, 122, 73, 71, 90, 115, 89, 88, 78, 111,\n        73, 67, 74, 80, 85, 69, 86, 79, 73, 68, 73, 48, 76, 122, 99, 105, 73, 71, 108, 117, 73, 72,\n        82, 111, 90, 83, 66, 116, 97, 88, 78, 48, 101, 83, 66, 117, 97, 87, 100, 111, 100, 67, 66,\n        104, 97, 88, 73, 115, 73, 71, 108, 115, 98, 72, 86, 116, 97, 87, 53, 104, 100, 71, 108, 117,\n        90, 121, 65, 52, 73, 72, 90, 112, 98, 110, 82, 104, 90, 50, 85, 103, 89, 50, 70, 121, 99,\n        121, 66, 119, 89, 88, 74, 114, 90, 87, 81, 103, 89, 87, 120, 118, 98, 109, 99, 103, 84, 87,\n        70, 112, 98, 105, 66, 84, 100, 72, 74, 108, 90, 88, 81, 117, 73, 69, 69, 103, 90, 50, 86,\n        117, 100, 71, 120, 108, 73, 71, 74, 121, 90, 87, 86, 54, 90, 83, 66, 106, 89, 88, 74, 121,\n        97, 87, 86, 122, 73, 72, 82, 111, 90, 83, 66, 104, 99, 109, 57, 116, 89, 83, 66, 118, 90,\n        105, 66, 109, 99, 109, 86, 122, 97, 67, 66, 106, 98, 50, 90, 109, 90, 87, 85, 103, 89, 87,\n        53, 107, 73, 72, 100, 104, 99, 109, 48, 103, 89, 50, 108, 117, 98, 109, 70, 116, 98, 50, 52,\n        103, 99, 109, 57, 115, 98, 72, 77, 103, 90, 110, 74, 118, 98, 83, 66, 75, 98, 50, 85, 110,\n        99, 121, 66, 69, 97, 87, 53, 108, 99, 105, 119, 103, 90, 87, 53, 48, 97, 87, 78, 112, 98,\n        109, 99, 103, 78, 105, 66, 122, 98, 71, 86, 108, 99, 72, 107, 103, 100, 72, 74, 49, 89, 50,\n        116, 108, 99, 110, 77, 103, 100, 71, 56, 103, 99, 51, 82, 118, 99, 67, 66, 109, 98, 51, 73,\n        103, 89, 83, 66, 115, 89, 88, 82, 108, 76, 87, 53, 112, 90, 50, 104, 48, 73, 72, 78, 117,\n        89, 87, 78, 114, 76, 105, 66, 78, 90, 87, 70, 117, 100, 50, 104, 112, 98, 71, 85, 115, 73,\n        68, 69, 120, 73, 71, 49, 112, 99, 50, 78, 111, 97, 87, 86, 50, 98, 51, 86, 122, 73, 71, 116,\n        112, 100, 72, 82, 108, 98, 110, 77, 103, 99, 71, 120, 104, 101, 87, 90, 49, 98, 71, 120, 53,\n        73, 71, 78, 111, 89, 88, 78, 108, 73, 71, 69, 103, 89, 109, 70, 115, 98, 67, 66, 118, 90,\n        105, 66, 53, 89, 88, 74, 117, 73, 71, 70, 106, 99, 109, 57, 122, 99, 121, 66, 78, 99, 110,\n        77, 117, 73, 69, 112, 118, 97, 71, 53, 122, 98, 50, 52, 110, 99, 121, 66, 119, 98, 51, 74,\n        106, 97, 67, 119, 103, 100, 71, 104, 108, 97, 88, 73, 103, 89, 87, 53, 48, 97, 87, 78, 122,\n        73, 71, 57, 105, 99, 50, 86, 121, 100, 109, 86, 107, 73, 71, 74, 53, 73, 68, 73, 103, 100,\n        50, 108, 122, 90, 83, 66, 118, 98, 71, 81, 103, 98, 51, 100, 115, 99, 121, 66, 119, 90, 88,\n        74, 106, 97, 71, 86, 107, 73, 71, 57, 117, 73, 71, 69, 103, 98, 109, 86, 104, 99, 109, 74,\n        53, 73, 71, 57, 104, 97, 121, 66, 48, 99, 109, 86, 108, 76, 103,\n    ];\n    let result = STANDARD_NO_PAD.decode(input);\n    assert(result == expected.as_bytes());\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = STANDARD.decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir_base64/v0.3.1/src/decoder.nr"},"190":{"source":"use crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_120: Field = 0x1000000000000000000000000000000;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> Field {\n    let TWO_POW_120 = 0x1000000000000000000000000000000;\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0]\n    } else if N == 2 {\n        validate_in_range::<N, MOD_BITS>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120 + limbs[2] * TWO_POW_120 * TWO_POW_120\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    field: Field,\n) -> [Field; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result = unsafe { __from_field::<N>(field) };\n\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n\n        let TWO_POW_120 = 0x1000000000000000000000000000000;\n        // validate that the last limb is less than the modulus\n        if N > 2 {\n            // validate that the result is less than the modulus\n            let mut grumpkin_modulus = [0; N];\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n            // validate that the limbs are in range\n            validate_in_range::<N, MOD_BITS>(result);\n        }\n        // validate the limbs sum up to the field value\n        let field_val = if N < 2 {\n            result[0]\n        } else if N == 2 {\n            validate_in_range::<N, MOD_BITS>(result);\n            result[0] + result[1] * TWO_POW_120\n        } else {\n            validate_in_range::<N, MOD_BITS>(result);\n            result[0] + result[1] * TWO_POW_120 + result[2] * TWO_POW_120 * TWO_POW_120\n        };\n        assert(field_val == field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[Field; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [Field; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: Field = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as Field + (1 - need_more_bytes as Field));\n                limb += byte as Field * need_more_bytes as Field;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [Field; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [Field; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n    predicate: bool,\n) -> [Field; N] {\n    let mut result: [Field; N] = lhs;\n    for i in 0..N {\n        result[i] = (lhs[i] - rhs[i]) * predicate as Field + rhs[i];\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120;\n        r *= TWO_POW_120;\n        modulus_mod_n *= TWO_POW_120;\n        l += lhs[N - i - 1];\n        r += rhs[N - i - 1];\n        modulus_mod_n += params.modulus[N - i - 1];\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [Field; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [Field; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = modulus[i] - val[i];\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += borrow_flags[0] as Field * TWO_POW_120;\n    for i in 1..N - 1 {\n        p_minus_self[i] += (borrow_flags[i] as Field * TWO_POW_120 - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= borrow_flags[N - 2] as Field;\n    validate_in_range::<_, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N - 1) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [Field; N], rhs: [Field; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] - 1\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb =\n            modulus[0] - val[0] - result[0] + (borrow_flags[0] as Field * TWO_POW_120);\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] - val[i] - result[i] - borrow_flags[i - 1] as Field\n                + (borrow_flags[i] as Field * TWO_POW_120);\n            assert(result_limb == 0);\n        }\n        let result_limb =\n            modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __add(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [Field; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb =\n            lhs[0] + rhs[0] - subtrahend[0] - result[0] + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] + rhs[i] - subtrahend[i] - result[i] - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb =\n            lhs[N - 1] + rhs[N - 1] - subtrahend[N - 1] - result[N - 1] - borrow_sub_carry;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [Field; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb =\n            lhs[N - 1] - rhs[N - 1] + addend[N - 1] - result[N - 1] - borrow_sub_carry;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/fns/constrained_ops.nr"},"191":{"source":"use crate::utils::split_bits;\n\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * __compute_quadratic_expression_with_borrow_flags\n * __add_linear_expression\n * __compute_quadratic_expression_product\n * __compute_quadratic_expression\n * evaluate_quadratic_expression\n */\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let modulus: [Field; N] = params.modulus;\n    let modulus_bits = MOD_BITS;\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        modulus_bits,\n        modulus,\n        params.modulus_u60_x4,\n    );\n    assert(remainder == [0; N]);\n\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] * modulus[j];\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let downshift: Field = 1 / two_pow_120;\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits = (mulout_p[0] - mulout_n[0] + (borrow_flags[0] * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n    flags: [bool; M],\n) -> ([Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [Field; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [Field; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + modulus2[j] - x[i][j];\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut add: [Field; N] = [0; N];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] * rhs[k][j]);\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        k,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([Field; N], [Field; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [Field; N] = params.double_modulus;\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i];\n                    t0[k][i] += double_modulus[i];\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i];\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i];\n                    t1[k][i] += double_modulus[i];\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i];\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i];\n                t4[i] += double_modulus[i];\n            } else {\n                t4[i] += linear_terms[j][i];\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term = t0[k][i] * t1[k][j] - quotient[i] * params.modulus[j];\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j];\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] * params.modulus[j];\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/fns/expressions.nr"},"193":{"source":"/**\n* @brief construct a BigNum instance out of an array of bytes in BIG ENDIAN format\n* @description: each 120-bit limb represents 15 bytes, we require that the size of the byte array\n*               is precisely large enough to cover MOD_BITS\n* @param x: input byte array\n**/\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    x: [u8; NBytes],\n) -> [Field; N] {\n    let num_bits = NBytes * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result = [0; N];\n\n    let excess_bytes = N * 15 - NBytes;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        result[N - i - 1] = limb;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - (NBytes * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    val: [Field; N],\n) -> [u8; NBytes] {\n    let nbytes = (MOD_BITS / 8) + (MOD_BITS % 8 != 0) as u32;\n    assert(nbytes <= NBytes);\n\n    let mut result: [u8; NBytes] = [0; NBytes];\n    for i in 0..N - 1 {\n        let limb_bytes: [u8; 15] = val[i].to_le_bytes();\n        for j in 0..15 {\n            result[i * 15 + j] = limb_bytes[j];\n        }\n    }\n    let last_limb_bytes: [u8; 15] = val[N - 1].to_le_bytes();\n    let num_last_bytes = (NBytes - (N - 1) * 15);\n    for i in 0..num_last_bytes {\n        result[(N - 1) * 15 + i] = last_limb_bytes[i];\n    }\n    result\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/fns/serialization.nr"},"194":{"source":"use crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\nuse crate::fns::unconstrained_ops::{__add, __eq, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_60: u64 = 0x1000000000000000;\n\n/**\n * In this file:\n *\n * __validate_in_field_compute_borrow_flags\n * __validate_gt_remainder\n * __neg_with_flags\n * __add_with_flags\n * __sub_with_flags\n * __barrett_reduction\n * __tonelli_shanks_sqrt\n */\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [Field; N] {\n    // cast the field to a u60 representation\n    let res_u60: U60Repr<N, 2> = U60Repr::from_field(field);\n    let result: [Field; N] = U60Repr::into(res_u60);\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [Field; N] = params.modulus;\n    flags[0] = modulus[0].lt(val[0]);\n    for i in 1..N - 1 {\n        flags[i] = modulus[i].lt(val[i] + flags[i - 1] as Field);\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N]) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let mut b_u60: U60Repr<N, 2> = From::from(rhs);\n\n    let underflow = b_u60.gte(a_u60);\n    b_u60 += U60Repr::one();\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                carry_flags[i / 2] = carry as bool;\n                borrow_flags[i / 2] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> ([Field; N], [bool; N]) {\n    let x_u60: U60Repr<N, 2> = From::from(val);\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut borrow_in: u64 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let sub_term = x_u60.limbs[i] + borrow_in;\n        let borrow = (sub_term > params.modulus_u60.limbs[i]) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + params.modulus_u60.limbs[i] - sub_term;\n\n        borrow_in = borrow;\n        if ((i & 1) == 1) {\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let b_u60: U60Repr<N, 2> = From::from(rhs);\n    let add_u60 = a_u60 + b_u60;\n\n    let overflow = add_u60.gte(params.modulus_u60);\n\n    let mut subtrahend_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    if overflow {\n        subtrahend_u60 = params.modulus_u60;\n    }\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + b_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = subtrahend_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                let idx = (i - 1) / 2;\n                carry_flags[idx] = carry as bool;\n                borrow_flags[idx] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60 + U60Repr::one());\n\n    let addend_u60: U60Repr<N, 2> = if underflow {\n        params.modulus_u60\n    } else {\n        U60Repr { limbs: [0; 2 * N] }\n    };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + addend_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                carry_flags[i / 2] = carry as bool;\n                borrow_flags[i / 2] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [Field; 2 * N],\n    redc_param: [Field; N],\n    k: u32,\n    modulus: [Field; N],\n    modulus_u60: U60Repr<N, 4>,\n) -> ([Field; N], [Field; N]) {\n    // for each i in 0..(N + N), adds x[i] * redc_param[j] to mulout[i + j] for each j in 0..N\n    let mut mulout: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout[i + j] += x[i] * redc_param[j];\n        }\n    }\n\n    mulout = split_bits::__normalize_limbs(mulout, 3 * N - 1);\n    let mulout_u60: U60Repr<N, 6> = U60Repr::new(mulout);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient_u60 = mulout_u60.shr((k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = quotient_u60.into_field_array();\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] += partial_quotient_full[i] * modulus[j];\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    for i in 0..(N + N) {\n        let (lo, hi) = split_bits::split_120_bits(quotient_mul_modulus_normalized[i]);\n        quotient_mul_modulus_normalized[i] = lo;\n\n        // Propagate higher bits to the next index\n        // TODO: what is faster, leaving this if statement in or out?\n        // (array is size-1 too large so we can tolerate adding 0 into max element)\n        if (i + 1 < N + N) {\n            quotient_mul_modulus_normalized[i + 1] += hi;\n        }\n    }\n\n    let quotient_mul_modulus_u60: U60Repr<N, 4> = U60Repr::new(quotient_mul_modulus_normalized);\n    // convert the input into U60Repr\n    let x_u60: U60Repr<N, 4> = U60Repr::new(x);\n    let mut remainder_u60 = x_u60 - quotient_mul_modulus_u60;\n    // barrett reduction is quirky so might need to remove a few modulus_u60 from the remainder\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n\n    let q: [Field; N] = U60Repr::into(quotient_u60);\n    let r: [Field; N] = U60Repr::into(remainder_u60);\n\n    (q, r)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut target: U60Repr<N, 2> = params.modulus_u60 - U60Repr::one();\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target.limbs[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target.shr1();\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [Field; N],\n    p_minus_one_over_two: [Field; N],\n) -> (bool, [Field; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [Field; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = __eq(exped, neg_one);\n    let mut result: (bool, [Field; N]) = (found, target);\n    if (!found) {\n        let _target = __add(params, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [Field; N] {\n    let mut target: [Field; N] = __one();\n    let p_minus_one_over_two: U60Repr<N, 2> = (params.modulus_u60 - U60Repr::one()).shr(1);\n    let p_minus_one_over_two: [Field; N] = U60Repr::into(p_minus_one_over_two);\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [Field; N],\n    i: u32,\n) -> u32 {\n    let one: [Field; N] = __one();\n    let is_one = __eq(t2m, one);\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/fns/unconstrained_helpers.nr"},"195":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __multiplicative_generator, __primitive_root_log_size,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\n/**\n * In this file:\n *\n * __one\n * __derive_from_seed\n * __eq\n * __is_zero\n * __neg\n * __add\n * __sub\n * __mul_with_quotient\n * __mul\n * __div\n * __udiv_mod\n * __invmod\n * __pow\n * __batch_invert\n * __batch_invert_slice\n */\n\npub(crate) unconstrained fn __one<let N: u32>() -> [Field; N] {\n    let mut limbs: [Field; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [Field; N], rhs: [Field; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [Field; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> [Field; N] {\n    let f: [Field; N] = limbs;\n    let x_u60: U60Repr<N, 2> = U60Repr::from(f);\n    U60Repr::into(params.modulus_u60 - x_u60)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let x_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let y_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let mut z_u60 = x_u60 + y_u60;\n\n    if z_u60.gte(params.modulus_u60) {\n        z_u60 = z_u60 - params.modulus_u60;\n    }\n    U60Repr::into(z_u60)\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += lhs[i] * rhs[j];\n        }\n    }\n    let to_reduce = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(\n        to_reduce,\n        params.redc_param,\n        MOD_BITS,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    let inv_divisor = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut quotient_u60: U60Repr<N, 2> = U60Repr::from([0; N]);\n    let mut remainder_u60: U60Repr<N, 2> = U60Repr::from(numerator);\n\n    let mut divisor_u60: U60Repr<N, 2> = U60Repr::from(divisor);\n    let b = divisor_u60;\n\n    let mut bit_difference = remainder_u60.get_msb() - divisor_u60.get_msb();\n\n    let mut accumulator_u60: U60Repr<N, 2> = U60Repr::one();\n    divisor_u60 = divisor_u60.shl(bit_difference);\n    accumulator_u60 = accumulator_u60.shl(bit_difference);\n\n    if (divisor_u60.gte(remainder_u60 + U60Repr::one())) {\n        divisor_u60.shr1();\n        accumulator_u60.shr1();\n    }\n    for _ in 0..(N * 120) {\n        if (remainder_u60.gte(b) == false) {\n            break;\n        }\n\n        // we've shunted 'divisor' up to have the same bit length as our remainder.\n        // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n        if (remainder_u60.gte(divisor_u60)) {\n            remainder_u60 -= divisor_u60;\n            // we can use OR here instead of +, as\n            // accumulator is always a nice power of two\n            quotient_u60 = quotient_u60 + accumulator_u60;\n        }\n        divisor_u60.shr1(); // >>= 1;\n        accumulator_u60.shr1(); //  >>= 1;\n    }\n\n    (U60Repr::into(quotient_u60), U60Repr::into(remainder_u60))\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let exp_u60 = params.modulus_u60 - (one_u60 + one_u60);\n    let exp = U60Repr::into(exp_u60);\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n    exponent: [Field; N],\n) -> [Field; N] {\n    let x: U60Repr<N, 2> = U60Repr::from(exponent);\n\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [Field; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if x.get_bit(num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n) -> [[Field; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]; M] = [[0; N]; M];\n    let mut temporaries: [[Field; N]; N] = std::mem::zeroed();\n    for i in 0..N {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..N {\n        let idx = N - 1 - i;\n        if (!__is_zero(x[idx])) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]],\n) -> [[Field; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]] = [[0; N]];\n    let mut temporaries: [[Field; N]; N] = std::mem::zeroed();\n    for i in 0..N {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n        result = result.push_back([0; N]);\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (__is_zero(x[idx]) == false) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [Field; N],\n) -> std::option::Option<[Field; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let mut Q = (params.modulus_u60 - one_u60).shr(primitive_root_log_size - 1);\n    let Q_minus_one_over_two_u60 = (Q - one_u60).shr(2);\n    let Q_minus_one_over_two: [Field; N] = U60Repr::into(Q_minus_one_over_two_u60);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [Field; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    let one: [Field; N] = __one::<N>();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/fns/unconstrained_ops.nr"},"197":{"source":"use crate::utils::u60_representation::U60Repr;\n\npub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [Field; N],\n\n    // @brief modulus but represented in a U60Repr form\n    pub modulus_u60: U60Repr<N, 2>,\n    pub modulus_u60_x4: U60Repr<N, 4>,\n\n    // @brief double_modulus: used when performing negations and subtractions\n    pub double_modulus: [Field; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [Field; N],\n}\n\n// To be implemented by the user for any BigNum they define, or within the predefined BigNums in the `fields/` dir.\npub trait BigNumParamsGetter<let N: u32, let MOD_BITS: u32> {\n    pub fn get_params() -> BigNumParams<N, MOD_BITS>;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [Field; N],\n        redc_param: [Field; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            modulus_u60: U60Repr::from(modulus),\n            modulus_u60_x4: U60Repr::from(modulus),\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.modulus_u60 == other.modulus_u60)\n            & (self.modulus_u60_x4 == other.modulus_u60_x4)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [Field; N]) -> [Field; N] {\n    let TWO_POW_120: Field = 0x1000000000000000000000000000000;\n    let m: U60Repr<N, 2> = U60Repr::from(modulus);\n    let mut result: [Field; N] = U60Repr::into(m + m);\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/params.nr"},"198":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, is_zero, mul, neg,\n        sub, udiv, udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [Field; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\npub(crate) trait RuntimeBigNumTrait<let N: u32, let MOD_BITS: u32>: Neg + Add + Sub + Mul + Div + Eq {\n    pub fn new(params: BigNumParams<N, MOD_BITS>) -> Self;\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self;\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self;\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self;\n    pub fn from_be_bytes<let NBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        x: [u8; NBytes],\n    ) -> Self;\n\n    pub fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes];\n\n    pub fn modulus(self) -> Self;\n    pub fn modulus_bits() -> u32;\n    pub fn num_limbs() -> u32;\n    // pub fn get(self) -> [Field];\n    pub fn get_limbs(self) -> [Field; N];\n    pub fn get_limb(self, idx: u32) -> Field;\n    pub fn set_limb(&mut self, idx: u32, value: Field);\n\n    unconstrained fn __eq(self, other: Self) -> bool;\n    unconstrained fn __is_zero(self) -> bool;\n\n    // unconstrained\n    pub fn __neg(self) -> Self;\n    // unconstrained\n    pub fn __add(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __sub(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __mul(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __div(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    // unconstrained\n    pub fn __invmod(self) -> Self;\n    // unconstrained\n    pub fn __pow(self, exponent: Self) -> Self;\n\n    // unconstrained\n    pub fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M];\n    unconstrained fn __batch_invert_slice<let M: u32>(to_invert: [Self]) -> [Self];\n\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n\n    // unconstrained\n    pub fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self);\n\n    pub fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    );\n\n    pub fn eq(lhs: Self, rhs: Self) -> bool {\n        lhs == rhs\n    }\n    pub fn assert_is_not_equal(self, other: Self);\n    pub fn validate_in_field(self);\n    pub fn validate_in_range(self);\n    // pub fn validate_gt(self, lhs: Self, rhs: Self);\n\n    pub fn udiv_mod(numerator: Self, divisor: Self) -> (Self, Self);\n    pub fn udiv(numerator: Self, divisor: Self) -> Self;\n    pub fn umod(numerator: Self, divisor: Self) -> Self;\n\n    pub fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self;\n    pub fn is_zero(self) -> bool;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNumTrait<N, MOD_BITS> for RuntimeBigNum<N, MOD_BITS> {\n\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [Field; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::new(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x), params }\n    }\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    fn get_limbs(self) -> [Field; N] {\n        self.limbs\n    }\n\n    fn get_limb(self, idx: u32) -> Field {\n        self.limbs[idx]\n    }\n\n    fn set_limb(&mut self, idx: u32, value: Field) {\n        self.limbs[idx] = value;\n    }\n\n    unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs =\n            unsafe { __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn| Self::get_limbs(bn))) };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // Note: can't return a slice from this unconstrained to a constrained function.\n    unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs = {\n            let inv_slice =\n                __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn| Self::get_limbs(bn)));\n            inv_slice.as_array()\n        };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let (q_limbs, r_limbs) = unsafe {\n            __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n                params,\n                map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                lhs_flags,\n                map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                rhs_flags,\n                map(linear_terms, |bn| Self::get_limbs(bn)),\n                linear_flags,\n            )\n        };\n        (Self { limbs: q_limbs, params }, Self { limbs: r_limbs, params })\n    }\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| Self::get_limbs(bn)),\n            linear_flags,\n        )\n    }\n\n    fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    fn validate_in_range(self) {\n        validate_in_range::<_, MOD_BITS>(self.limbs);\n    }\n\n    fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let params = lhs.params;\n        assert(params == rhs.params);\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate), params }\n    }\n\n    fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/runtime_bignum.nr"},"205":{"source":"global TWO_POW_56: u64 = 0x100000000000000;\npub(crate) global TWO_POW_60: u64 = 0x1000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n//fields to u60rep conversion\n// field elements are 254 bits\n// so there will be 5 limbs\npub(crate) unconstrained fn field_to_u60rep(mut x: Field) -> (u64, u64, u64, u64, u64) {\n    // get the first 60 bits by casting to u64 and then taking the lower 60 bits\n    // we use the fact that this casting drops everything above 64 bits\n    let x_first_u64 = (x as u64);\n    let first: u64 = x_first_u64 % TWO_POW_60;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_60 as Field);\n    let x_second_u64 = (x as u64);\n    let second = x_second_u64 % TWO_POW_60;\n    x = (x - (second as Field)) / (TWO_POW_60 as Field);\n    let x_third_u64 = (x as u64);\n    let third = x_third_u64 % TWO_POW_60;\n    x = (x - (third as Field)) / (TWO_POW_60 as Field);\n    let x_fourth_u64 = (x as u64);\n    let fourth = x_fourth_u64 % TWO_POW_60;\n    x = (x - (fourth as Field)) / (TWO_POW_60 as Field);\n    let x_fifth_u64 = (x as u64);\n    let fifth = x_fifth_u64 % TWO_POW_60;\n    (first, second, third, fourth, fifth)\n}\n\n// Decomposes a single field into two 120 bit fields\npub unconstrained fn split_120_bits(mut x: Field) -> (Field, Field) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_56 = ((x as u64) % TWO_POW_56) as Field;\n\n    let low = low_lower_64 + TWO_POW_64 * low_upper_56;\n    let high = (x - low_upper_56) / TWO_POW_56 as Field;\n\n    (low, high)\n}\n\n/// Decomposes a single field into two 60 bit fields\n///\n/// Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\nunconstrained fn __split_60_bits(x: Field) -> (u64, u64) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let x_lower_64 = (x as u64);\n    let low = x_lower_64 % TWO_POW_60;\n    let high = ((x - (low as Field)) / TWO_POW_60 as Field) as u64;\n\n    (low, high)\n}\n\n/// Decomposes a single field into two 60 bit fields\n///\n/// Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\npub fn split_60_bits(x: Field) -> (u64, u64) {\n    // We assert that the two returned limbs fit within 60 bits each\n    // and reconstruct `x` when added together.\n    let (lo, hi) = unsafe { __split_60_bits(x) };\n    if !std::runtime::is_unconstrained() {\n        let lo_field = lo as Field;\n        let hi_field = hi as Field;\n        lo_field.assert_max_bit_size::<60>();\n        hi_field.assert_max_bit_size::<60>();\n        assert_eq(lo_field + (TWO_POW_60 as Field) * hi_field, x);\n    }\n\n    (lo, hi)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [Field; N] {\n    let mut normalized: [Field; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[i] = lo;\n        next = input[i + 1] + hi;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n        normalized[range - 1] = lo;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/utils/split_bits.nr"},"206":{"source":"use crate::utils::msb::get_msb64;\nuse crate::utils::split_bits;\nuse crate::utils::split_bits::{field_to_u60rep, TWO_POW_60};\n\n/**\n * @brief U60Repr represents a BigNum element as a sequence of 60-bit unsigned integers.\n *\n * @description: used in unconstrained functions when computing witness values.\n * It is helpful to use u60 types when evaluating addition operations that can overflow the field modulus,\n * as well as when performing bit shifts.\n */\npub struct U60Repr<let N: u32, let NumSegments: u32> {\n    pub(crate) limbs: [u64; N * NumSegments],\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Add for U60Repr<N, NumSegments> {\n    fn add(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut carry: u64 = 0;\n        for i in 0..N * NumSegments {\n            let mut add: u64 = self.limbs[i] + b.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            result.limbs[i] = add;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Sub for U60Repr<N, NumSegments> {\n    fn sub(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        for i in 0..N * NumSegments {\n            borrow = ((b.limbs[i] + borrow_in) > self.limbs[i]) as u64;\n            let sub = (borrow << 60) + self.limbs[i] - b.limbs[i] - borrow_in;\n            result.limbs[i] = sub;\n            borrow_in = borrow;\n        }\n\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::From<[Field; N]> for U60Repr<N, NumSegments> {\n    fn from(input: [Field; N]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..N {\n            let (lo, hi) = split_bits::split_60_bits(input[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n}\n\n// impl<let N: u32, let NumSegments: u32> std::convert::From<Field> for U60Repr<N, NumSegments> {\n//     fn from(input: Field) -> Self {\n//        let (low, mid, high) =  unsafe { field_to_u60rep(input) } ;\n//         let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n//         let N_u60: u32 = N * NumSegments;\n//         assert(N_u60 >=1, \"N must be at least 1\");\n//         if N_u60 == 1 {\n//             assert((mid ==0) & (high == 0), \"input field is too large to fit in a single limb\");\n//             result.limbs[0] = low;\n//         }\n//         else if N_u60 == 2{\n//             assert(high == 0, \"input field is too large to fit in two limbs\");\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//         }else{\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//             result.limbs[2] = high;\n//         }\n//         result\n//     }\n// }\n\nimpl<let N: u32, let NumSegments: u32> std::convert::Into<[Field; N]> for U60Repr<N, NumSegments> {\n    fn into(x: U60Repr<N, NumSegments>) -> [Field; N] {\n        let mut result: [Field; N] = [0; N];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..N {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::cmp::Eq for U60Repr<N, NumSegments> {\n    fn eq(self, other: Self) -> bool {\n        self.limbs == other.limbs\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> U60Repr<N, NumSegments> {\n\n    pub(crate) fn new<let NumFieldSegments: u32>(x: [Field; N * NumFieldSegments]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N * NumFieldSegments) {\n            let (lo, hi) = split_bits::split_60_bits(x[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n\n    pub(crate) fn one() -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub(crate) unconstrained fn from_field(input: Field) -> Self {\n        let (first, second, third, fourth, fifth) = field_to_u60rep(input);\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        let N_u60: u32 = N * NumSegments;\n        assert(N_u60 >= 1, \"N must be at least 1\");\n        if N_u60 == 1 {\n            assert(\n                (second == 0) & (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in a single limb\",\n            );\n            result.limbs[0] = first;\n        } else if N_u60 == 2 {\n            assert(\n                (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in two limbs\",\n            );\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n        } else if N_u60 == 3 {\n            assert((fourth == 0) & (fifth == 0), \"input field is too large to fit in three limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n        } else if N_u60 == 4 {\n            assert((fifth == 0), \"input field is too large to fit in four limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n        } else {\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n            result.limbs[4] = fifth;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn into_field_array(\n        x: U60Repr<N, NumSegments>,\n    ) -> [Field; N * NumSegments / 2] {\n        let mut result: [Field; N * NumSegments / 2] = [0; N * NumSegments / 2];\n        for i in 0..(N * NumSegments / 2) {\n            result[i] =\n                x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * TWO_POW_60 as Field);\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn gte(self, b: Self) -> bool {\n        let mut result = false;\n        let mut early_exit = false;\n        for i in 0..(N * NumSegments) {\n            let idx = (N * NumSegments) - 1 - i;\n            if (b.limbs[idx] == self.limbs[idx]) {\n                continue;\n            }\n\n            result = b.limbs[idx] < self.limbs[idx];\n            early_exit = true;\n            break;\n        }\n        if early_exit {\n            result\n        } else {\n            self.limbs[0] == b.limbs[0]\n        }\n    }\n\n    pub(crate) fn get_bit(self, bit: u32) -> bool {\n        let segment_index = bit / 60;\n        let uint_index = bit % 60;\n\n        let limb: u64 = self.limbs[segment_index];\n        let value = (limb >> uint_index as u8) & 1;\n        value == 1\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift = (60 - limb_shift) as u8;\n        let mask: u64 = (((1 as u64) << limb_shift) - 1) << remainder_shift;\n        result.limbs[0] = (self.limbs[0 + num_shifted_limbs] >> limb_shift);\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i + num_shifted_limbs];\n            result.limbs[i] = value >> limb_shift;\n            let remainder: u64 = (value << remainder_shift) & mask;\n            result.limbs[i - 1] = result.limbs[i - 1] + remainder;\n        }\n        result\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr1(&mut self) {\n        let value = self.limbs[NumSegments * N - 1];\n        self.limbs[NumSegments * N - 1] = value >> 1;\n\n        let mut remainder = (value & 1) << 59;\n\n        for i in 0..N * NumSegments {\n            let value = self.limbs[N * NumSegments - 1 - i];\n            self.limbs[N * NumSegments - 1 - i] = (value >> 1) + remainder;\n            remainder = (value << 59) & 0x800000000000000;\n        }\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shl(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; NumSegments * N] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift: u8 = 60 - limb_shift as u8;\n\n        // 83\n        // limb shift = 1\n        // inside shift = 19 bits to the left\n        // meaning we have 19 carry bits and 41 remainder bits\n        let mask: u64 = (1 as u64 << 60) - 1;\n        //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        let value = self.limbs[0];\n\n        let mut remainder = (value >> remainder_shift);\n        result.limbs[num_shifted_limbs] = (value << limb_shift) & mask;\n\n        // shift 84. num shifted = 1\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i];\n            let upshift = ((value << limb_shift) + remainder) & mask;\n            result.limbs[i + num_shifted_limbs] = upshift;\n            remainder = (value >> remainder_shift);\n            // let remainder: u64 = (self.limbs.get(i + num_shifted_limbs as u64) << remainder_shift as u8) & mask;\n            // result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    pub(crate) fn increment(&mut self) {\n        let mut carry: u64 = 0;\n\n        let mut add: u64 = self.limbs[0] + 1;\n        carry = add >> 60;\n        add = add - (carry << 60);\n        self.limbs[0] = add;\n\n        for i in 1..NumSegments * N {\n            let mut add: u64 = self.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            self.limbs[i] = add;\n        }\n    }\n\n    pub(crate) unconstrained fn get_msb(val: Self) -> u32 {\n        let mut count = 0;\n        for i in 0..N * NumSegments {\n            let v = val.limbs[((N * NumSegments) - 1 - i)];\n            if (v > 0) {\n                count = 60 * ((N * NumSegments) - 1 - i) + get_msb64(v);\n                break;\n            }\n        }\n        count\n    }\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir-bignum/v0.5.2/src/utils/u60_representation.nr"},"209":{"source":"use dep::bignum::{params::BigNumParams, RuntimeBigNum};\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme.\n * @note The `exponent` can be either 65537 or 3 (i.e. the most common values in use for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    assert((exponent == 3) | (exponent == 65537), \"Exponent must be 65537 or 3\");\n    let mut exponentiated = sig * sig; // sig^2\n    if exponent == 65537 {\n        // e = 65537 = 1 0000 0000 0000 0001\n        exponentiated = exponentiated * exponentiated; // sig^4\n        exponentiated = exponentiated * exponentiated; // sig^8\n        exponentiated = exponentiated * exponentiated; // sig^16\n        exponentiated = exponentiated * exponentiated; // sig^32\n        exponentiated = exponentiated * exponentiated; // sig^64\n        exponentiated = exponentiated * exponentiated; // sig^128\n        exponentiated = exponentiated * exponentiated; // sig^256\n        exponentiated = exponentiated * exponentiated; // sig^512\n        exponentiated = exponentiated * exponentiated; // sig^1024\n        exponentiated = exponentiated * exponentiated; // sig^2048\n        exponentiated = exponentiated * exponentiated; // sig^4096\n        exponentiated = exponentiated * exponentiated; // sig^8192\n        exponentiated = exponentiated * exponentiated; // sig^16384\n        exponentiated = exponentiated * exponentiated; // sig^32768\n        exponentiated = exponentiated * exponentiated; // sig^65536\n    }\n    // otherwise, e = 3 = 11\n    exponentiated = exponentiated * sig; // either sig^2 * sig = sig^3 or sig^65536 * sig = sig^65537\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_1024() {\n    // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"hello world! test#123\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170,\n                193, 96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n            ],\n    );\n\n    let params: BigNumParams<9, 1024> = BigNumParams::new(\n        false,\n        [\n            0xab238ad9cb37979a43aefbf10be8fb,\n            0x31347febe45fe8c2dac1dd30900704,\n            0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n            0x5eac6390f7873fe97ff9bb14a173ea,\n            0xbc41f700c91fd733a2c63177bbdbd4,\n            0x41442bd58769a3595b659a2ec9c6be,\n            0x4ddc91395f330382aa2e2d3fbe147,\n            0x3d008ff255a0bc71c7887f5728ba1,\n            0xb640c3a8f511c64e,\n        ],\n        [\n            0x5d53d2634c6a0918266043968ce263,\n            0x5dd4be3dce0323a492ee9340aec4db,\n            0xf82d0e2e5c8319f01a460c72c01854,\n            0x236e6fc6e62e8a1d522acda5fb3892,\n            0xdaf755619d66e580901aa224d03174,\n            0x8366291616480e7e1f202dbcedda87,\n            0x40ba1202537d1e94561ccc05265586,\n            0x69b993d857ba89ea5de9822aeb4b93,\n            0x167968c0000761a273,\n        ],\n    );\n\n    let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xc3850e84ea02da3f028ff422f4d6a9,\n            0x9761f0bd9021f76d45c60df0670a19,\n            0xc1ede421a43607ab623ed4d5a17fc8,\n            0x86197b4315206f4d53200b42555831,\n            0xe95783b69db28c26a83706f39d04cd,\n            0x18b178dc1a9ec76fb22b57e4dfa703,\n            0xdd0e19cd5a09ab48e7af4d0e3470e3,\n            0x10004dfab1cf91304e80e6baa4dfc7,\n            0x241c3fd77b90adef,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048() {\n    // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"Hello World! This is Noir-RSA\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131,\n                166, 79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n            ],\n    );\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n            0xbfb937fc4d3cf02cc0af780f3cab44,\n            0xd20637ef7adcf5d238ee87bccc9bca,\n            0xb9db4f2663108e2f8b673f7612ae8b,\n            0x85f894ef669b36bfd3d86b0a28873,\n            0xdcc70e1884e38b8229cce3b884121d,\n            0x35488d1138e0b03e1676f7f5d8a5b3,\n            0xe1a97820e7dcbb4eab35c9b71bb273,\n            0x97d19eb3c63249ddbfcff915863f54,\n            0x3a78c7af6da0f6af0d67b1ca4b6065,\n            0xd7a3c433c020f624821e5e678c7d69,\n            0x52d5b53240feae82ffea3d2a3d9b09,\n            0xb8aad5e19e2163f68997c6fdd71906,\n            0x5db432d06e8b0bf59511100c7894e2,\n            0xadc0bbc4c54da10d1cc88438ea3127,\n            0xece1cf6a1501109cd2734d5893c8d9,\n            0x7196b90acdf06c31b1288064fd0c27,\n            0xc8,\n        ],\n        [\n            0x1b1deccf4dbde852c34a5d6908a0f,\n            0xbc9e5bdab22f023fbcca58692bccf5,\n            0x1f65439685623e45396ff55751c3bf,\n            0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n            0x5ca2e8e3048243c16c708a8030ab0d,\n            0x30079bfeb1fa51e5501581173ca19c,\n            0xff8d5f6bea485fdcc2716327f69ab4,\n            0x36b599d81589416b5b5f037986b999,\n            0x75612e34a4ff29f0a19a7823512f58,\n            0x288b6897929b54c3b26a5faa07c00f,\n            0x4b5675fa13ab7444f1f047d3eb1bbe,\n            0x6ba0ac610ef9f267ab30fe25bb1c84,\n            0xa386b48ee03168d5cea3ecb9dc901f,\n            0xacf1a01f7dba44e050c976142fb1f6,\n            0x97a63b5cb7efc60d3502946aec63cf,\n            0x12cc1d5cab10a1e9e2398d29b9e3ef,\n            0x4635cf25c66e76bba8034df46204fb,\n            0x146f,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xad29e07d16a278de49a371b9760a27,\n            0x86311920cc0e17a3c20cdff4c56dbb,\n            0x863556c6c5247dd83668dd825716ae,\n            0xc247c960945f4485b46c33b87425ca,\n            0x7326463c5c4cd5b08e21b938d9ed9a,\n            0x4f89fe0c82da08a0259eddb34d0da1,\n            0x43a74e76d4e1bd2666f1591889af0d,\n            0x240f7b80f0ff29f4253ee3019f832d,\n            0xc6edd131fbaaf725fd423dac52b362,\n            0x85f9732679242163e8afff44f6104d,\n            0xd3c3bbcb1757013fd6fb80f31dd9a6,\n            0x9008633f15df440e6df6d21ee585a2,\n            0x324df3425ed256e283be5b6b761741,\n            0xc60c1302929bd0e07caa4aeff4e8fd,\n            0x600d804ff13ba8d0e1bc9508714212,\n            0x50f7e75e5751d7edd61167027926be,\n            0x0db41d39442023e1420a8a84fe81d9,\n            0xab,\n        ],\n    };\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n    // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"hello world\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132,\n                239, 227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n            ],\n    );\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0xe40ee47801326543c8e84b85d567c1,\n            0x5b54ea87f0ce29de1995697b0696fd,\n            0x457078f8fdce68b437cac0970b2452,\n            0x473ec776fee3731b6ab06e35875ddc,\n            0x62dedd594e5f12c80c3ccb5791a6cd,\n            0xecb934b9d8272c5e3a418145345499,\n            0xd1af643b3d785470ed0c6cd633f706,\n            0xb58a57b9e96eccbdfc7c17f0333d4,\n            0x2ebd34b5039fc596504927c282c60d,\n            0x3a44928a74f25fc1043bb37ce4dfa8,\n            0x91448459f9617fac33a2816162ac9e,\n            0x70cb910d9f3e1a78864640ec6c8240,\n            0x9aed33f6b31f1c9de67248a98c180,\n            0x7f1416e032c79488c94b311e87bd9c,\n            0x7191b4ebb1b3fffa949fa48ed01e5,\n            0x350a75cbaeca6bfdd71ca83cdbcae9,\n            0xfb1d274fa207457c6814d42c09f9cf,\n            0xd4,\n        ],\n        [\n            0x803bf4d38110a7d37fdd05f590dee9,\n            0xa68d317c933f37cab5ab4e7c00a3b9,\n            0x476a05a536bf5f2aa1b8850146cba7,\n            0xca297ea8b5528d91d4836ff27c30ab,\n            0x75cf2eaab76eefa12bbd570f1aea9f,\n            0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n            0xd497db1f6ebe83decacaa647fabea6,\n            0x686b27ca330e25e7a7cf197f6433ef,\n            0xfde04d2225c8308b07580af0058a0f,\n            0xa29fb69777c0e916976243b2b09855,\n            0xf983592285852e7e1c2cb3ae968323,\n            0x673608017f9f5acf67a01b73728d70,\n            0xeeff82521c0bc432a05f4b7444fac0,\n            0x85a89c4d229f60aaa3aa7ac7dac1e2,\n            0xcfecff93bc9fbfe0d6dff6091f2db8,\n            0xf20f047dcb224b4447bd098c07f8c2,\n            0x554bb53cadeb3eaab911a189f90227,\n            0x133b,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xa250eff812c63eaaeaa3f04641c05f,\n            0xecc09613cb8b289c1f37c8f92e6a05,\n            0x2c0a0510058360c07af65d46f594fd,\n            0x943d67513363d3de430c94a1dafe7c,\n            0x511ec8e9b10bc6c6ff0d6c232ccf92,\n            0x50ffd07b3c093b3f5fc027de847731,\n            0xc268e1489449943fdafdf89ff168c3,\n            0x0b8b7f9f49b492f78fda58d252f23a,\n            0x491c6c4ef836a6a8730b7bf81e865e,\n            0x8746c75fb079d014e419543f56d7f0,\n            0x65804c417d6168a8bc0025d255cebf,\n            0xf695e91b77890b8e3fd775fa56e627,\n            0x5e90001c0218550f4083ae28025a2f,\n            0x526bd4eff34f25f62a698f0470e0a6,\n            0x7f224306a7d9daf536b1559434c6c6,\n            0x88809f16fe1fcea3c87511d9319735,\n            0x7694685fee0bfab4a9196b92ec6f2e,\n            0xa7,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/noir_rsa/v0.5.1/lib/src/rsa.nr"}},"names":["main"],"brillig_names":["build_msg_block_iter","pad_msg_block","attach_len_to_msg_block","__mul","__compute_quadratic_expression_with_borrow_flags","extract_claim_unconstrained","__boundary_check","__validate_decoded","search","get_lt_predicate_f","extract_claim_unconstrained","get_domain_start_index_in_email","__split_60_bits","__mul","__compute_quadratic_expression_with_borrow_flags","decompose_hint","is_position_found_in_email_body","is_salary_found_in_email_body","directive_integer_quotient","directive_invert","directive_to_radix"]}